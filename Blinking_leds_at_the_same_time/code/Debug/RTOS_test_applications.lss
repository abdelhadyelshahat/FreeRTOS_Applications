
RTOS_test_applications.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004984  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000020  00800060  00004984  00004a18  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000051a  00800080  00800080  00004a38  2**0
                  ALLOC
  3 .stab         00007320  00000000  00000000  00004a38  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003b84  00000000  00000000  0000bd58  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 a0 0c 	jmp	0x1940	; 0x1940 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e8       	ldi	r30, 0x84	; 132
      68:	f9 e4       	ldi	r31, 0x49	; 73
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 38       	cpi	r26, 0x80	; 128
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	a0 e8       	ldi	r26, 0x80	; 128
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	aa 39       	cpi	r26, 0x9A	; 154
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 df 23 	call	0x47be	; 0x47be <main>
      8a:	0c 94 c0 24 	jmp	0x4980	; 0x4980 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	df 93       	push	r29
      a2:	cf 93       	push	r28
      a4:	0f 92       	push	r0
      a6:	cd b7       	in	r28, 0x3d	; 61
      a8:	de b7       	in	r29, 0x3e	; 62
      aa:	89 83       	std	Y+1, r24	; 0x01
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
      ac:	8a e0       	ldi	r24, 0x0A	; 10
      ae:	62 e0       	ldi	r22, 0x02	; 2
      b0:	40 e0       	ldi	r20, 0x00	; 0
      b2:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <xQueueGenericCreate>
      b6:	90 93 83 00 	sts	0x0083, r25
      ba:	80 93 82 00 	sts	0x0082, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
      be:	8d ec       	ldi	r24, 0xCD	; 205
      c0:	90 e0       	ldi	r25, 0x00	; 0
      c2:	20 e6       	ldi	r18, 0x60	; 96
      c4:	30 e0       	ldi	r19, 0x00	; 0
      c6:	e2 e8       	ldi	r30, 0x82	; 130
      c8:	f0 e0       	ldi	r31, 0x00	; 0
      ca:	b9 01       	movw	r22, r18
      cc:	45 e5       	ldi	r20, 0x55	; 85
      ce:	50 e0       	ldi	r21, 0x00	; 0
      d0:	9f 01       	movw	r18, r30
      d2:	09 81       	ldd	r16, Y+1	; 0x01
      d4:	ee 24       	eor	r14, r14
      d6:	ff 24       	eor	r15, r15
      d8:	cc 24       	eor	r12, r12
      da:	dd 24       	eor	r13, r13
      dc:	aa 24       	eor	r10, r10
      de:	bb 24       	eor	r11, r11
      e0:	0e 94 4f 14 	call	0x289e	; 0x289e <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
      e4:	80 e9       	ldi	r24, 0x90	; 144
      e6:	90 e0       	ldi	r25, 0x00	; 0
      e8:	28 e6       	ldi	r18, 0x68	; 104
      ea:	30 e0       	ldi	r19, 0x00	; 0
      ec:	e2 e8       	ldi	r30, 0x82	; 130
      ee:	f0 e0       	ldi	r31, 0x00	; 0
      f0:	b9 01       	movw	r22, r18
      f2:	45 e5       	ldi	r20, 0x55	; 85
      f4:	50 e0       	ldi	r21, 0x00	; 0
      f6:	9f 01       	movw	r18, r30
      f8:	09 81       	ldd	r16, Y+1	; 0x01
      fa:	ee 24       	eor	r14, r14
      fc:	ff 24       	eor	r15, r15
      fe:	cc 24       	eor	r12, r12
     100:	dd 24       	eor	r13, r13
     102:	aa 24       	eor	r10, r10
     104:	bb 24       	eor	r11, r11
     106:	0e 94 4f 14 	call	0x289e	; 0x289e <xTaskGenericCreate>
}
     10a:	0f 90       	pop	r0
     10c:	cf 91       	pop	r28
     10e:	df 91       	pop	r29
     110:	0f 91       	pop	r16
     112:	ff 90       	pop	r15
     114:	ef 90       	pop	r14
     116:	df 90       	pop	r13
     118:	cf 90       	pop	r12
     11a:	bf 90       	pop	r11
     11c:	af 90       	pop	r10
     11e:	08 95       	ret

00000120 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
     120:	df 93       	push	r29
     122:	cf 93       	push	r28
     124:	00 d0       	rcall	.+0      	; 0x126 <vPolledQueueProducer+0x6>
     126:	00 d0       	rcall	.+0      	; 0x128 <vPolledQueueProducer+0x8>
     128:	00 d0       	rcall	.+0      	; 0x12a <vPolledQueueProducer+0xa>
     12a:	cd b7       	in	r28, 0x3d	; 61
     12c:	de b7       	in	r29, 0x3e	; 62
     12e:	9e 83       	std	Y+6, r25	; 0x06
     130:	8d 83       	std	Y+5, r24	; 0x05
uint16_t usValue = ( uint16_t ) 0;
     132:	1c 82       	std	Y+4, r1	; 0x04
     134:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xError = pdFALSE, xLoop;
     136:	1a 82       	std	Y+2, r1	; 0x02

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     138:	19 82       	std	Y+1, r1	; 0x01
     13a:	27 c0       	rjmp	.+78     	; 0x18a <vPolledQueueProducer+0x6a>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
     13c:	ed 81       	ldd	r30, Y+5	; 0x05
     13e:	fe 81       	ldd	r31, Y+6	; 0x06
     140:	80 81       	ld	r24, Z
     142:	91 81       	ldd	r25, Z+1	; 0x01
     144:	9e 01       	movw	r18, r28
     146:	2d 5f       	subi	r18, 0xFD	; 253
     148:	3f 4f       	sbci	r19, 0xFF	; 255
     14a:	b9 01       	movw	r22, r18
     14c:	40 e0       	ldi	r20, 0x00	; 0
     14e:	50 e0       	ldi	r21, 0x00	; 0
     150:	20 e0       	ldi	r18, 0x00	; 0
     152:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <xQueueGenericSend>
     156:	81 30       	cpi	r24, 0x01	; 1
     158:	19 f0       	breq	.+6      	; 0x160 <vPolledQueueProducer+0x40>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
     15a:	81 e0       	ldi	r24, 0x01	; 1
     15c:	8a 83       	std	Y+2, r24	; 0x02
     15e:	12 c0       	rjmp	.+36     	; 0x184 <vPolledQueueProducer+0x64>
			}
			else
			{
				if( xError == pdFALSE )
     160:	8a 81       	ldd	r24, Y+2	; 0x02
     162:	88 23       	and	r24, r24
     164:	51 f4       	brne	.+20     	; 0x17a <vPolledQueueProducer+0x5a>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
     166:	0f b6       	in	r0, 0x3f	; 63
     168:	f8 94       	cli
     16a:	0f 92       	push	r0
						xPollingProducerCount++;
     16c:	80 91 81 00 	lds	r24, 0x0081
     170:	8f 5f       	subi	r24, 0xFF	; 255
     172:	80 93 81 00 	sts	0x0081, r24
					portEXIT_CRITICAL();
     176:	0f 90       	pop	r0
     178:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
     17a:	8b 81       	ldd	r24, Y+3	; 0x03
     17c:	9c 81       	ldd	r25, Y+4	; 0x04
     17e:	01 96       	adiw	r24, 0x01	; 1
     180:	9c 83       	std	Y+4, r25	; 0x04
     182:	8b 83       	std	Y+3, r24	; 0x03
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     184:	89 81       	ldd	r24, Y+1	; 0x01
     186:	8f 5f       	subi	r24, 0xFF	; 255
     188:	89 83       	std	Y+1, r24	; 0x01
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	83 30       	cpi	r24, 0x03	; 3
     18e:	b4 f2       	brlt	.-84     	; 0x13c <vPolledQueueProducer+0x1c>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
     190:	88 ec       	ldi	r24, 0xC8	; 200
     192:	90 e0       	ldi	r25, 0x00	; 0
     194:	0e 94 09 16 	call	0x2c12	; 0x2c12 <vTaskDelay>
     198:	cf cf       	rjmp	.-98     	; 0x138 <vPolledQueueProducer+0x18>

0000019a <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
     19a:	df 93       	push	r29
     19c:	cf 93       	push	r28
     19e:	cd b7       	in	r28, 0x3d	; 61
     1a0:	de b7       	in	r29, 0x3e	; 62
     1a2:	27 97       	sbiw	r28, 0x07	; 7
     1a4:	0f b6       	in	r0, 0x3f	; 63
     1a6:	f8 94       	cli
     1a8:	de bf       	out	0x3e, r29	; 62
     1aa:	0f be       	out	0x3f, r0	; 63
     1ac:	cd bf       	out	0x3d, r28	; 61
     1ae:	9f 83       	std	Y+7, r25	; 0x07
     1b0:	8e 83       	std	Y+6, r24	; 0x06
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
     1b2:	1b 82       	std	Y+3, r1	; 0x03
     1b4:	1a 82       	std	Y+2, r1	; 0x02
BaseType_t xError = pdFALSE;
     1b6:	19 82       	std	Y+1, r1	; 0x01
     1b8:	2f c0       	rjmp	.+94     	; 0x218 <vPolledQueueConsumer+0x7e>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
     1ba:	ee 81       	ldd	r30, Y+6	; 0x06
     1bc:	ff 81       	ldd	r31, Y+7	; 0x07
     1be:	80 81       	ld	r24, Z
     1c0:	91 81       	ldd	r25, Z+1	; 0x01
     1c2:	9e 01       	movw	r18, r28
     1c4:	2c 5f       	subi	r18, 0xFC	; 252
     1c6:	3f 4f       	sbci	r19, 0xFF	; 255
     1c8:	b9 01       	movw	r22, r18
     1ca:	40 e0       	ldi	r20, 0x00	; 0
     1cc:	50 e0       	ldi	r21, 0x00	; 0
     1ce:	20 e0       	ldi	r18, 0x00	; 0
     1d0:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <xQueueGenericReceive>
     1d4:	81 30       	cpi	r24, 0x01	; 1
     1d6:	01 f5       	brne	.+64     	; 0x218 <vPolledQueueConsumer+0x7e>
			{
				if( usData != usExpectedValue )
     1d8:	2c 81       	ldd	r18, Y+4	; 0x04
     1da:	3d 81       	ldd	r19, Y+5	; 0x05
     1dc:	8a 81       	ldd	r24, Y+2	; 0x02
     1de:	9b 81       	ldd	r25, Y+3	; 0x03
     1e0:	28 17       	cp	r18, r24
     1e2:	39 07       	cpc	r19, r25
     1e4:	39 f0       	breq	.+14     	; 0x1f4 <vPolledQueueConsumer+0x5a>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
     1e6:	81 e0       	ldi	r24, 0x01	; 1
     1e8:	89 83       	std	Y+1, r24	; 0x01

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
     1ea:	8c 81       	ldd	r24, Y+4	; 0x04
     1ec:	9d 81       	ldd	r25, Y+5	; 0x05
     1ee:	9b 83       	std	Y+3, r25	; 0x03
     1f0:	8a 83       	std	Y+2, r24	; 0x02
     1f2:	0d c0       	rjmp	.+26     	; 0x20e <vPolledQueueConsumer+0x74>
				}
				else
				{
					if( xError == pdFALSE )
     1f4:	89 81       	ldd	r24, Y+1	; 0x01
     1f6:	88 23       	and	r24, r24
     1f8:	51 f4       	brne	.+20     	; 0x20e <vPolledQueueConsumer+0x74>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
     1fa:	0f b6       	in	r0, 0x3f	; 63
     1fc:	f8 94       	cli
     1fe:	0f 92       	push	r0
							xPollingConsumerCount++;
     200:	80 91 80 00 	lds	r24, 0x0080
     204:	8f 5f       	subi	r24, 0xFF	; 255
     206:	80 93 80 00 	sts	0x0080, r24
						portEXIT_CRITICAL();
     20a:	0f 90       	pop	r0
     20c:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
     20e:	8a 81       	ldd	r24, Y+2	; 0x02
     210:	9b 81       	ldd	r25, Y+3	; 0x03
     212:	01 96       	adiw	r24, 0x01	; 1
     214:	9b 83       	std	Y+3, r25	; 0x03
     216:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
     218:	ee 81       	ldd	r30, Y+6	; 0x06
     21a:	ff 81       	ldd	r31, Y+7	; 0x07
     21c:	80 81       	ld	r24, Z
     21e:	91 81       	ldd	r25, Z+1	; 0x01
     220:	0e 94 73 10 	call	0x20e6	; 0x20e6 <uxQueueMessagesWaiting>
     224:	88 23       	and	r24, r24
     226:	49 f6       	brne	.-110    	; 0x1ba <vPolledQueueConsumer+0x20>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
     228:	84 eb       	ldi	r24, 0xB4	; 180
     22a:	90 e0       	ldi	r25, 0x00	; 0
     22c:	0e 94 09 16 	call	0x2c12	; 0x2c12 <vTaskDelay>
     230:	f3 cf       	rjmp	.-26     	; 0x218 <vPolledQueueConsumer+0x7e>

00000232 <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
BaseType_t xArePollingQueuesStillRunning( void )
{
     232:	df 93       	push	r29
     234:	cf 93       	push	r28
     236:	0f 92       	push	r0
     238:	cd b7       	in	r28, 0x3d	; 61
     23a:	de b7       	in	r29, 0x3e	; 62

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
     23c:	80 91 80 00 	lds	r24, 0x0080
     240:	88 23       	and	r24, r24
     242:	21 f0       	breq	.+8      	; 0x24c <xArePollingQueuesStillRunning+0x1a>
     244:	80 91 81 00 	lds	r24, 0x0081
     248:	88 23       	and	r24, r24
     24a:	11 f4       	brne	.+4      	; 0x250 <xArePollingQueuesStillRunning+0x1e>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
     24c:	19 82       	std	Y+1, r1	; 0x01
     24e:	02 c0       	rjmp	.+4      	; 0x254 <xArePollingQueuesStillRunning+0x22>
	}
	else
	{
		xReturn = pdTRUE;
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
     254:	10 92 80 00 	sts	0x0080, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
     258:	10 92 81 00 	sts	0x0081, r1

	return xReturn;
     25c:	89 81       	ldd	r24, Y+1	; 0x01
}
     25e:	0f 90       	pop	r0
     260:	cf 91       	pop	r28
     262:	df 91       	pop	r29
     264:	08 95       	ret

00000266 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     266:	df 93       	push	r29
     268:	cf 93       	push	r28
     26a:	cd b7       	in	r28, 0x3d	; 61
     26c:	de b7       	in	r29, 0x3e	; 62
     26e:	27 97       	sbiw	r28, 0x07	; 7
     270:	0f b6       	in	r0, 0x3f	; 63
     272:	f8 94       	cli
     274:	de bf       	out	0x3e, r29	; 62
     276:	0f be       	out	0x3f, r0	; 63
     278:	cd bf       	out	0x3d, r28	; 61
     27a:	9d 83       	std	Y+5, r25	; 0x05
     27c:	8c 83       	std	Y+4, r24	; 0x04
     27e:	6e 83       	std	Y+6, r22	; 0x06
     280:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     282:	8a e1       	ldi	r24, 0x1A	; 26
     284:	90 e0       	ldi	r25, 0x00	; 0
     286:	0e 94 4b 07 	call	0xe96	; 0xe96 <pvPortMalloc>
     28a:	9a 83       	std	Y+2, r25	; 0x02
     28c:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     28e:	89 81       	ldd	r24, Y+1	; 0x01
     290:	9a 81       	ldd	r25, Y+2	; 0x02
     292:	00 97       	sbiw	r24, 0x00	; 0
     294:	09 f4       	brne	.+2      	; 0x298 <xCoRoutineCreate+0x32>
     296:	6f c0       	rjmp	.+222    	; 0x376 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     298:	80 91 84 00 	lds	r24, 0x0084
     29c:	90 91 85 00 	lds	r25, 0x0085
     2a0:	00 97       	sbiw	r24, 0x00	; 0
     2a2:	41 f4       	brne	.+16     	; 0x2b4 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     2a4:	89 81       	ldd	r24, Y+1	; 0x01
     2a6:	9a 81       	ldd	r25, Y+2	; 0x02
     2a8:	90 93 85 00 	sts	0x0085, r25
     2ac:	80 93 84 00 	sts	0x0084, r24
			prvInitialiseCoRoutineLists();
     2b0:	0e 94 9a 03 	call	0x734	; 0x734 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     2b4:	8e 81       	ldd	r24, Y+6	; 0x06
     2b6:	82 30       	cpi	r24, 0x02	; 2
     2b8:	10 f0       	brcs	.+4      	; 0x2be <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     2ba:	81 e0       	ldi	r24, 0x01	; 1
     2bc:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     2be:	e9 81       	ldd	r30, Y+1	; 0x01
     2c0:	fa 81       	ldd	r31, Y+2	; 0x02
     2c2:	11 8e       	std	Z+25, r1	; 0x19
     2c4:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     2c6:	e9 81       	ldd	r30, Y+1	; 0x01
     2c8:	fa 81       	ldd	r31, Y+2	; 0x02
     2ca:	8e 81       	ldd	r24, Y+6	; 0x06
     2cc:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     2ce:	e9 81       	ldd	r30, Y+1	; 0x01
     2d0:	fa 81       	ldd	r31, Y+2	; 0x02
     2d2:	8f 81       	ldd	r24, Y+7	; 0x07
     2d4:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     2d6:	e9 81       	ldd	r30, Y+1	; 0x01
     2d8:	fa 81       	ldd	r31, Y+2	; 0x02
     2da:	8c 81       	ldd	r24, Y+4	; 0x04
     2dc:	9d 81       	ldd	r25, Y+5	; 0x05
     2de:	91 83       	std	Z+1, r25	; 0x01
     2e0:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
     2e4:	9a 81       	ldd	r25, Y+2	; 0x02
     2e6:	02 96       	adiw	r24, 0x02	; 2
     2e8:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	0c 96       	adiw	r24, 0x0c	; 12
     2f2:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     2f6:	e9 81       	ldd	r30, Y+1	; 0x01
     2f8:	fa 81       	ldd	r31, Y+2	; 0x02
     2fa:	89 81       	ldd	r24, Y+1	; 0x01
     2fc:	9a 81       	ldd	r25, Y+2	; 0x02
     2fe:	91 87       	std	Z+9, r25	; 0x09
     300:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     302:	e9 81       	ldd	r30, Y+1	; 0x01
     304:	fa 81       	ldd	r31, Y+2	; 0x02
     306:	89 81       	ldd	r24, Y+1	; 0x01
     308:	9a 81       	ldd	r25, Y+2	; 0x02
     30a:	93 8b       	std	Z+19, r25	; 0x13
     30c:	82 8b       	std	Z+18, r24	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     30e:	8e 81       	ldd	r24, Y+6	; 0x06
     310:	28 2f       	mov	r18, r24
     312:	30 e0       	ldi	r19, 0x00	; 0
     314:	82 e0       	ldi	r24, 0x02	; 2
     316:	90 e0       	ldi	r25, 0x00	; 0
     318:	82 1b       	sub	r24, r18
     31a:	93 0b       	sbc	r25, r19
     31c:	e9 81       	ldd	r30, Y+1	; 0x01
     31e:	fa 81       	ldd	r31, Y+2	; 0x02
     320:	95 87       	std	Z+13, r25	; 0x0d
     322:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     324:	e9 81       	ldd	r30, Y+1	; 0x01
     326:	fa 81       	ldd	r31, Y+2	; 0x02
     328:	96 89       	ldd	r25, Z+22	; 0x16
     32a:	80 91 86 00 	lds	r24, 0x0086
     32e:	89 17       	cp	r24, r25
     330:	28 f4       	brcc	.+10     	; 0x33c <xCoRoutineCreate+0xd6>
     332:	e9 81       	ldd	r30, Y+1	; 0x01
     334:	fa 81       	ldd	r31, Y+2	; 0x02
     336:	86 89       	ldd	r24, Z+22	; 0x16
     338:	80 93 86 00 	sts	0x0086, r24
     33c:	e9 81       	ldd	r30, Y+1	; 0x01
     33e:	fa 81       	ldd	r31, Y+2	; 0x02
     340:	86 89       	ldd	r24, Z+22	; 0x16
     342:	28 2f       	mov	r18, r24
     344:	30 e0       	ldi	r19, 0x00	; 0
     346:	c9 01       	movw	r24, r18
     348:	88 0f       	add	r24, r24
     34a:	99 1f       	adc	r25, r25
     34c:	88 0f       	add	r24, r24
     34e:	99 1f       	adc	r25, r25
     350:	88 0f       	add	r24, r24
     352:	99 1f       	adc	r25, r25
     354:	82 0f       	add	r24, r18
     356:	93 1f       	adc	r25, r19
     358:	ac 01       	movw	r20, r24
     35a:	43 57       	subi	r20, 0x73	; 115
     35c:	5f 4f       	sbci	r21, 0xFF	; 255
     35e:	89 81       	ldd	r24, Y+1	; 0x01
     360:	9a 81       	ldd	r25, Y+2	; 0x02
     362:	9c 01       	movw	r18, r24
     364:	2e 5f       	subi	r18, 0xFE	; 254
     366:	3f 4f       	sbci	r19, 0xFF	; 255
     368:	ca 01       	movw	r24, r20
     36a:	b9 01       	movw	r22, r18
     36c:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

		xReturn = pdPASS;
     370:	81 e0       	ldi	r24, 0x01	; 1
     372:	8b 83       	std	Y+3, r24	; 0x03
     374:	02 c0       	rjmp	.+4      	; 0x37a <xCoRoutineCreate+0x114>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     376:	8f ef       	ldi	r24, 0xFF	; 255
     378:	8b 83       	std	Y+3, r24	; 0x03
	}

	return xReturn;
     37a:	8b 81       	ldd	r24, Y+3	; 0x03
}
     37c:	27 96       	adiw	r28, 0x07	; 7
     37e:	0f b6       	in	r0, 0x3f	; 63
     380:	f8 94       	cli
     382:	de bf       	out	0x3e, r29	; 62
     384:	0f be       	out	0x3f, r0	; 63
     386:	cd bf       	out	0x3d, r28	; 61
     388:	cf 91       	pop	r28
     38a:	df 91       	pop	r29
     38c:	08 95       	ret

0000038e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     38e:	df 93       	push	r29
     390:	cf 93       	push	r28
     392:	00 d0       	rcall	.+0      	; 0x394 <vCoRoutineAddToDelayedList+0x6>
     394:	00 d0       	rcall	.+0      	; 0x396 <vCoRoutineAddToDelayedList+0x8>
     396:	00 d0       	rcall	.+0      	; 0x398 <vCoRoutineAddToDelayedList+0xa>
     398:	cd b7       	in	r28, 0x3d	; 61
     39a:	de b7       	in	r29, 0x3e	; 62
     39c:	9c 83       	std	Y+4, r25	; 0x04
     39e:	8b 83       	std	Y+3, r24	; 0x03
     3a0:	7e 83       	std	Y+6, r23	; 0x06
     3a2:	6d 83       	std	Y+5, r22	; 0x05
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     3a4:	20 91 87 00 	lds	r18, 0x0087
     3a8:	30 91 88 00 	lds	r19, 0x0088
     3ac:	8b 81       	ldd	r24, Y+3	; 0x03
     3ae:	9c 81       	ldd	r25, Y+4	; 0x04
     3b0:	82 0f       	add	r24, r18
     3b2:	93 1f       	adc	r25, r19
     3b4:	9a 83       	std	Y+2, r25	; 0x02
     3b6:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3b8:	80 91 84 00 	lds	r24, 0x0084
     3bc:	90 91 85 00 	lds	r25, 0x0085
     3c0:	02 96       	adiw	r24, 0x02	; 2
     3c2:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     3c6:	e0 91 84 00 	lds	r30, 0x0084
     3ca:	f0 91 85 00 	lds	r31, 0x0085
     3ce:	89 81       	ldd	r24, Y+1	; 0x01
     3d0:	9a 81       	ldd	r25, Y+2	; 0x02
     3d2:	93 83       	std	Z+3, r25	; 0x03
     3d4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     3d6:	20 91 87 00 	lds	r18, 0x0087
     3da:	30 91 88 00 	lds	r19, 0x0088
     3de:	89 81       	ldd	r24, Y+1	; 0x01
     3e0:	9a 81       	ldd	r25, Y+2	; 0x02
     3e2:	82 17       	cp	r24, r18
     3e4:	93 07       	cpc	r25, r19
     3e6:	70 f4       	brcc	.+28     	; 0x404 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3e8:	80 91 b3 00 	lds	r24, 0x00B3
     3ec:	90 91 b4 00 	lds	r25, 0x00B4
     3f0:	20 91 84 00 	lds	r18, 0x0084
     3f4:	30 91 85 00 	lds	r19, 0x0085
     3f8:	2e 5f       	subi	r18, 0xFE	; 254
     3fa:	3f 4f       	sbci	r19, 0xFF	; 255
     3fc:	b9 01       	movw	r22, r18
     3fe:	0e 94 17 09 	call	0x122e	; 0x122e <vListInsert>
     402:	0d c0       	rjmp	.+26     	; 0x41e <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     404:	80 91 b1 00 	lds	r24, 0x00B1
     408:	90 91 b2 00 	lds	r25, 0x00B2
     40c:	20 91 84 00 	lds	r18, 0x0084
     410:	30 91 85 00 	lds	r19, 0x0085
     414:	2e 5f       	subi	r18, 0xFE	; 254
     416:	3f 4f       	sbci	r19, 0xFF	; 255
     418:	b9 01       	movw	r22, r18
     41a:	0e 94 17 09 	call	0x122e	; 0x122e <vListInsert>
	}

	if( pxEventList )
     41e:	8d 81       	ldd	r24, Y+5	; 0x05
     420:	9e 81       	ldd	r25, Y+6	; 0x06
     422:	00 97       	sbiw	r24, 0x00	; 0
     424:	61 f0       	breq	.+24     	; 0x43e <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     426:	80 91 84 00 	lds	r24, 0x0084
     42a:	90 91 85 00 	lds	r25, 0x0085
     42e:	9c 01       	movw	r18, r24
     430:	24 5f       	subi	r18, 0xF4	; 244
     432:	3f 4f       	sbci	r19, 0xFF	; 255
     434:	8d 81       	ldd	r24, Y+5	; 0x05
     436:	9e 81       	ldd	r25, Y+6	; 0x06
     438:	b9 01       	movw	r22, r18
     43a:	0e 94 17 09 	call	0x122e	; 0x122e <vListInsert>
	}
}
     43e:	26 96       	adiw	r28, 0x06	; 6
     440:	0f b6       	in	r0, 0x3f	; 63
     442:	f8 94       	cli
     444:	de bf       	out	0x3e, r29	; 62
     446:	0f be       	out	0x3f, r0	; 63
     448:	cd bf       	out	0x3d, r28	; 61
     44a:	cf 91       	pop	r28
     44c:	df 91       	pop	r29
     44e:	08 95       	ret

00000450 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     450:	df 93       	push	r29
     452:	cf 93       	push	r28
     454:	00 d0       	rcall	.+0      	; 0x456 <prvCheckPendingReadyList+0x6>
     456:	cd b7       	in	r28, 0x3d	; 61
     458:	de b7       	in	r29, 0x3e	; 62
     45a:	3a c0       	rjmp	.+116    	; 0x4d0 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     45c:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     45e:	e0 91 ba 00 	lds	r30, 0x00BA
     462:	f0 91 bb 00 	lds	r31, 0x00BB
     466:	86 81       	ldd	r24, Z+6	; 0x06
     468:	97 81       	ldd	r25, Z+7	; 0x07
     46a:	9a 83       	std	Y+2, r25	; 0x02
     46c:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     46e:	89 81       	ldd	r24, Y+1	; 0x01
     470:	9a 81       	ldd	r25, Y+2	; 0x02
     472:	0c 96       	adiw	r24, 0x0c	; 12
     474:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     478:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     47a:	89 81       	ldd	r24, Y+1	; 0x01
     47c:	9a 81       	ldd	r25, Y+2	; 0x02
     47e:	02 96       	adiw	r24, 0x02	; 2
     480:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     484:	e9 81       	ldd	r30, Y+1	; 0x01
     486:	fa 81       	ldd	r31, Y+2	; 0x02
     488:	96 89       	ldd	r25, Z+22	; 0x16
     48a:	80 91 86 00 	lds	r24, 0x0086
     48e:	89 17       	cp	r24, r25
     490:	28 f4       	brcc	.+10     	; 0x49c <prvCheckPendingReadyList+0x4c>
     492:	e9 81       	ldd	r30, Y+1	; 0x01
     494:	fa 81       	ldd	r31, Y+2	; 0x02
     496:	86 89       	ldd	r24, Z+22	; 0x16
     498:	80 93 86 00 	sts	0x0086, r24
     49c:	e9 81       	ldd	r30, Y+1	; 0x01
     49e:	fa 81       	ldd	r31, Y+2	; 0x02
     4a0:	86 89       	ldd	r24, Z+22	; 0x16
     4a2:	28 2f       	mov	r18, r24
     4a4:	30 e0       	ldi	r19, 0x00	; 0
     4a6:	c9 01       	movw	r24, r18
     4a8:	88 0f       	add	r24, r24
     4aa:	99 1f       	adc	r25, r25
     4ac:	88 0f       	add	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	88 0f       	add	r24, r24
     4b2:	99 1f       	adc	r25, r25
     4b4:	82 0f       	add	r24, r18
     4b6:	93 1f       	adc	r25, r19
     4b8:	ac 01       	movw	r20, r24
     4ba:	43 57       	subi	r20, 0x73	; 115
     4bc:	5f 4f       	sbci	r21, 0xFF	; 255
     4be:	89 81       	ldd	r24, Y+1	; 0x01
     4c0:	9a 81       	ldd	r25, Y+2	; 0x02
     4c2:	9c 01       	movw	r18, r24
     4c4:	2e 5f       	subi	r18, 0xFE	; 254
     4c6:	3f 4f       	sbci	r19, 0xFF	; 255
     4c8:	ca 01       	movw	r24, r20
     4ca:	b9 01       	movw	r22, r18
     4cc:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     4d0:	80 91 b5 00 	lds	r24, 0x00B5
     4d4:	88 23       	and	r24, r24
     4d6:	09 f0       	breq	.+2      	; 0x4da <prvCheckPendingReadyList+0x8a>
     4d8:	c1 cf       	rjmp	.-126    	; 0x45c <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
     4da:	0f 90       	pop	r0
     4dc:	0f 90       	pop	r0
     4de:	cf 91       	pop	r28
     4e0:	df 91       	pop	r29
     4e2:	08 95       	ret

000004e4 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     4e4:	df 93       	push	r29
     4e6:	cf 93       	push	r28
     4e8:	00 d0       	rcall	.+0      	; 0x4ea <prvCheckDelayedList+0x6>
     4ea:	00 d0       	rcall	.+0      	; 0x4ec <prvCheckDelayedList+0x8>
     4ec:	cd b7       	in	r28, 0x3d	; 61
     4ee:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     4f0:	0e 94 13 18 	call	0x3026	; 0x3026 <xTaskGetTickCount>
     4f4:	20 91 89 00 	lds	r18, 0x0089
     4f8:	30 91 8a 00 	lds	r19, 0x008A
     4fc:	82 1b       	sub	r24, r18
     4fe:	93 0b       	sbc	r25, r19
     500:	90 93 8c 00 	sts	0x008C, r25
     504:	80 93 8b 00 	sts	0x008B, r24
     508:	85 c0       	rjmp	.+266    	; 0x614 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     50a:	80 91 87 00 	lds	r24, 0x0087
     50e:	90 91 88 00 	lds	r25, 0x0088
     512:	01 96       	adiw	r24, 0x01	; 1
     514:	90 93 88 00 	sts	0x0088, r25
     518:	80 93 87 00 	sts	0x0087, r24
		xPassedTicks--;
     51c:	80 91 8b 00 	lds	r24, 0x008B
     520:	90 91 8c 00 	lds	r25, 0x008C
     524:	01 97       	sbiw	r24, 0x01	; 1
     526:	90 93 8c 00 	sts	0x008C, r25
     52a:	80 93 8b 00 	sts	0x008B, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     52e:	80 91 87 00 	lds	r24, 0x0087
     532:	90 91 88 00 	lds	r25, 0x0088
     536:	00 97       	sbiw	r24, 0x00	; 0
     538:	09 f0       	breq	.+2      	; 0x53c <prvCheckDelayedList+0x58>
     53a:	64 c0       	rjmp	.+200    	; 0x604 <prvCheckDelayedList+0x120>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     53c:	80 91 b1 00 	lds	r24, 0x00B1
     540:	90 91 b2 00 	lds	r25, 0x00B2
     544:	9a 83       	std	Y+2, r25	; 0x02
     546:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     548:	80 91 b3 00 	lds	r24, 0x00B3
     54c:	90 91 b4 00 	lds	r25, 0x00B4
     550:	90 93 b2 00 	sts	0x00B2, r25
     554:	80 93 b1 00 	sts	0x00B1, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     558:	89 81       	ldd	r24, Y+1	; 0x01
     55a:	9a 81       	ldd	r25, Y+2	; 0x02
     55c:	90 93 b4 00 	sts	0x00B4, r25
     560:	80 93 b3 00 	sts	0x00B3, r24
     564:	4f c0       	rjmp	.+158    	; 0x604 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     566:	e0 91 b1 00 	lds	r30, 0x00B1
     56a:	f0 91 b2 00 	lds	r31, 0x00B2
     56e:	05 80       	ldd	r0, Z+5	; 0x05
     570:	f6 81       	ldd	r31, Z+6	; 0x06
     572:	e0 2d       	mov	r30, r0
     574:	86 81       	ldd	r24, Z+6	; 0x06
     576:	97 81       	ldd	r25, Z+7	; 0x07
     578:	9c 83       	std	Y+4, r25	; 0x04
     57a:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     57c:	eb 81       	ldd	r30, Y+3	; 0x03
     57e:	fc 81       	ldd	r31, Y+4	; 0x04
     580:	22 81       	ldd	r18, Z+2	; 0x02
     582:	33 81       	ldd	r19, Z+3	; 0x03
     584:	80 91 87 00 	lds	r24, 0x0087
     588:	90 91 88 00 	lds	r25, 0x0088
     58c:	82 17       	cp	r24, r18
     58e:	93 07       	cpc	r25, r19
     590:	08 f4       	brcc	.+2      	; 0x594 <prvCheckDelayedList+0xb0>
     592:	40 c0       	rjmp	.+128    	; 0x614 <prvCheckDelayedList+0x130>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     594:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	02 96       	adiw	r24, 0x02	; 2
     59c:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     5a0:	eb 81       	ldd	r30, Y+3	; 0x03
     5a2:	fc 81       	ldd	r31, Y+4	; 0x04
     5a4:	84 89       	ldd	r24, Z+20	; 0x14
     5a6:	95 89       	ldd	r25, Z+21	; 0x15
     5a8:	00 97       	sbiw	r24, 0x00	; 0
     5aa:	29 f0       	breq	.+10     	; 0x5b6 <prvCheckDelayedList+0xd2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     5ac:	8b 81       	ldd	r24, Y+3	; 0x03
     5ae:	9c 81       	ldd	r25, Y+4	; 0x04
     5b0:	0c 96       	adiw	r24, 0x0c	; 12
     5b2:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     5b6:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     5b8:	eb 81       	ldd	r30, Y+3	; 0x03
     5ba:	fc 81       	ldd	r31, Y+4	; 0x04
     5bc:	96 89       	ldd	r25, Z+22	; 0x16
     5be:	80 91 86 00 	lds	r24, 0x0086
     5c2:	89 17       	cp	r24, r25
     5c4:	28 f4       	brcc	.+10     	; 0x5d0 <prvCheckDelayedList+0xec>
     5c6:	eb 81       	ldd	r30, Y+3	; 0x03
     5c8:	fc 81       	ldd	r31, Y+4	; 0x04
     5ca:	86 89       	ldd	r24, Z+22	; 0x16
     5cc:	80 93 86 00 	sts	0x0086, r24
     5d0:	eb 81       	ldd	r30, Y+3	; 0x03
     5d2:	fc 81       	ldd	r31, Y+4	; 0x04
     5d4:	86 89       	ldd	r24, Z+22	; 0x16
     5d6:	28 2f       	mov	r18, r24
     5d8:	30 e0       	ldi	r19, 0x00	; 0
     5da:	c9 01       	movw	r24, r18
     5dc:	88 0f       	add	r24, r24
     5de:	99 1f       	adc	r25, r25
     5e0:	88 0f       	add	r24, r24
     5e2:	99 1f       	adc	r25, r25
     5e4:	88 0f       	add	r24, r24
     5e6:	99 1f       	adc	r25, r25
     5e8:	82 0f       	add	r24, r18
     5ea:	93 1f       	adc	r25, r19
     5ec:	ac 01       	movw	r20, r24
     5ee:	43 57       	subi	r20, 0x73	; 115
     5f0:	5f 4f       	sbci	r21, 0xFF	; 255
     5f2:	8b 81       	ldd	r24, Y+3	; 0x03
     5f4:	9c 81       	ldd	r25, Y+4	; 0x04
     5f6:	9c 01       	movw	r18, r24
     5f8:	2e 5f       	subi	r18, 0xFE	; 254
     5fa:	3f 4f       	sbci	r19, 0xFF	; 255
     5fc:	ca 01       	movw	r24, r20
     5fe:	b9 01       	movw	r22, r18
     600:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     604:	e0 91 b1 00 	lds	r30, 0x00B1
     608:	f0 91 b2 00 	lds	r31, 0x00B2
     60c:	80 81       	ld	r24, Z
     60e:	88 23       	and	r24, r24
     610:	09 f0       	breq	.+2      	; 0x614 <prvCheckDelayedList+0x130>
     612:	a9 cf       	rjmp	.-174    	; 0x566 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     614:	80 91 8b 00 	lds	r24, 0x008B
     618:	90 91 8c 00 	lds	r25, 0x008C
     61c:	00 97       	sbiw	r24, 0x00	; 0
     61e:	09 f0       	breq	.+2      	; 0x622 <prvCheckDelayedList+0x13e>
     620:	74 cf       	rjmp	.-280    	; 0x50a <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     622:	80 91 87 00 	lds	r24, 0x0087
     626:	90 91 88 00 	lds	r25, 0x0088
     62a:	90 93 8a 00 	sts	0x008A, r25
     62e:	80 93 89 00 	sts	0x0089, r24
}
     632:	0f 90       	pop	r0
     634:	0f 90       	pop	r0
     636:	0f 90       	pop	r0
     638:	0f 90       	pop	r0
     63a:	cf 91       	pop	r28
     63c:	df 91       	pop	r29
     63e:	08 95       	ret

00000640 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     640:	df 93       	push	r29
     642:	cf 93       	push	r28
     644:	00 d0       	rcall	.+0      	; 0x646 <vCoRoutineSchedule+0x6>
     646:	cd b7       	in	r28, 0x3d	; 61
     648:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     64a:	0e 94 28 02 	call	0x450	; 0x450 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     64e:	0e 94 72 02 	call	0x4e4	; 0x4e4 <prvCheckDelayedList>
     652:	0a c0       	rjmp	.+20     	; 0x668 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     654:	80 91 86 00 	lds	r24, 0x0086
     658:	88 23       	and	r24, r24
     65a:	09 f4       	brne	.+2      	; 0x65e <vCoRoutineSchedule+0x1e>
     65c:	66 c0       	rjmp	.+204    	; 0x72a <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     65e:	80 91 86 00 	lds	r24, 0x0086
     662:	81 50       	subi	r24, 0x01	; 1
     664:	80 93 86 00 	sts	0x0086, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     668:	80 91 86 00 	lds	r24, 0x0086
     66c:	28 2f       	mov	r18, r24
     66e:	30 e0       	ldi	r19, 0x00	; 0
     670:	c9 01       	movw	r24, r18
     672:	88 0f       	add	r24, r24
     674:	99 1f       	adc	r25, r25
     676:	88 0f       	add	r24, r24
     678:	99 1f       	adc	r25, r25
     67a:	88 0f       	add	r24, r24
     67c:	99 1f       	adc	r25, r25
     67e:	82 0f       	add	r24, r18
     680:	93 1f       	adc	r25, r19
     682:	fc 01       	movw	r30, r24
     684:	e3 57       	subi	r30, 0x73	; 115
     686:	ff 4f       	sbci	r31, 0xFF	; 255
     688:	80 81       	ld	r24, Z
     68a:	88 23       	and	r24, r24
     68c:	19 f3       	breq	.-58     	; 0x654 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     68e:	80 91 86 00 	lds	r24, 0x0086
     692:	28 2f       	mov	r18, r24
     694:	30 e0       	ldi	r19, 0x00	; 0
     696:	c9 01       	movw	r24, r18
     698:	88 0f       	add	r24, r24
     69a:	99 1f       	adc	r25, r25
     69c:	88 0f       	add	r24, r24
     69e:	99 1f       	adc	r25, r25
     6a0:	88 0f       	add	r24, r24
     6a2:	99 1f       	adc	r25, r25
     6a4:	82 0f       	add	r24, r18
     6a6:	93 1f       	adc	r25, r19
     6a8:	83 57       	subi	r24, 0x73	; 115
     6aa:	9f 4f       	sbci	r25, 0xFF	; 255
     6ac:	9a 83       	std	Y+2, r25	; 0x02
     6ae:	89 83       	std	Y+1, r24	; 0x01
     6b0:	e9 81       	ldd	r30, Y+1	; 0x01
     6b2:	fa 81       	ldd	r31, Y+2	; 0x02
     6b4:	01 80       	ldd	r0, Z+1	; 0x01
     6b6:	f2 81       	ldd	r31, Z+2	; 0x02
     6b8:	e0 2d       	mov	r30, r0
     6ba:	82 81       	ldd	r24, Z+2	; 0x02
     6bc:	93 81       	ldd	r25, Z+3	; 0x03
     6be:	e9 81       	ldd	r30, Y+1	; 0x01
     6c0:	fa 81       	ldd	r31, Y+2	; 0x02
     6c2:	92 83       	std	Z+2, r25	; 0x02
     6c4:	81 83       	std	Z+1, r24	; 0x01
     6c6:	e9 81       	ldd	r30, Y+1	; 0x01
     6c8:	fa 81       	ldd	r31, Y+2	; 0x02
     6ca:	21 81       	ldd	r18, Z+1	; 0x01
     6cc:	32 81       	ldd	r19, Z+2	; 0x02
     6ce:	89 81       	ldd	r24, Y+1	; 0x01
     6d0:	9a 81       	ldd	r25, Y+2	; 0x02
     6d2:	03 96       	adiw	r24, 0x03	; 3
     6d4:	28 17       	cp	r18, r24
     6d6:	39 07       	cpc	r19, r25
     6d8:	59 f4       	brne	.+22     	; 0x6f0 <vCoRoutineSchedule+0xb0>
     6da:	e9 81       	ldd	r30, Y+1	; 0x01
     6dc:	fa 81       	ldd	r31, Y+2	; 0x02
     6de:	01 80       	ldd	r0, Z+1	; 0x01
     6e0:	f2 81       	ldd	r31, Z+2	; 0x02
     6e2:	e0 2d       	mov	r30, r0
     6e4:	82 81       	ldd	r24, Z+2	; 0x02
     6e6:	93 81       	ldd	r25, Z+3	; 0x03
     6e8:	e9 81       	ldd	r30, Y+1	; 0x01
     6ea:	fa 81       	ldd	r31, Y+2	; 0x02
     6ec:	92 83       	std	Z+2, r25	; 0x02
     6ee:	81 83       	std	Z+1, r24	; 0x01
     6f0:	e9 81       	ldd	r30, Y+1	; 0x01
     6f2:	fa 81       	ldd	r31, Y+2	; 0x02
     6f4:	01 80       	ldd	r0, Z+1	; 0x01
     6f6:	f2 81       	ldd	r31, Z+2	; 0x02
     6f8:	e0 2d       	mov	r30, r0
     6fa:	86 81       	ldd	r24, Z+6	; 0x06
     6fc:	97 81       	ldd	r25, Z+7	; 0x07
     6fe:	90 93 85 00 	sts	0x0085, r25
     702:	80 93 84 00 	sts	0x0084, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     706:	e0 91 84 00 	lds	r30, 0x0084
     70a:	f0 91 85 00 	lds	r31, 0x0085
     70e:	40 81       	ld	r20, Z
     710:	51 81       	ldd	r21, Z+1	; 0x01
     712:	80 91 84 00 	lds	r24, 0x0084
     716:	90 91 85 00 	lds	r25, 0x0085
     71a:	e0 91 84 00 	lds	r30, 0x0084
     71e:	f0 91 85 00 	lds	r31, 0x0085
     722:	27 89       	ldd	r18, Z+23	; 0x17
     724:	62 2f       	mov	r22, r18
     726:	fa 01       	movw	r30, r20
     728:	09 95       	icall

	return;
}
     72a:	0f 90       	pop	r0
     72c:	0f 90       	pop	r0
     72e:	cf 91       	pop	r28
     730:	df 91       	pop	r29
     732:	08 95       	ret

00000734 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     734:	df 93       	push	r29
     736:	cf 93       	push	r28
     738:	0f 92       	push	r0
     73a:	cd b7       	in	r28, 0x3d	; 61
     73c:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     73e:	19 82       	std	Y+1, r1	; 0x01
     740:	13 c0       	rjmp	.+38     	; 0x768 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     742:	89 81       	ldd	r24, Y+1	; 0x01
     744:	28 2f       	mov	r18, r24
     746:	30 e0       	ldi	r19, 0x00	; 0
     748:	c9 01       	movw	r24, r18
     74a:	88 0f       	add	r24, r24
     74c:	99 1f       	adc	r25, r25
     74e:	88 0f       	add	r24, r24
     750:	99 1f       	adc	r25, r25
     752:	88 0f       	add	r24, r24
     754:	99 1f       	adc	r25, r25
     756:	82 0f       	add	r24, r18
     758:	93 1f       	adc	r25, r19
     75a:	83 57       	subi	r24, 0x73	; 115
     75c:	9f 4f       	sbci	r25, 0xFF	; 255
     75e:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     762:	89 81       	ldd	r24, Y+1	; 0x01
     764:	8f 5f       	subi	r24, 0xFF	; 255
     766:	89 83       	std	Y+1, r24	; 0x01
     768:	89 81       	ldd	r24, Y+1	; 0x01
     76a:	82 30       	cpi	r24, 0x02	; 2
     76c:	50 f3       	brcs	.-44     	; 0x742 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     76e:	8f e9       	ldi	r24, 0x9F	; 159
     770:	90 e0       	ldi	r25, 0x00	; 0
     772:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     776:	88 ea       	ldi	r24, 0xA8	; 168
     778:	90 e0       	ldi	r25, 0x00	; 0
     77a:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     77e:	85 eb       	ldi	r24, 0xB5	; 181
     780:	90 e0       	ldi	r25, 0x00	; 0
     782:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     786:	8f e9       	ldi	r24, 0x9F	; 159
     788:	90 e0       	ldi	r25, 0x00	; 0
     78a:	90 93 b2 00 	sts	0x00B2, r25
     78e:	80 93 b1 00 	sts	0x00B1, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     792:	88 ea       	ldi	r24, 0xA8	; 168
     794:	90 e0       	ldi	r25, 0x00	; 0
     796:	90 93 b4 00 	sts	0x00B4, r25
     79a:	80 93 b3 00 	sts	0x00B3, r24
}
     79e:	0f 90       	pop	r0
     7a0:	cf 91       	pop	r28
     7a2:	df 91       	pop	r29
     7a4:	08 95       	ret

000007a6 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     7a6:	df 93       	push	r29
     7a8:	cf 93       	push	r28
     7aa:	00 d0       	rcall	.+0      	; 0x7ac <xCoRoutineRemoveFromEventList+0x6>
     7ac:	00 d0       	rcall	.+0      	; 0x7ae <xCoRoutineRemoveFromEventList+0x8>
     7ae:	0f 92       	push	r0
     7b0:	cd b7       	in	r28, 0x3d	; 61
     7b2:	de b7       	in	r29, 0x3e	; 62
     7b4:	9d 83       	std	Y+5, r25	; 0x05
     7b6:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     7b8:	ec 81       	ldd	r30, Y+4	; 0x04
     7ba:	fd 81       	ldd	r31, Y+5	; 0x05
     7bc:	05 80       	ldd	r0, Z+5	; 0x05
     7be:	f6 81       	ldd	r31, Z+6	; 0x06
     7c0:	e0 2d       	mov	r30, r0
     7c2:	86 81       	ldd	r24, Z+6	; 0x06
     7c4:	97 81       	ldd	r25, Z+7	; 0x07
     7c6:	9b 83       	std	Y+3, r25	; 0x03
     7c8:	8a 83       	std	Y+2, r24	; 0x02
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     7ca:	8a 81       	ldd	r24, Y+2	; 0x02
     7cc:	9b 81       	ldd	r25, Y+3	; 0x03
     7ce:	0c 96       	adiw	r24, 0x0c	; 12
     7d0:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     7d4:	8a 81       	ldd	r24, Y+2	; 0x02
     7d6:	9b 81       	ldd	r25, Y+3	; 0x03
     7d8:	9c 01       	movw	r18, r24
     7da:	24 5f       	subi	r18, 0xF4	; 244
     7dc:	3f 4f       	sbci	r19, 0xFF	; 255
     7de:	85 eb       	ldi	r24, 0xB5	; 181
     7e0:	90 e0       	ldi	r25, 0x00	; 0
     7e2:	b9 01       	movw	r22, r18
     7e4:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     7e8:	ea 81       	ldd	r30, Y+2	; 0x02
     7ea:	fb 81       	ldd	r31, Y+3	; 0x03
     7ec:	96 89       	ldd	r25, Z+22	; 0x16
     7ee:	e0 91 84 00 	lds	r30, 0x0084
     7f2:	f0 91 85 00 	lds	r31, 0x0085
     7f6:	86 89       	ldd	r24, Z+22	; 0x16
     7f8:	98 17       	cp	r25, r24
     7fa:	18 f0       	brcs	.+6      	; 0x802 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     7fc:	81 e0       	ldi	r24, 0x01	; 1
     7fe:	89 83       	std	Y+1, r24	; 0x01
     800:	01 c0       	rjmp	.+2      	; 0x804 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     802:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     804:	89 81       	ldd	r24, Y+1	; 0x01
}
     806:	0f 90       	pop	r0
     808:	0f 90       	pop	r0
     80a:	0f 90       	pop	r0
     80c:	0f 90       	pop	r0
     80e:	0f 90       	pop	r0
     810:	cf 91       	pop	r28
     812:	df 91       	pop	r29
     814:	08 95       	ret

00000816 <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
     816:	df 93       	push	r29
     818:	cf 93       	push	r28
     81a:	00 d0       	rcall	.+0      	; 0x81c <xEventGroupCreate+0x6>
     81c:	cd b7       	in	r28, 0x3d	; 61
     81e:	de b7       	in	r29, 0x3e	; 62
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
     820:	8b e0       	ldi	r24, 0x0B	; 11
     822:	90 e0       	ldi	r25, 0x00	; 0
     824:	0e 94 4b 07 	call	0xe96	; 0xe96 <pvPortMalloc>
     828:	9a 83       	std	Y+2, r25	; 0x02
     82a:	89 83       	std	Y+1, r24	; 0x01
	if( pxEventBits != NULL )
     82c:	89 81       	ldd	r24, Y+1	; 0x01
     82e:	9a 81       	ldd	r25, Y+2	; 0x02
     830:	00 97       	sbiw	r24, 0x00	; 0
     832:	49 f0       	breq	.+18     	; 0x846 <xEventGroupCreate+0x30>
	{
		pxEventBits->uxEventBits = 0;
     834:	e9 81       	ldd	r30, Y+1	; 0x01
     836:	fa 81       	ldd	r31, Y+2	; 0x02
     838:	11 82       	std	Z+1, r1	; 0x01
     83a:	10 82       	st	Z, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     83c:	89 81       	ldd	r24, Y+1	; 0x01
     83e:	9a 81       	ldd	r25, Y+2	; 0x02
     840:	02 96       	adiw	r24, 0x02	; 2
     842:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
     846:	89 81       	ldd	r24, Y+1	; 0x01
     848:	9a 81       	ldd	r25, Y+2	; 0x02
}
     84a:	0f 90       	pop	r0
     84c:	0f 90       	pop	r0
     84e:	cf 91       	pop	r28
     850:	df 91       	pop	r29
     852:	08 95       	ret

00000854 <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     854:	df 93       	push	r29
     856:	cf 93       	push	r28
     858:	cd b7       	in	r28, 0x3d	; 61
     85a:	de b7       	in	r29, 0x3e	; 62
     85c:	60 97       	sbiw	r28, 0x10	; 16
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	de bf       	out	0x3e, r29	; 62
     864:	0f be       	out	0x3f, r0	; 63
     866:	cd bf       	out	0x3d, r28	; 61
     868:	9a 87       	std	Y+10, r25	; 0x0a
     86a:	89 87       	std	Y+9, r24	; 0x09
     86c:	7c 87       	std	Y+12, r23	; 0x0c
     86e:	6b 87       	std	Y+11, r22	; 0x0b
     870:	5e 87       	std	Y+14, r21	; 0x0e
     872:	4d 87       	std	Y+13, r20	; 0x0d
     874:	38 8b       	std	Y+16, r19	; 0x10
     876:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
     878:	89 85       	ldd	r24, Y+9	; 0x09
     87a:	9a 85       	ldd	r25, Y+10	; 0x0a
     87c:	9c 83       	std	Y+4, r25	; 0x04
     87e:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     880:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     882:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     886:	eb 81       	ldd	r30, Y+3	; 0x03
     888:	fc 81       	ldd	r31, Y+4	; 0x04
     88a:	80 81       	ld	r24, Z
     88c:	91 81       	ldd	r25, Z+1	; 0x01
     88e:	98 87       	std	Y+8, r25	; 0x08
     890:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     892:	89 85       	ldd	r24, Y+9	; 0x09
     894:	9a 85       	ldd	r25, Y+10	; 0x0a
     896:	2b 85       	ldd	r18, Y+11	; 0x0b
     898:	3c 85       	ldd	r19, Y+12	; 0x0c
     89a:	b9 01       	movw	r22, r18
     89c:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     8a0:	2f 81       	ldd	r18, Y+7	; 0x07
     8a2:	38 85       	ldd	r19, Y+8	; 0x08
     8a4:	8b 85       	ldd	r24, Y+11	; 0x0b
     8a6:	9c 85       	ldd	r25, Y+12	; 0x0c
     8a8:	28 2b       	or	r18, r24
     8aa:	39 2b       	or	r19, r25
     8ac:	8d 85       	ldd	r24, Y+13	; 0x0d
     8ae:	9e 85       	ldd	r25, Y+14	; 0x0e
     8b0:	28 23       	and	r18, r24
     8b2:	39 23       	and	r19, r25
     8b4:	8d 85       	ldd	r24, Y+13	; 0x0d
     8b6:	9e 85       	ldd	r25, Y+14	; 0x0e
     8b8:	28 17       	cp	r18, r24
     8ba:	39 07       	cpc	r19, r25
     8bc:	c9 f4       	brne	.+50     	; 0x8f0 <__stack+0x91>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     8be:	2f 81       	ldd	r18, Y+7	; 0x07
     8c0:	38 85       	ldd	r19, Y+8	; 0x08
     8c2:	8b 85       	ldd	r24, Y+11	; 0x0b
     8c4:	9c 85       	ldd	r25, Y+12	; 0x0c
     8c6:	82 2b       	or	r24, r18
     8c8:	93 2b       	or	r25, r19
     8ca:	9e 83       	std	Y+6, r25	; 0x06
     8cc:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     8ce:	eb 81       	ldd	r30, Y+3	; 0x03
     8d0:	fc 81       	ldd	r31, Y+4	; 0x04
     8d2:	20 81       	ld	r18, Z
     8d4:	31 81       	ldd	r19, Z+1	; 0x01
     8d6:	8d 85       	ldd	r24, Y+13	; 0x0d
     8d8:	9e 85       	ldd	r25, Y+14	; 0x0e
     8da:	80 95       	com	r24
     8dc:	90 95       	com	r25
     8de:	82 23       	and	r24, r18
     8e0:	93 23       	and	r25, r19
     8e2:	eb 81       	ldd	r30, Y+3	; 0x03
     8e4:	fc 81       	ldd	r31, Y+4	; 0x04
     8e6:	91 83       	std	Z+1, r25	; 0x01
     8e8:	80 83       	st	Z, r24

			xTicksToWait = 0;
     8ea:	18 8a       	std	Y+16, r1	; 0x10
     8ec:	1f 86       	std	Y+15, r1	; 0x0f
     8ee:	1c c0       	rjmp	.+56     	; 0x928 <__stack+0xc9>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     8f0:	8f 85       	ldd	r24, Y+15	; 0x0f
     8f2:	98 89       	ldd	r25, Y+16	; 0x10
     8f4:	00 97       	sbiw	r24, 0x00	; 0
     8f6:	91 f0       	breq	.+36     	; 0x91c <__stack+0xbd>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     8f8:	8b 81       	ldd	r24, Y+3	; 0x03
     8fa:	9c 81       	ldd	r25, Y+4	; 0x04
     8fc:	bc 01       	movw	r22, r24
     8fe:	6e 5f       	subi	r22, 0xFE	; 254
     900:	7f 4f       	sbci	r23, 0xFF	; 255
     902:	8d 85       	ldd	r24, Y+13	; 0x0d
     904:	9e 85       	ldd	r25, Y+14	; 0x0e
     906:	9c 01       	movw	r18, r24
     908:	35 60       	ori	r19, 0x05	; 5
     90a:	4f 85       	ldd	r20, Y+15	; 0x0f
     90c:	58 89       	ldd	r21, Y+16	; 0x10
     90e:	cb 01       	movw	r24, r22
     910:	b9 01       	movw	r22, r18
     912:	0e 94 cd 19 	call	0x339a	; 0x339a <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     916:	1e 82       	std	Y+6, r1	; 0x06
     918:	1d 82       	std	Y+5, r1	; 0x05
     91a:	06 c0       	rjmp	.+12     	; 0x928 <__stack+0xc9>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     91c:	eb 81       	ldd	r30, Y+3	; 0x03
     91e:	fc 81       	ldd	r31, Y+4	; 0x04
     920:	80 81       	ld	r24, Z
     922:	91 81       	ldd	r25, Z+1	; 0x01
     924:	9e 83       	std	Y+6, r25	; 0x06
     926:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     928:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>
     92c:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     92e:	8f 85       	ldd	r24, Y+15	; 0x0f
     930:	98 89       	ldd	r25, Y+16	; 0x10
     932:	00 97       	sbiw	r24, 0x00	; 0
     934:	09 f4       	brne	.+2      	; 0x938 <__stack+0xd9>
     936:	3a c0       	rjmp	.+116    	; 0x9ac <__stack+0x14d>
	{
		if( xAlreadyYielded == pdFALSE )
     938:	8a 81       	ldd	r24, Y+2	; 0x02
     93a:	88 23       	and	r24, r24
     93c:	11 f4       	brne	.+4      	; 0x942 <__stack+0xe3>
		{
			portYIELD_WITHIN_API();
     93e:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     942:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <uxTaskResetEventItemValue>
     946:	9e 83       	std	Y+6, r25	; 0x06
     948:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     94a:	8d 81       	ldd	r24, Y+5	; 0x05
     94c:	9e 81       	ldd	r25, Y+6	; 0x06
     94e:	80 70       	andi	r24, 0x00	; 0
     950:	92 70       	andi	r25, 0x02	; 2
     952:	00 97       	sbiw	r24, 0x00	; 0
     954:	31 f5       	brne	.+76     	; 0x9a2 <__stack+0x143>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     956:	0f b6       	in	r0, 0x3f	; 63
     958:	f8 94       	cli
     95a:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     95c:	eb 81       	ldd	r30, Y+3	; 0x03
     95e:	fc 81       	ldd	r31, Y+4	; 0x04
     960:	80 81       	ld	r24, Z
     962:	91 81       	ldd	r25, Z+1	; 0x01
     964:	9e 83       	std	Y+6, r25	; 0x06
     966:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     968:	2d 81       	ldd	r18, Y+5	; 0x05
     96a:	3e 81       	ldd	r19, Y+6	; 0x06
     96c:	8d 85       	ldd	r24, Y+13	; 0x0d
     96e:	9e 85       	ldd	r25, Y+14	; 0x0e
     970:	28 23       	and	r18, r24
     972:	39 23       	and	r19, r25
     974:	8d 85       	ldd	r24, Y+13	; 0x0d
     976:	9e 85       	ldd	r25, Y+14	; 0x0e
     978:	28 17       	cp	r18, r24
     97a:	39 07       	cpc	r19, r25
     97c:	71 f4       	brne	.+28     	; 0x99a <__stack+0x13b>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     97e:	eb 81       	ldd	r30, Y+3	; 0x03
     980:	fc 81       	ldd	r31, Y+4	; 0x04
     982:	20 81       	ld	r18, Z
     984:	31 81       	ldd	r19, Z+1	; 0x01
     986:	8d 85       	ldd	r24, Y+13	; 0x0d
     988:	9e 85       	ldd	r25, Y+14	; 0x0e
     98a:	80 95       	com	r24
     98c:	90 95       	com	r25
     98e:	82 23       	and	r24, r18
     990:	93 23       	and	r25, r19
     992:	eb 81       	ldd	r30, Y+3	; 0x03
     994:	fc 81       	ldd	r31, Y+4	; 0x04
     996:	91 83       	std	Z+1, r25	; 0x01
     998:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     99a:	0f 90       	pop	r0
     99c:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     99e:	81 e0       	ldi	r24, 0x01	; 1
     9a0:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     9a2:	8d 81       	ldd	r24, Y+5	; 0x05
     9a4:	9e 81       	ldd	r25, Y+6	; 0x06
     9a6:	90 70       	andi	r25, 0x00	; 0
     9a8:	9e 83       	std	Y+6, r25	; 0x06
     9aa:	8d 83       	std	Y+5, r24	; 0x05
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
     9ac:	8d 81       	ldd	r24, Y+5	; 0x05
     9ae:	9e 81       	ldd	r25, Y+6	; 0x06
}
     9b0:	60 96       	adiw	r28, 0x10	; 16
     9b2:	0f b6       	in	r0, 0x3f	; 63
     9b4:	f8 94       	cli
     9b6:	de bf       	out	0x3e, r29	; 62
     9b8:	0f be       	out	0x3f, r0	; 63
     9ba:	cd bf       	out	0x3d, r28	; 61
     9bc:	cf 91       	pop	r28
     9be:	df 91       	pop	r29
     9c0:	08 95       	ret

000009c2 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     9c2:	0f 93       	push	r16
     9c4:	1f 93       	push	r17
     9c6:	df 93       	push	r29
     9c8:	cf 93       	push	r28
     9ca:	cd b7       	in	r28, 0x3d	; 61
     9cc:	de b7       	in	r29, 0x3e	; 62
     9ce:	63 97       	sbiw	r28, 0x13	; 19
     9d0:	0f b6       	in	r0, 0x3f	; 63
     9d2:	f8 94       	cli
     9d4:	de bf       	out	0x3e, r29	; 62
     9d6:	0f be       	out	0x3f, r0	; 63
     9d8:	cd bf       	out	0x3d, r28	; 61
     9da:	9d 87       	std	Y+13, r25	; 0x0d
     9dc:	8c 87       	std	Y+12, r24	; 0x0c
     9de:	7f 87       	std	Y+15, r23	; 0x0f
     9e0:	6e 87       	std	Y+14, r22	; 0x0e
     9e2:	48 8b       	std	Y+16, r20	; 0x10
     9e4:	29 8b       	std	Y+17, r18	; 0x11
     9e6:	1b 8b       	std	Y+19, r17	; 0x13
     9e8:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
     9ea:	8c 85       	ldd	r24, Y+12	; 0x0c
     9ec:	9d 85       	ldd	r25, Y+13	; 0x0d
     9ee:	9b 87       	std	Y+11, r25	; 0x0b
     9f0:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     9f2:	1f 82       	std	Y+7, r1	; 0x07
     9f4:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     9f6:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     9f8:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     9fc:	ea 85       	ldd	r30, Y+10	; 0x0a
     9fe:	fb 85       	ldd	r31, Y+11	; 0x0b
     a00:	80 81       	ld	r24, Z
     a02:	91 81       	ldd	r25, Z+1	; 0x01
     a04:	9a 83       	std	Y+2, r25	; 0x02
     a06:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     a08:	89 81       	ldd	r24, Y+1	; 0x01
     a0a:	9a 81       	ldd	r25, Y+2	; 0x02
     a0c:	2e 85       	ldd	r18, Y+14	; 0x0e
     a0e:	3f 85       	ldd	r19, Y+15	; 0x0f
     a10:	b9 01       	movw	r22, r18
     a12:	49 89       	ldd	r20, Y+17	; 0x11
     a14:	0e 94 19 07 	call	0xe32	; 0xe32 <prvTestWaitCondition>
     a18:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     a1a:	8d 81       	ldd	r24, Y+5	; 0x05
     a1c:	88 23       	and	r24, r24
     a1e:	c1 f0       	breq	.+48     	; 0xa50 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     a20:	89 81       	ldd	r24, Y+1	; 0x01
     a22:	9a 81       	ldd	r25, Y+2	; 0x02
     a24:	99 87       	std	Y+9, r25	; 0x09
     a26:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     a28:	1b 8a       	std	Y+19, r1	; 0x13
     a2a:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     a2c:	88 89       	ldd	r24, Y+16	; 0x10
     a2e:	88 23       	and	r24, r24
     a30:	d9 f1       	breq	.+118    	; 0xaa8 <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     a32:	ea 85       	ldd	r30, Y+10	; 0x0a
     a34:	fb 85       	ldd	r31, Y+11	; 0x0b
     a36:	20 81       	ld	r18, Z
     a38:	31 81       	ldd	r19, Z+1	; 0x01
     a3a:	8e 85       	ldd	r24, Y+14	; 0x0e
     a3c:	9f 85       	ldd	r25, Y+15	; 0x0f
     a3e:	80 95       	com	r24
     a40:	90 95       	com	r25
     a42:	82 23       	and	r24, r18
     a44:	93 23       	and	r25, r19
     a46:	ea 85       	ldd	r30, Y+10	; 0x0a
     a48:	fb 85       	ldd	r31, Y+11	; 0x0b
     a4a:	91 83       	std	Z+1, r25	; 0x01
     a4c:	80 83       	st	Z, r24
     a4e:	2c c0       	rjmp	.+88     	; 0xaa8 <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     a50:	8a 89       	ldd	r24, Y+18	; 0x12
     a52:	9b 89       	ldd	r25, Y+19	; 0x13
     a54:	00 97       	sbiw	r24, 0x00	; 0
     a56:	29 f4       	brne	.+10     	; 0xa62 <xEventGroupWaitBits+0xa0>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     a58:	89 81       	ldd	r24, Y+1	; 0x01
     a5a:	9a 81       	ldd	r25, Y+2	; 0x02
     a5c:	99 87       	std	Y+9, r25	; 0x09
     a5e:	88 87       	std	Y+8, r24	; 0x08
     a60:	23 c0       	rjmp	.+70     	; 0xaa8 <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     a62:	88 89       	ldd	r24, Y+16	; 0x10
     a64:	88 23       	and	r24, r24
     a66:	29 f0       	breq	.+10     	; 0xa72 <xEventGroupWaitBits+0xb0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     a68:	8e 81       	ldd	r24, Y+6	; 0x06
     a6a:	9f 81       	ldd	r25, Y+7	; 0x07
     a6c:	91 60       	ori	r25, 0x01	; 1
     a6e:	9f 83       	std	Y+7, r25	; 0x07
     a70:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     a72:	89 89       	ldd	r24, Y+17	; 0x11
     a74:	88 23       	and	r24, r24
     a76:	29 f0       	breq	.+10     	; 0xa82 <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     a78:	8e 81       	ldd	r24, Y+6	; 0x06
     a7a:	9f 81       	ldd	r25, Y+7	; 0x07
     a7c:	94 60       	ori	r25, 0x04	; 4
     a7e:	9f 83       	std	Y+7, r25	; 0x07
     a80:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     a82:	8a 85       	ldd	r24, Y+10	; 0x0a
     a84:	9b 85       	ldd	r25, Y+11	; 0x0b
     a86:	bc 01       	movw	r22, r24
     a88:	6e 5f       	subi	r22, 0xFE	; 254
     a8a:	7f 4f       	sbci	r23, 0xFF	; 255
     a8c:	2e 85       	ldd	r18, Y+14	; 0x0e
     a8e:	3f 85       	ldd	r19, Y+15	; 0x0f
     a90:	8e 81       	ldd	r24, Y+6	; 0x06
     a92:	9f 81       	ldd	r25, Y+7	; 0x07
     a94:	28 2b       	or	r18, r24
     a96:	39 2b       	or	r19, r25
     a98:	4a 89       	ldd	r20, Y+18	; 0x12
     a9a:	5b 89       	ldd	r21, Y+19	; 0x13
     a9c:	cb 01       	movw	r24, r22
     a9e:	b9 01       	movw	r22, r18
     aa0:	0e 94 cd 19 	call	0x339a	; 0x339a <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     aa4:	19 86       	std	Y+9, r1	; 0x09
     aa6:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     aa8:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>
     aac:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     aae:	8a 89       	ldd	r24, Y+18	; 0x12
     ab0:	9b 89       	ldd	r25, Y+19	; 0x13
     ab2:	00 97       	sbiw	r24, 0x00	; 0
     ab4:	09 f4       	brne	.+2      	; 0xab8 <xEventGroupWaitBits+0xf6>
     ab6:	3b c0       	rjmp	.+118    	; 0xb2e <xEventGroupWaitBits+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
     ab8:	8c 81       	ldd	r24, Y+4	; 0x04
     aba:	88 23       	and	r24, r24
     abc:	11 f4       	brne	.+4      	; 0xac2 <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
     abe:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     ac2:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <uxTaskResetEventItemValue>
     ac6:	99 87       	std	Y+9, r25	; 0x09
     ac8:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     aca:	88 85       	ldd	r24, Y+8	; 0x08
     acc:	99 85       	ldd	r25, Y+9	; 0x09
     ace:	80 70       	andi	r24, 0x00	; 0
     ad0:	92 70       	andi	r25, 0x02	; 2
     ad2:	00 97       	sbiw	r24, 0x00	; 0
     ad4:	39 f5       	brne	.+78     	; 0xb24 <xEventGroupWaitBits+0x162>
		{
			taskENTER_CRITICAL();
     ad6:	0f b6       	in	r0, 0x3f	; 63
     ad8:	f8 94       	cli
     ada:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     adc:	ea 85       	ldd	r30, Y+10	; 0x0a
     ade:	fb 85       	ldd	r31, Y+11	; 0x0b
     ae0:	80 81       	ld	r24, Z
     ae2:	91 81       	ldd	r25, Z+1	; 0x01
     ae4:	99 87       	std	Y+9, r25	; 0x09
     ae6:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     ae8:	88 85       	ldd	r24, Y+8	; 0x08
     aea:	99 85       	ldd	r25, Y+9	; 0x09
     aec:	2e 85       	ldd	r18, Y+14	; 0x0e
     aee:	3f 85       	ldd	r19, Y+15	; 0x0f
     af0:	b9 01       	movw	r22, r18
     af2:	49 89       	ldd	r20, Y+17	; 0x11
     af4:	0e 94 19 07 	call	0xe32	; 0xe32 <prvTestWaitCondition>
     af8:	88 23       	and	r24, r24
     afa:	89 f0       	breq	.+34     	; 0xb1e <xEventGroupWaitBits+0x15c>
				{
					if( xClearOnExit != pdFALSE )
     afc:	88 89       	ldd	r24, Y+16	; 0x10
     afe:	88 23       	and	r24, r24
     b00:	71 f0       	breq	.+28     	; 0xb1e <xEventGroupWaitBits+0x15c>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     b02:	ea 85       	ldd	r30, Y+10	; 0x0a
     b04:	fb 85       	ldd	r31, Y+11	; 0x0b
     b06:	20 81       	ld	r18, Z
     b08:	31 81       	ldd	r19, Z+1	; 0x01
     b0a:	8e 85       	ldd	r24, Y+14	; 0x0e
     b0c:	9f 85       	ldd	r25, Y+15	; 0x0f
     b0e:	80 95       	com	r24
     b10:	90 95       	com	r25
     b12:	82 23       	and	r24, r18
     b14:	93 23       	and	r25, r19
     b16:	ea 85       	ldd	r30, Y+10	; 0x0a
     b18:	fb 85       	ldd	r31, Y+11	; 0x0b
     b1a:	91 83       	std	Z+1, r25	; 0x01
     b1c:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     b1e:	0f 90       	pop	r0
     b20:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
     b22:	1b 82       	std	Y+3, r1	; 0x03
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     b24:	88 85       	ldd	r24, Y+8	; 0x08
     b26:	99 85       	ldd	r25, Y+9	; 0x09
     b28:	90 70       	andi	r25, 0x00	; 0
     b2a:	99 87       	std	Y+9, r25	; 0x09
     b2c:	88 87       	std	Y+8, r24	; 0x08
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
     b2e:	88 85       	ldd	r24, Y+8	; 0x08
     b30:	99 85       	ldd	r25, Y+9	; 0x09
}
     b32:	63 96       	adiw	r28, 0x13	; 19
     b34:	0f b6       	in	r0, 0x3f	; 63
     b36:	f8 94       	cli
     b38:	de bf       	out	0x3e, r29	; 62
     b3a:	0f be       	out	0x3f, r0	; 63
     b3c:	cd bf       	out	0x3d, r28	; 61
     b3e:	cf 91       	pop	r28
     b40:	df 91       	pop	r29
     b42:	1f 91       	pop	r17
     b44:	0f 91       	pop	r16
     b46:	08 95       	ret

00000b48 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     b48:	df 93       	push	r29
     b4a:	cf 93       	push	r28
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	28 97       	sbiw	r28, 0x08	; 8
     b52:	0f b6       	in	r0, 0x3f	; 63
     b54:	f8 94       	cli
     b56:	de bf       	out	0x3e, r29	; 62
     b58:	0f be       	out	0x3f, r0	; 63
     b5a:	cd bf       	out	0x3d, r28	; 61
     b5c:	9e 83       	std	Y+6, r25	; 0x06
     b5e:	8d 83       	std	Y+5, r24	; 0x05
     b60:	78 87       	std	Y+8, r23	; 0x08
     b62:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
     b64:	8d 81       	ldd	r24, Y+5	; 0x05
     b66:	9e 81       	ldd	r25, Y+6	; 0x06
     b68:	9c 83       	std	Y+4, r25	; 0x04
     b6a:	8b 83       	std	Y+3, r24	; 0x03

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     b6c:	0f b6       	in	r0, 0x3f	; 63
     b6e:	f8 94       	cli
     b70:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     b72:	eb 81       	ldd	r30, Y+3	; 0x03
     b74:	fc 81       	ldd	r31, Y+4	; 0x04
     b76:	80 81       	ld	r24, Z
     b78:	91 81       	ldd	r25, Z+1	; 0x01
     b7a:	9a 83       	std	Y+2, r25	; 0x02
     b7c:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     b7e:	eb 81       	ldd	r30, Y+3	; 0x03
     b80:	fc 81       	ldd	r31, Y+4	; 0x04
     b82:	20 81       	ld	r18, Z
     b84:	31 81       	ldd	r19, Z+1	; 0x01
     b86:	8f 81       	ldd	r24, Y+7	; 0x07
     b88:	98 85       	ldd	r25, Y+8	; 0x08
     b8a:	80 95       	com	r24
     b8c:	90 95       	com	r25
     b8e:	82 23       	and	r24, r18
     b90:	93 23       	and	r25, r19
     b92:	eb 81       	ldd	r30, Y+3	; 0x03
     b94:	fc 81       	ldd	r31, Y+4	; 0x04
     b96:	91 83       	std	Z+1, r25	; 0x01
     b98:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     b9a:	0f 90       	pop	r0
     b9c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     b9e:	89 81       	ldd	r24, Y+1	; 0x01
     ba0:	9a 81       	ldd	r25, Y+2	; 0x02
}
     ba2:	28 96       	adiw	r28, 0x08	; 8
     ba4:	0f b6       	in	r0, 0x3f	; 63
     ba6:	f8 94       	cli
     ba8:	de bf       	out	0x3e, r29	; 62
     baa:	0f be       	out	0x3f, r0	; 63
     bac:	cd bf       	out	0x3d, r28	; 61
     bae:	cf 91       	pop	r28
     bb0:	df 91       	pop	r29
     bb2:	08 95       	ret

00000bb4 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     bb4:	df 93       	push	r29
     bb6:	cf 93       	push	r28
     bb8:	cd b7       	in	r28, 0x3d	; 61
     bba:	de b7       	in	r29, 0x3e	; 62
     bbc:	27 97       	sbiw	r28, 0x07	; 7
     bbe:	0f b6       	in	r0, 0x3f	; 63
     bc0:	f8 94       	cli
     bc2:	de bf       	out	0x3e, r29	; 62
     bc4:	0f be       	out	0x3f, r0	; 63
     bc6:	cd bf       	out	0x3d, r28	; 61
     bc8:	9f 83       	std	Y+7, r25	; 0x07
     bca:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
     bcc:	8e 81       	ldd	r24, Y+6	; 0x06
     bce:	9f 81       	ldd	r25, Y+7	; 0x07
     bd0:	9c 83       	std	Y+4, r25	; 0x04
     bd2:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     bd4:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     bd6:	eb 81       	ldd	r30, Y+3	; 0x03
     bd8:	fc 81       	ldd	r31, Y+4	; 0x04
     bda:	80 81       	ld	r24, Z
     bdc:	91 81       	ldd	r25, Z+1	; 0x01
     bde:	9a 83       	std	Y+2, r25	; 0x02
     be0:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     be2:	89 81       	ldd	r24, Y+1	; 0x01
     be4:	9a 81       	ldd	r25, Y+2	; 0x02
}
     be6:	27 96       	adiw	r28, 0x07	; 7
     be8:	0f b6       	in	r0, 0x3f	; 63
     bea:	f8 94       	cli
     bec:	de bf       	out	0x3e, r29	; 62
     bee:	0f be       	out	0x3f, r0	; 63
     bf0:	cd bf       	out	0x3d, r28	; 61
     bf2:	cf 91       	pop	r28
     bf4:	df 91       	pop	r29
     bf6:	08 95       	ret

00000bf8 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     bf8:	df 93       	push	r29
     bfa:	cf 93       	push	r28
     bfc:	cd b7       	in	r28, 0x3d	; 61
     bfe:	de b7       	in	r29, 0x3e	; 62
     c00:	65 97       	sbiw	r28, 0x15	; 21
     c02:	0f b6       	in	r0, 0x3f	; 63
     c04:	f8 94       	cli
     c06:	de bf       	out	0x3e, r29	; 62
     c08:	0f be       	out	0x3f, r0	; 63
     c0a:	cd bf       	out	0x3d, r28	; 61
     c0c:	9b 8b       	std	Y+19, r25	; 0x13
     c0e:	8a 8b       	std	Y+18, r24	; 0x12
     c10:	7d 8b       	std	Y+21, r23	; 0x15
     c12:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     c14:	19 86       	std	Y+9, r1	; 0x09
     c16:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
     c18:	8a 89       	ldd	r24, Y+18	; 0x12
     c1a:	9b 89       	ldd	r25, Y+19	; 0x13
     c1c:	9b 83       	std	Y+3, r25	; 0x03
     c1e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     c20:	19 82       	std	Y+1, r1	; 0x01

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     c22:	8a 81       	ldd	r24, Y+2	; 0x02
     c24:	9b 81       	ldd	r25, Y+3	; 0x03
     c26:	02 96       	adiw	r24, 0x02	; 2
     c28:	9b 87       	std	Y+11, r25	; 0x0b
     c2a:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c2c:	8a 85       	ldd	r24, Y+10	; 0x0a
     c2e:	9b 85       	ldd	r25, Y+11	; 0x0b
     c30:	03 96       	adiw	r24, 0x03	; 3
     c32:	9d 87       	std	Y+13, r25	; 0x0d
     c34:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     c36:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     c3a:	ea 85       	ldd	r30, Y+10	; 0x0a
     c3c:	fb 85       	ldd	r31, Y+11	; 0x0b
     c3e:	85 81       	ldd	r24, Z+5	; 0x05
     c40:	96 81       	ldd	r25, Z+6	; 0x06
     c42:	99 8b       	std	Y+17, r25	; 0x11
     c44:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     c46:	ea 81       	ldd	r30, Y+2	; 0x02
     c48:	fb 81       	ldd	r31, Y+3	; 0x03
     c4a:	20 81       	ld	r18, Z
     c4c:	31 81       	ldd	r19, Z+1	; 0x01
     c4e:	8c 89       	ldd	r24, Y+20	; 0x14
     c50:	9d 89       	ldd	r25, Y+21	; 0x15
     c52:	82 2b       	or	r24, r18
     c54:	93 2b       	or	r25, r19
     c56:	ea 81       	ldd	r30, Y+2	; 0x02
     c58:	fb 81       	ldd	r31, Y+3	; 0x03
     c5a:	91 83       	std	Z+1, r25	; 0x01
     c5c:	80 83       	st	Z, r24
     c5e:	59 c0       	rjmp	.+178    	; 0xd12 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     c60:	e8 89       	ldd	r30, Y+16	; 0x10
     c62:	f9 89       	ldd	r31, Y+17	; 0x11
     c64:	82 81       	ldd	r24, Z+2	; 0x02
     c66:	93 81       	ldd	r25, Z+3	; 0x03
     c68:	9f 87       	std	Y+15, r25	; 0x0f
     c6a:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     c6c:	e8 89       	ldd	r30, Y+16	; 0x10
     c6e:	f9 89       	ldd	r31, Y+17	; 0x11
     c70:	80 81       	ld	r24, Z
     c72:	91 81       	ldd	r25, Z+1	; 0x01
     c74:	9f 83       	std	Y+7, r25	; 0x07
     c76:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     c78:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     c7a:	8e 81       	ldd	r24, Y+6	; 0x06
     c7c:	9f 81       	ldd	r25, Y+7	; 0x07
     c7e:	80 70       	andi	r24, 0x00	; 0
     c80:	9d 83       	std	Y+5, r25	; 0x05
     c82:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     c84:	8e 81       	ldd	r24, Y+6	; 0x06
     c86:	9f 81       	ldd	r25, Y+7	; 0x07
     c88:	90 70       	andi	r25, 0x00	; 0
     c8a:	9f 83       	std	Y+7, r25	; 0x07
     c8c:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     c8e:	8c 81       	ldd	r24, Y+4	; 0x04
     c90:	9d 81       	ldd	r25, Y+5	; 0x05
     c92:	80 70       	andi	r24, 0x00	; 0
     c94:	94 70       	andi	r25, 0x04	; 4
     c96:	00 97       	sbiw	r24, 0x00	; 0
     c98:	69 f4       	brne	.+26     	; 0xcb4 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     c9a:	ea 81       	ldd	r30, Y+2	; 0x02
     c9c:	fb 81       	ldd	r31, Y+3	; 0x03
     c9e:	20 81       	ld	r18, Z
     ca0:	31 81       	ldd	r19, Z+1	; 0x01
     ca2:	8e 81       	ldd	r24, Y+6	; 0x06
     ca4:	9f 81       	ldd	r25, Y+7	; 0x07
     ca6:	82 23       	and	r24, r18
     ca8:	93 23       	and	r25, r19
     caa:	00 97       	sbiw	r24, 0x00	; 0
     cac:	91 f0       	breq	.+36     	; 0xcd2 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     cae:	81 e0       	ldi	r24, 0x01	; 1
     cb0:	89 83       	std	Y+1, r24	; 0x01
     cb2:	0f c0       	rjmp	.+30     	; 0xcd2 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     cb4:	ea 81       	ldd	r30, Y+2	; 0x02
     cb6:	fb 81       	ldd	r31, Y+3	; 0x03
     cb8:	20 81       	ld	r18, Z
     cba:	31 81       	ldd	r19, Z+1	; 0x01
     cbc:	8e 81       	ldd	r24, Y+6	; 0x06
     cbe:	9f 81       	ldd	r25, Y+7	; 0x07
     cc0:	28 23       	and	r18, r24
     cc2:	39 23       	and	r19, r25
     cc4:	8e 81       	ldd	r24, Y+6	; 0x06
     cc6:	9f 81       	ldd	r25, Y+7	; 0x07
     cc8:	28 17       	cp	r18, r24
     cca:	39 07       	cpc	r19, r25
     ccc:	11 f4       	brne	.+4      	; 0xcd2 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     cce:	81 e0       	ldi	r24, 0x01	; 1
     cd0:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     cd2:	89 81       	ldd	r24, Y+1	; 0x01
     cd4:	88 23       	and	r24, r24
     cd6:	c9 f0       	breq	.+50     	; 0xd0a <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     cd8:	8c 81       	ldd	r24, Y+4	; 0x04
     cda:	9d 81       	ldd	r25, Y+5	; 0x05
     cdc:	80 70       	andi	r24, 0x00	; 0
     cde:	91 70       	andi	r25, 0x01	; 1
     ce0:	00 97       	sbiw	r24, 0x00	; 0
     ce2:	41 f0       	breq	.+16     	; 0xcf4 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     ce4:	88 85       	ldd	r24, Y+8	; 0x08
     ce6:	99 85       	ldd	r25, Y+9	; 0x09
     ce8:	2e 81       	ldd	r18, Y+6	; 0x06
     cea:	3f 81       	ldd	r19, Y+7	; 0x07
     cec:	82 2b       	or	r24, r18
     cee:	93 2b       	or	r25, r19
     cf0:	99 87       	std	Y+9, r25	; 0x09
     cf2:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     cf4:	ea 81       	ldd	r30, Y+2	; 0x02
     cf6:	fb 81       	ldd	r31, Y+3	; 0x03
     cf8:	80 81       	ld	r24, Z
     cfa:	91 81       	ldd	r25, Z+1	; 0x01
     cfc:	9c 01       	movw	r18, r24
     cfe:	32 60       	ori	r19, 0x02	; 2
     d00:	88 89       	ldd	r24, Y+16	; 0x10
     d02:	99 89       	ldd	r25, Y+17	; 0x11
     d04:	b9 01       	movw	r22, r18
     d06:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     d0a:	8e 85       	ldd	r24, Y+14	; 0x0e
     d0c:	9f 85       	ldd	r25, Y+15	; 0x0f
     d0e:	99 8b       	std	Y+17, r25	; 0x11
     d10:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     d12:	28 89       	ldd	r18, Y+16	; 0x10
     d14:	39 89       	ldd	r19, Y+17	; 0x11
     d16:	8c 85       	ldd	r24, Y+12	; 0x0c
     d18:	9d 85       	ldd	r25, Y+13	; 0x0d
     d1a:	28 17       	cp	r18, r24
     d1c:	39 07       	cpc	r19, r25
     d1e:	09 f0       	breq	.+2      	; 0xd22 <xEventGroupSetBits+0x12a>
     d20:	9f cf       	rjmp	.-194    	; 0xc60 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     d22:	ea 81       	ldd	r30, Y+2	; 0x02
     d24:	fb 81       	ldd	r31, Y+3	; 0x03
     d26:	20 81       	ld	r18, Z
     d28:	31 81       	ldd	r19, Z+1	; 0x01
     d2a:	88 85       	ldd	r24, Y+8	; 0x08
     d2c:	99 85       	ldd	r25, Y+9	; 0x09
     d2e:	80 95       	com	r24
     d30:	90 95       	com	r25
     d32:	82 23       	and	r24, r18
     d34:	93 23       	and	r25, r19
     d36:	ea 81       	ldd	r30, Y+2	; 0x02
     d38:	fb 81       	ldd	r31, Y+3	; 0x03
     d3a:	91 83       	std	Z+1, r25	; 0x01
     d3c:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     d3e:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     d42:	ea 81       	ldd	r30, Y+2	; 0x02
     d44:	fb 81       	ldd	r31, Y+3	; 0x03
     d46:	80 81       	ld	r24, Z
     d48:	91 81       	ldd	r25, Z+1	; 0x01
}
     d4a:	65 96       	adiw	r28, 0x15	; 21
     d4c:	0f b6       	in	r0, 0x3f	; 63
     d4e:	f8 94       	cli
     d50:	de bf       	out	0x3e, r29	; 62
     d52:	0f be       	out	0x3f, r0	; 63
     d54:	cd bf       	out	0x3d, r28	; 61
     d56:	cf 91       	pop	r28
     d58:	df 91       	pop	r29
     d5a:	08 95       	ret

00000d5c <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     d5c:	df 93       	push	r29
     d5e:	cf 93       	push	r28
     d60:	00 d0       	rcall	.+0      	; 0xd62 <vEventGroupDelete+0x6>
     d62:	00 d0       	rcall	.+0      	; 0xd64 <vEventGroupDelete+0x8>
     d64:	00 d0       	rcall	.+0      	; 0xd66 <vEventGroupDelete+0xa>
     d66:	cd b7       	in	r28, 0x3d	; 61
     d68:	de b7       	in	r29, 0x3e	; 62
     d6a:	9e 83       	std	Y+6, r25	; 0x06
     d6c:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
     d6e:	8d 81       	ldd	r24, Y+5	; 0x05
     d70:	9e 81       	ldd	r25, Y+6	; 0x06
     d72:	9c 83       	std	Y+4, r25	; 0x04
     d74:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     d76:	8b 81       	ldd	r24, Y+3	; 0x03
     d78:	9c 81       	ldd	r25, Y+4	; 0x04
     d7a:	02 96       	adiw	r24, 0x02	; 2
     d7c:	9a 83       	std	Y+2, r25	; 0x02
     d7e:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     d80:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vTaskSuspendAll>
     d84:	08 c0       	rjmp	.+16     	; 0xd96 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     d86:	e9 81       	ldd	r30, Y+1	; 0x01
     d88:	fa 81       	ldd	r31, Y+2	; 0x02
     d8a:	85 81       	ldd	r24, Z+5	; 0x05
     d8c:	96 81       	ldd	r25, Z+6	; 0x06
     d8e:	60 e0       	ldi	r22, 0x00	; 0
     d90:	72 e0       	ldi	r23, 0x02	; 2
     d92:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     d96:	e9 81       	ldd	r30, Y+1	; 0x01
     d98:	fa 81       	ldd	r31, Y+2	; 0x02
     d9a:	80 81       	ld	r24, Z
     d9c:	88 23       	and	r24, r24
     d9e:	99 f7       	brne	.-26     	; 0xd86 <vEventGroupDelete+0x2a>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
     da0:	8b 81       	ldd	r24, Y+3	; 0x03
     da2:	9c 81       	ldd	r25, Y+4	; 0x04
     da4:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
	}
	( void ) xTaskResumeAll();
     da8:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>
}
     dac:	26 96       	adiw	r28, 0x06	; 6
     dae:	0f b6       	in	r0, 0x3f	; 63
     db0:	f8 94       	cli
     db2:	de bf       	out	0x3e, r29	; 62
     db4:	0f be       	out	0x3f, r0	; 63
     db6:	cd bf       	out	0x3d, r28	; 61
     db8:	cf 91       	pop	r28
     dba:	df 91       	pop	r29
     dbc:	08 95       	ret

00000dbe <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     dbe:	df 93       	push	r29
     dc0:	cf 93       	push	r28
     dc2:	00 d0       	rcall	.+0      	; 0xdc4 <vEventGroupSetBitsCallback+0x6>
     dc4:	00 d0       	rcall	.+0      	; 0xdc6 <vEventGroupSetBitsCallback+0x8>
     dc6:	00 d0       	rcall	.+0      	; 0xdc8 <vEventGroupSetBitsCallback+0xa>
     dc8:	cd b7       	in	r28, 0x3d	; 61
     dca:	de b7       	in	r29, 0x3e	; 62
     dcc:	9a 83       	std	Y+2, r25	; 0x02
     dce:	89 83       	std	Y+1, r24	; 0x01
     dd0:	4b 83       	std	Y+3, r20	; 0x03
     dd2:	5c 83       	std	Y+4, r21	; 0x04
     dd4:	6d 83       	std	Y+5, r22	; 0x05
     dd6:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     dd8:	2b 81       	ldd	r18, Y+3	; 0x03
     dda:	3c 81       	ldd	r19, Y+4	; 0x04
     ddc:	89 81       	ldd	r24, Y+1	; 0x01
     dde:	9a 81       	ldd	r25, Y+2	; 0x02
     de0:	b9 01       	movw	r22, r18
     de2:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <xEventGroupSetBits>
}
     de6:	26 96       	adiw	r28, 0x06	; 6
     de8:	0f b6       	in	r0, 0x3f	; 63
     dea:	f8 94       	cli
     dec:	de bf       	out	0x3e, r29	; 62
     dee:	0f be       	out	0x3f, r0	; 63
     df0:	cd bf       	out	0x3d, r28	; 61
     df2:	cf 91       	pop	r28
     df4:	df 91       	pop	r29
     df6:	08 95       	ret

00000df8 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     df8:	df 93       	push	r29
     dfa:	cf 93       	push	r28
     dfc:	00 d0       	rcall	.+0      	; 0xdfe <vEventGroupClearBitsCallback+0x6>
     dfe:	00 d0       	rcall	.+0      	; 0xe00 <vEventGroupClearBitsCallback+0x8>
     e00:	00 d0       	rcall	.+0      	; 0xe02 <vEventGroupClearBitsCallback+0xa>
     e02:	cd b7       	in	r28, 0x3d	; 61
     e04:	de b7       	in	r29, 0x3e	; 62
     e06:	9a 83       	std	Y+2, r25	; 0x02
     e08:	89 83       	std	Y+1, r24	; 0x01
     e0a:	4b 83       	std	Y+3, r20	; 0x03
     e0c:	5c 83       	std	Y+4, r21	; 0x04
     e0e:	6d 83       	std	Y+5, r22	; 0x05
     e10:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     e12:	2b 81       	ldd	r18, Y+3	; 0x03
     e14:	3c 81       	ldd	r19, Y+4	; 0x04
     e16:	89 81       	ldd	r24, Y+1	; 0x01
     e18:	9a 81       	ldd	r25, Y+2	; 0x02
     e1a:	b9 01       	movw	r22, r18
     e1c:	0e 94 a4 05 	call	0xb48	; 0xb48 <xEventGroupClearBits>
}
     e20:	26 96       	adiw	r28, 0x06	; 6
     e22:	0f b6       	in	r0, 0x3f	; 63
     e24:	f8 94       	cli
     e26:	de bf       	out	0x3e, r29	; 62
     e28:	0f be       	out	0x3f, r0	; 63
     e2a:	cd bf       	out	0x3d, r28	; 61
     e2c:	cf 91       	pop	r28
     e2e:	df 91       	pop	r29
     e30:	08 95       	ret

00000e32 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     e32:	df 93       	push	r29
     e34:	cf 93       	push	r28
     e36:	00 d0       	rcall	.+0      	; 0xe38 <prvTestWaitCondition+0x6>
     e38:	00 d0       	rcall	.+0      	; 0xe3a <prvTestWaitCondition+0x8>
     e3a:	00 d0       	rcall	.+0      	; 0xe3c <prvTestWaitCondition+0xa>
     e3c:	cd b7       	in	r28, 0x3d	; 61
     e3e:	de b7       	in	r29, 0x3e	; 62
     e40:	9b 83       	std	Y+3, r25	; 0x03
     e42:	8a 83       	std	Y+2, r24	; 0x02
     e44:	7d 83       	std	Y+5, r23	; 0x05
     e46:	6c 83       	std	Y+4, r22	; 0x04
     e48:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     e4a:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     e4c:	8e 81       	ldd	r24, Y+6	; 0x06
     e4e:	88 23       	and	r24, r24
     e50:	59 f4       	brne	.+22     	; 0xe68 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     e52:	8a 81       	ldd	r24, Y+2	; 0x02
     e54:	9b 81       	ldd	r25, Y+3	; 0x03
     e56:	2c 81       	ldd	r18, Y+4	; 0x04
     e58:	3d 81       	ldd	r19, Y+5	; 0x05
     e5a:	82 23       	and	r24, r18
     e5c:	93 23       	and	r25, r19
     e5e:	00 97       	sbiw	r24, 0x00	; 0
     e60:	81 f0       	breq	.+32     	; 0xe82 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     e62:	81 e0       	ldi	r24, 0x01	; 1
     e64:	89 83       	std	Y+1, r24	; 0x01
     e66:	0d c0       	rjmp	.+26     	; 0xe82 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     e68:	2a 81       	ldd	r18, Y+2	; 0x02
     e6a:	3b 81       	ldd	r19, Y+3	; 0x03
     e6c:	8c 81       	ldd	r24, Y+4	; 0x04
     e6e:	9d 81       	ldd	r25, Y+5	; 0x05
     e70:	28 23       	and	r18, r24
     e72:	39 23       	and	r19, r25
     e74:	8c 81       	ldd	r24, Y+4	; 0x04
     e76:	9d 81       	ldd	r25, Y+5	; 0x05
     e78:	28 17       	cp	r18, r24
     e7a:	39 07       	cpc	r19, r25
     e7c:	11 f4       	brne	.+4      	; 0xe82 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     e7e:	81 e0       	ldi	r24, 0x01	; 1
     e80:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     e82:	89 81       	ldd	r24, Y+1	; 0x01
}
     e84:	26 96       	adiw	r28, 0x06	; 6
     e86:	0f b6       	in	r0, 0x3f	; 63
     e88:	f8 94       	cli
     e8a:	de bf       	out	0x3e, r29	; 62
     e8c:	0f be       	out	0x3f, r0	; 63
     e8e:	cd bf       	out	0x3d, r28	; 61
     e90:	cf 91       	pop	r28
     e92:	df 91       	pop	r29
     e94:	08 95       	ret

00000e96 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     e96:	df 93       	push	r29
     e98:	cf 93       	push	r28
     e9a:	00 d0       	rcall	.+0      	; 0xe9c <pvPortMalloc+0x6>
     e9c:	00 d0       	rcall	.+0      	; 0xe9e <pvPortMalloc+0x8>
     e9e:	cd b7       	in	r28, 0x3d	; 61
     ea0:	de b7       	in	r29, 0x3e	; 62
     ea2:	9c 83       	std	Y+4, r25	; 0x04
     ea4:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     ea6:	1a 82       	std	Y+2, r1	; 0x02
     ea8:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     eaa:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     eae:	80 91 c0 00 	lds	r24, 0x00C0
     eb2:	90 91 c1 00 	lds	r25, 0x00C1
     eb6:	00 97       	sbiw	r24, 0x00	; 0
     eb8:	31 f4       	brne	.+12     	; 0xec6 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     eba:	83 ec       	ldi	r24, 0xC3	; 195
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	90 93 c1 00 	sts	0x00C1, r25
     ec2:	80 93 c0 00 	sts	0x00C0, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     ec6:	80 91 be 00 	lds	r24, 0x00BE
     eca:	90 91 bf 00 	lds	r25, 0x00BF
     ece:	2b 81       	ldd	r18, Y+3	; 0x03
     ed0:	3c 81       	ldd	r19, Y+4	; 0x04
     ed2:	82 0f       	add	r24, r18
     ed4:	93 1f       	adc	r25, r19
     ed6:	24 e0       	ldi	r18, 0x04	; 4
     ed8:	8d 37       	cpi	r24, 0x7D	; 125
     eda:	92 07       	cpc	r25, r18
     edc:	38 f5       	brcc	.+78     	; 0xf2c <pvPortMalloc+0x96>
     ede:	20 91 be 00 	lds	r18, 0x00BE
     ee2:	30 91 bf 00 	lds	r19, 0x00BF
     ee6:	8b 81       	ldd	r24, Y+3	; 0x03
     ee8:	9c 81       	ldd	r25, Y+4	; 0x04
     eea:	28 0f       	add	r18, r24
     eec:	39 1f       	adc	r19, r25
     eee:	80 91 be 00 	lds	r24, 0x00BE
     ef2:	90 91 bf 00 	lds	r25, 0x00BF
     ef6:	82 17       	cp	r24, r18
     ef8:	93 07       	cpc	r25, r19
     efa:	c0 f4       	brcc	.+48     	; 0xf2c <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     efc:	20 91 c0 00 	lds	r18, 0x00C0
     f00:	30 91 c1 00 	lds	r19, 0x00C1
     f04:	80 91 be 00 	lds	r24, 0x00BE
     f08:	90 91 bf 00 	lds	r25, 0x00BF
     f0c:	82 0f       	add	r24, r18
     f0e:	93 1f       	adc	r25, r19
     f10:	9a 83       	std	Y+2, r25	; 0x02
     f12:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     f14:	20 91 be 00 	lds	r18, 0x00BE
     f18:	30 91 bf 00 	lds	r19, 0x00BF
     f1c:	8b 81       	ldd	r24, Y+3	; 0x03
     f1e:	9c 81       	ldd	r25, Y+4	; 0x04
     f20:	82 0f       	add	r24, r18
     f22:	93 1f       	adc	r25, r19
     f24:	90 93 bf 00 	sts	0x00BF, r25
     f28:	80 93 be 00 	sts	0x00BE, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     f2c:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     f30:	89 81       	ldd	r24, Y+1	; 0x01
     f32:	9a 81       	ldd	r25, Y+2	; 0x02
}
     f34:	0f 90       	pop	r0
     f36:	0f 90       	pop	r0
     f38:	0f 90       	pop	r0
     f3a:	0f 90       	pop	r0
     f3c:	cf 91       	pop	r28
     f3e:	df 91       	pop	r29
     f40:	08 95       	ret

00000f42 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     f42:	df 93       	push	r29
     f44:	cf 93       	push	r28
     f46:	00 d0       	rcall	.+0      	; 0xf48 <vPortFree+0x6>
     f48:	cd b7       	in	r28, 0x3d	; 61
     f4a:	de b7       	in	r29, 0x3e	; 62
     f4c:	9a 83       	std	Y+2, r25	; 0x02
     f4e:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     f50:	0f 90       	pop	r0
     f52:	0f 90       	pop	r0
     f54:	cf 91       	pop	r28
     f56:	df 91       	pop	r29
     f58:	08 95       	ret

00000f5a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     f5a:	df 93       	push	r29
     f5c:	cf 93       	push	r28
     f5e:	cd b7       	in	r28, 0x3d	; 61
     f60:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     f62:	10 92 bf 00 	sts	0x00BF, r1
     f66:	10 92 be 00 	sts	0x00BE, r1
}
     f6a:	cf 91       	pop	r28
     f6c:	df 91       	pop	r29
     f6e:	08 95       	ret

00000f70 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     f70:	df 93       	push	r29
     f72:	cf 93       	push	r28
     f74:	cd b7       	in	r28, 0x3d	; 61
     f76:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     f78:	20 91 be 00 	lds	r18, 0x00BE
     f7c:	30 91 bf 00 	lds	r19, 0x00BF
     f80:	8d e7       	ldi	r24, 0x7D	; 125
     f82:	94 e0       	ldi	r25, 0x04	; 4
     f84:	82 1b       	sub	r24, r18
     f86:	93 0b       	sbc	r25, r19
}
     f88:	cf 91       	pop	r28
     f8a:	df 91       	pop	r29
     f8c:	08 95       	ret

00000f8e <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
     f8e:	af 92       	push	r10
     f90:	bf 92       	push	r11
     f92:	cf 92       	push	r12
     f94:	df 92       	push	r13
     f96:	ef 92       	push	r14
     f98:	ff 92       	push	r15
     f9a:	0f 93       	push	r16
     f9c:	df 93       	push	r29
     f9e:	cf 93       	push	r28
     fa0:	00 d0       	rcall	.+0      	; 0xfa2 <vStartIntegerMathTasks+0x14>
     fa2:	0f 92       	push	r0
     fa4:	cd b7       	in	r28, 0x3d	; 61
     fa6:	de b7       	in	r29, 0x3e	; 62
     fa8:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
     faa:	1a 82       	std	Y+2, r1	; 0x02
     fac:	19 82       	std	Y+1, r1	; 0x01
     fae:	1b c0       	rjmp	.+54     	; 0xfe6 <vStartIntegerMathTasks+0x58>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
     fb0:	89 81       	ldd	r24, Y+1	; 0x01
     fb2:	9a 81       	ldd	r25, Y+2	; 0x02
     fb4:	fc 01       	movw	r30, r24
     fb6:	e0 5c       	subi	r30, 0xC0	; 192
     fb8:	fa 4f       	sbci	r31, 0xFA	; 250
     fba:	85 e0       	ldi	r24, 0x05	; 5
     fbc:	98 e0       	ldi	r25, 0x08	; 8
     fbe:	20 e7       	ldi	r18, 0x70	; 112
     fc0:	30 e0       	ldi	r19, 0x00	; 0
     fc2:	b9 01       	movw	r22, r18
     fc4:	45 e5       	ldi	r20, 0x55	; 85
     fc6:	50 e0       	ldi	r21, 0x00	; 0
     fc8:	9f 01       	movw	r18, r30
     fca:	0b 81       	ldd	r16, Y+3	; 0x03
     fcc:	ee 24       	eor	r14, r14
     fce:	ff 24       	eor	r15, r15
     fd0:	cc 24       	eor	r12, r12
     fd2:	dd 24       	eor	r13, r13
     fd4:	aa 24       	eor	r10, r10
     fd6:	bb 24       	eor	r11, r11
     fd8:	0e 94 4f 14 	call	0x289e	; 0x289e <xTaskGenericCreate>

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
     fdc:	89 81       	ldd	r24, Y+1	; 0x01
     fde:	9a 81       	ldd	r25, Y+2	; 0x02
     fe0:	01 96       	adiw	r24, 0x01	; 1
     fe2:	9a 83       	std	Y+2, r25	; 0x02
     fe4:	89 83       	std	Y+1, r24	; 0x01
     fe6:	89 81       	ldd	r24, Y+1	; 0x01
     fe8:	9a 81       	ldd	r25, Y+2	; 0x02
     fea:	18 16       	cp	r1, r24
     fec:	19 06       	cpc	r1, r25
     fee:	04 f7       	brge	.-64     	; 0xfb0 <vStartIntegerMathTasks+0x22>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
	}
}
     ff0:	0f 90       	pop	r0
     ff2:	0f 90       	pop	r0
     ff4:	0f 90       	pop	r0
     ff6:	cf 91       	pop	r28
     ff8:	df 91       	pop	r29
     ffa:	0f 91       	pop	r16
     ffc:	ff 90       	pop	r15
     ffe:	ef 90       	pop	r14
    1000:	df 90       	pop	r13
    1002:	cf 90       	pop	r12
    1004:	bf 90       	pop	r11
    1006:	af 90       	pop	r10
    1008:	08 95       	ret

0000100a <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    100a:	df 93       	push	r29
    100c:	cf 93       	push	r28
    100e:	cd b7       	in	r28, 0x3d	; 61
    1010:	de b7       	in	r29, 0x3e	; 62
    1012:	2a 97       	sbiw	r28, 0x0a	; 10
    1014:	0f b6       	in	r0, 0x3f	; 63
    1016:	f8 94       	cli
    1018:	de bf       	out	0x3e, r29	; 62
    101a:	0f be       	out	0x3f, r0	; 63
    101c:	cd bf       	out	0x3d, r28	; 61
    101e:	9a 87       	std	Y+10, r25	; 0x0a
    1020:	89 87       	std	Y+9, r24	; 0x09
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    1022:	1c 82       	std	Y+4, r1	; 0x04
    1024:	1b 82       	std	Y+3, r1	; 0x03
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    1026:	89 85       	ldd	r24, Y+9	; 0x09
    1028:	9a 85       	ldd	r25, Y+10	; 0x0a
    102a:	9a 83       	std	Y+2, r25	; 0x02
    102c:	89 83       	std	Y+1, r24	; 0x01
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    102e:	8b e7       	ldi	r24, 0x7B	; 123
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	a0 e0       	ldi	r26, 0x00	; 0
    1034:	b0 e0       	ldi	r27, 0x00	; 0
    1036:	8d 83       	std	Y+5, r24	; 0x05
    1038:	9e 83       	std	Y+6, r25	; 0x06
    103a:	af 83       	std	Y+7, r26	; 0x07
    103c:	b8 87       	std	Y+8, r27	; 0x08
		lValue += intgCONST2;
    103e:	8d 81       	ldd	r24, Y+5	; 0x05
    1040:	9e 81       	ldd	r25, Y+6	; 0x06
    1042:	af 81       	ldd	r26, Y+7	; 0x07
    1044:	b8 85       	ldd	r27, Y+8	; 0x08
    1046:	89 5b       	subi	r24, 0xB9	; 185
    1048:	9b 46       	sbci	r25, 0x6B	; 107
    104a:	ac 4f       	sbci	r26, 0xFC	; 252
    104c:	bf 4f       	sbci	r27, 0xFF	; 255
    104e:	8d 83       	std	Y+5, r24	; 0x05
    1050:	9e 83       	std	Y+6, r25	; 0x06
    1052:	af 83       	std	Y+7, r26	; 0x07
    1054:	b8 87       	std	Y+8, r27	; 0x08
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    1056:	8d 81       	ldd	r24, Y+5	; 0x05
    1058:	9e 81       	ldd	r25, Y+6	; 0x06
    105a:	af 81       	ldd	r26, Y+7	; 0x07
    105c:	b8 85       	ldd	r27, Y+8	; 0x08
    105e:	2d ef       	ldi	r18, 0xFD	; 253
    1060:	3f ef       	ldi	r19, 0xFF	; 255
    1062:	4f ef       	ldi	r20, 0xFF	; 255
    1064:	5f ef       	ldi	r21, 0xFF	; 255
    1066:	bc 01       	movw	r22, r24
    1068:	cd 01       	movw	r24, r26
    106a:	0e 94 5b 24 	call	0x48b6	; 0x48b6 <__mulsi3>
    106e:	dc 01       	movw	r26, r24
    1070:	cb 01       	movw	r24, r22
    1072:	8d 83       	std	Y+5, r24	; 0x05
    1074:	9e 83       	std	Y+6, r25	; 0x06
    1076:	af 83       	std	Y+7, r26	; 0x07
    1078:	b8 87       	std	Y+8, r27	; 0x08
		lValue /= intgCONST4;
    107a:	8d 81       	ldd	r24, Y+5	; 0x05
    107c:	9e 81       	ldd	r25, Y+6	; 0x06
    107e:	af 81       	ldd	r26, Y+7	; 0x07
    1080:	b8 85       	ldd	r27, Y+8	; 0x08
    1082:	27 e0       	ldi	r18, 0x07	; 7
    1084:	30 e0       	ldi	r19, 0x00	; 0
    1086:	40 e0       	ldi	r20, 0x00	; 0
    1088:	50 e0       	ldi	r21, 0x00	; 0
    108a:	bc 01       	movw	r22, r24
    108c:	cd 01       	movw	r24, r26
    108e:	0e 94 7a 24 	call	0x48f4	; 0x48f4 <__divmodsi4>
    1092:	da 01       	movw	r26, r20
    1094:	c9 01       	movw	r24, r18
    1096:	8d 83       	std	Y+5, r24	; 0x05
    1098:	9e 83       	std	Y+6, r25	; 0x06
    109a:	af 83       	std	Y+7, r26	; 0x07
    109c:	b8 87       	std	Y+8, r27	; 0x08

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    109e:	8d 81       	ldd	r24, Y+5	; 0x05
    10a0:	9e 81       	ldd	r25, Y+6	; 0x06
    10a2:	af 81       	ldd	r26, Y+7	; 0x07
    10a4:	b8 85       	ldd	r27, Y+8	; 0x08
    10a6:	8b 31       	cpi	r24, 0x1B	; 27
    10a8:	27 e7       	ldi	r18, 0x77	; 119
    10aa:	92 07       	cpc	r25, r18
    10ac:	2e ef       	ldi	r18, 0xFE	; 254
    10ae:	a2 07       	cpc	r26, r18
    10b0:	2f ef       	ldi	r18, 0xFF	; 255
    10b2:	b2 07       	cpc	r27, r18
    10b4:	21 f0       	breq	.+8      	; 0x10be <vCompeteingIntMathTask+0xb4>
		{
			sError = pdTRUE;
    10b6:	81 e0       	ldi	r24, 0x01	; 1
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	9c 83       	std	Y+4, r25	; 0x04
    10bc:	8b 83       	std	Y+3, r24	; 0x03
		}

		if( sError == pdFALSE )
    10be:	8b 81       	ldd	r24, Y+3	; 0x03
    10c0:	9c 81       	ldd	r25, Y+4	; 0x04
    10c2:	00 97       	sbiw	r24, 0x00	; 0
    10c4:	09 f0       	breq	.+2      	; 0x10c8 <vCompeteingIntMathTask+0xbe>
    10c6:	b3 cf       	rjmp	.-154    	; 0x102e <vCompeteingIntMathTask+0x24>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    10c8:	0f b6       	in	r0, 0x3f	; 63
    10ca:	f8 94       	cli
    10cc:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    10ce:	e9 81       	ldd	r30, Y+1	; 0x01
    10d0:	fa 81       	ldd	r31, Y+2	; 0x02
    10d2:	81 e0       	ldi	r24, 0x01	; 1
    10d4:	80 83       	st	Z, r24
			portEXIT_CRITICAL();
    10d6:	0f 90       	pop	r0
    10d8:	0f be       	out	0x3f, r0	; 63
    10da:	a9 cf       	rjmp	.-174    	; 0x102e <vCompeteingIntMathTask+0x24>

000010dc <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
    10dc:	df 93       	push	r29
    10de:	cf 93       	push	r28
    10e0:	00 d0       	rcall	.+0      	; 0x10e2 <xAreIntegerMathsTaskStillRunning+0x6>
    10e2:	0f 92       	push	r0
    10e4:	cd b7       	in	r28, 0x3d	; 61
    10e6:	de b7       	in	r29, 0x3e	; 62
BaseType_t xReturn = pdTRUE;
    10e8:	81 e0       	ldi	r24, 0x01	; 1
    10ea:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    10ec:	1a 82       	std	Y+2, r1	; 0x02
    10ee:	19 82       	std	Y+1, r1	; 0x01
    10f0:	14 c0       	rjmp	.+40     	; 0x111a <xAreIntegerMathsTaskStillRunning+0x3e>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    10f2:	89 81       	ldd	r24, Y+1	; 0x01
    10f4:	9a 81       	ldd	r25, Y+2	; 0x02
    10f6:	fc 01       	movw	r30, r24
    10f8:	e0 5c       	subi	r30, 0xC0	; 192
    10fa:	fa 4f       	sbci	r31, 0xFA	; 250
    10fc:	80 81       	ld	r24, Z
    10fe:	88 23       	and	r24, r24
    1100:	09 f4       	brne	.+2      	; 0x1104 <xAreIntegerMathsTaskStillRunning+0x28>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
    1102:	1b 82       	std	Y+3, r1	; 0x03
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    1104:	89 81       	ldd	r24, Y+1	; 0x01
    1106:	9a 81       	ldd	r25, Y+2	; 0x02
    1108:	fc 01       	movw	r30, r24
    110a:	e0 5c       	subi	r30, 0xC0	; 192
    110c:	fa 4f       	sbci	r31, 0xFA	; 250
    110e:	10 82       	st	Z, r1
BaseType_t xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1110:	89 81       	ldd	r24, Y+1	; 0x01
    1112:	9a 81       	ldd	r25, Y+2	; 0x02
    1114:	01 96       	adiw	r24, 0x01	; 1
    1116:	9a 83       	std	Y+2, r25	; 0x02
    1118:	89 83       	std	Y+1, r24	; 0x01
    111a:	89 81       	ldd	r24, Y+1	; 0x01
    111c:	9a 81       	ldd	r25, Y+2	; 0x02
    111e:	18 16       	cp	r1, r24
    1120:	19 06       	cpc	r1, r25
    1122:	3c f7       	brge	.-50     	; 0x10f2 <xAreIntegerMathsTaskStillRunning+0x16>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
    1124:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1126:	0f 90       	pop	r0
    1128:	0f 90       	pop	r0
    112a:	0f 90       	pop	r0
    112c:	cf 91       	pop	r28
    112e:	df 91       	pop	r29
    1130:	08 95       	ret

00001132 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1132:	df 93       	push	r29
    1134:	cf 93       	push	r28
    1136:	00 d0       	rcall	.+0      	; 0x1138 <vListInitialise+0x6>
    1138:	cd b7       	in	r28, 0x3d	; 61
    113a:	de b7       	in	r29, 0x3e	; 62
    113c:	9a 83       	std	Y+2, r25	; 0x02
    113e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1140:	89 81       	ldd	r24, Y+1	; 0x01
    1142:	9a 81       	ldd	r25, Y+2	; 0x02
    1144:	03 96       	adiw	r24, 0x03	; 3
    1146:	e9 81       	ldd	r30, Y+1	; 0x01
    1148:	fa 81       	ldd	r31, Y+2	; 0x02
    114a:	92 83       	std	Z+2, r25	; 0x02
    114c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    114e:	e9 81       	ldd	r30, Y+1	; 0x01
    1150:	fa 81       	ldd	r31, Y+2	; 0x02
    1152:	8f ef       	ldi	r24, 0xFF	; 255
    1154:	9f ef       	ldi	r25, 0xFF	; 255
    1156:	94 83       	std	Z+4, r25	; 0x04
    1158:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    115a:	89 81       	ldd	r24, Y+1	; 0x01
    115c:	9a 81       	ldd	r25, Y+2	; 0x02
    115e:	03 96       	adiw	r24, 0x03	; 3
    1160:	e9 81       	ldd	r30, Y+1	; 0x01
    1162:	fa 81       	ldd	r31, Y+2	; 0x02
    1164:	96 83       	std	Z+6, r25	; 0x06
    1166:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1168:	89 81       	ldd	r24, Y+1	; 0x01
    116a:	9a 81       	ldd	r25, Y+2	; 0x02
    116c:	03 96       	adiw	r24, 0x03	; 3
    116e:	e9 81       	ldd	r30, Y+1	; 0x01
    1170:	fa 81       	ldd	r31, Y+2	; 0x02
    1172:	90 87       	std	Z+8, r25	; 0x08
    1174:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1176:	e9 81       	ldd	r30, Y+1	; 0x01
    1178:	fa 81       	ldd	r31, Y+2	; 0x02
    117a:	10 82       	st	Z, r1
}
    117c:	0f 90       	pop	r0
    117e:	0f 90       	pop	r0
    1180:	cf 91       	pop	r28
    1182:	df 91       	pop	r29
    1184:	08 95       	ret

00001186 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1186:	df 93       	push	r29
    1188:	cf 93       	push	r28
    118a:	00 d0       	rcall	.+0      	; 0x118c <vListInitialiseItem+0x6>
    118c:	cd b7       	in	r28, 0x3d	; 61
    118e:	de b7       	in	r29, 0x3e	; 62
    1190:	9a 83       	std	Y+2, r25	; 0x02
    1192:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1194:	e9 81       	ldd	r30, Y+1	; 0x01
    1196:	fa 81       	ldd	r31, Y+2	; 0x02
    1198:	11 86       	std	Z+9, r1	; 0x09
    119a:	10 86       	std	Z+8, r1	; 0x08
}
    119c:	0f 90       	pop	r0
    119e:	0f 90       	pop	r0
    11a0:	cf 91       	pop	r28
    11a2:	df 91       	pop	r29
    11a4:	08 95       	ret

000011a6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    11a6:	df 93       	push	r29
    11a8:	cf 93       	push	r28
    11aa:	00 d0       	rcall	.+0      	; 0x11ac <vListInsertEnd+0x6>
    11ac:	00 d0       	rcall	.+0      	; 0x11ae <vListInsertEnd+0x8>
    11ae:	00 d0       	rcall	.+0      	; 0x11b0 <vListInsertEnd+0xa>
    11b0:	cd b7       	in	r28, 0x3d	; 61
    11b2:	de b7       	in	r29, 0x3e	; 62
    11b4:	9c 83       	std	Y+4, r25	; 0x04
    11b6:	8b 83       	std	Y+3, r24	; 0x03
    11b8:	7e 83       	std	Y+6, r23	; 0x06
    11ba:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    11bc:	eb 81       	ldd	r30, Y+3	; 0x03
    11be:	fc 81       	ldd	r31, Y+4	; 0x04
    11c0:	81 81       	ldd	r24, Z+1	; 0x01
    11c2:	92 81       	ldd	r25, Z+2	; 0x02
    11c4:	9a 83       	std	Y+2, r25	; 0x02
    11c6:	89 83       	std	Y+1, r24	; 0x01

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    11c8:	ed 81       	ldd	r30, Y+5	; 0x05
    11ca:	fe 81       	ldd	r31, Y+6	; 0x06
    11cc:	89 81       	ldd	r24, Y+1	; 0x01
    11ce:	9a 81       	ldd	r25, Y+2	; 0x02
    11d0:	93 83       	std	Z+3, r25	; 0x03
    11d2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    11d4:	e9 81       	ldd	r30, Y+1	; 0x01
    11d6:	fa 81       	ldd	r31, Y+2	; 0x02
    11d8:	84 81       	ldd	r24, Z+4	; 0x04
    11da:	95 81       	ldd	r25, Z+5	; 0x05
    11dc:	ed 81       	ldd	r30, Y+5	; 0x05
    11de:	fe 81       	ldd	r31, Y+6	; 0x06
    11e0:	95 83       	std	Z+5, r25	; 0x05
    11e2:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    11e4:	e9 81       	ldd	r30, Y+1	; 0x01
    11e6:	fa 81       	ldd	r31, Y+2	; 0x02
    11e8:	04 80       	ldd	r0, Z+4	; 0x04
    11ea:	f5 81       	ldd	r31, Z+5	; 0x05
    11ec:	e0 2d       	mov	r30, r0
    11ee:	8d 81       	ldd	r24, Y+5	; 0x05
    11f0:	9e 81       	ldd	r25, Y+6	; 0x06
    11f2:	93 83       	std	Z+3, r25	; 0x03
    11f4:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    11f6:	e9 81       	ldd	r30, Y+1	; 0x01
    11f8:	fa 81       	ldd	r31, Y+2	; 0x02
    11fa:	8d 81       	ldd	r24, Y+5	; 0x05
    11fc:	9e 81       	ldd	r25, Y+6	; 0x06
    11fe:	95 83       	std	Z+5, r25	; 0x05
    1200:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1202:	ed 81       	ldd	r30, Y+5	; 0x05
    1204:	fe 81       	ldd	r31, Y+6	; 0x06
    1206:	8b 81       	ldd	r24, Y+3	; 0x03
    1208:	9c 81       	ldd	r25, Y+4	; 0x04
    120a:	91 87       	std	Z+9, r25	; 0x09
    120c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    120e:	eb 81       	ldd	r30, Y+3	; 0x03
    1210:	fc 81       	ldd	r31, Y+4	; 0x04
    1212:	80 81       	ld	r24, Z
    1214:	8f 5f       	subi	r24, 0xFF	; 255
    1216:	eb 81       	ldd	r30, Y+3	; 0x03
    1218:	fc 81       	ldd	r31, Y+4	; 0x04
    121a:	80 83       	st	Z, r24
}
    121c:	26 96       	adiw	r28, 0x06	; 6
    121e:	0f b6       	in	r0, 0x3f	; 63
    1220:	f8 94       	cli
    1222:	de bf       	out	0x3e, r29	; 62
    1224:	0f be       	out	0x3f, r0	; 63
    1226:	cd bf       	out	0x3d, r28	; 61
    1228:	cf 91       	pop	r28
    122a:	df 91       	pop	r29
    122c:	08 95       	ret

0000122e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    122e:	df 93       	push	r29
    1230:	cf 93       	push	r28
    1232:	cd b7       	in	r28, 0x3d	; 61
    1234:	de b7       	in	r29, 0x3e	; 62
    1236:	28 97       	sbiw	r28, 0x08	; 8
    1238:	0f b6       	in	r0, 0x3f	; 63
    123a:	f8 94       	cli
    123c:	de bf       	out	0x3e, r29	; 62
    123e:	0f be       	out	0x3f, r0	; 63
    1240:	cd bf       	out	0x3d, r28	; 61
    1242:	9e 83       	std	Y+6, r25	; 0x06
    1244:	8d 83       	std	Y+5, r24	; 0x05
    1246:	78 87       	std	Y+8, r23	; 0x08
    1248:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    124a:	ef 81       	ldd	r30, Y+7	; 0x07
    124c:	f8 85       	ldd	r31, Y+8	; 0x08
    124e:	80 81       	ld	r24, Z
    1250:	91 81       	ldd	r25, Z+1	; 0x01
    1252:	9a 83       	std	Y+2, r25	; 0x02
    1254:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1256:	89 81       	ldd	r24, Y+1	; 0x01
    1258:	9a 81       	ldd	r25, Y+2	; 0x02
    125a:	2f ef       	ldi	r18, 0xFF	; 255
    125c:	8f 3f       	cpi	r24, 0xFF	; 255
    125e:	92 07       	cpc	r25, r18
    1260:	39 f4       	brne	.+14     	; 0x1270 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1262:	ed 81       	ldd	r30, Y+5	; 0x05
    1264:	fe 81       	ldd	r31, Y+6	; 0x06
    1266:	87 81       	ldd	r24, Z+7	; 0x07
    1268:	90 85       	ldd	r25, Z+8	; 0x08
    126a:	9c 83       	std	Y+4, r25	; 0x04
    126c:	8b 83       	std	Y+3, r24	; 0x03
    126e:	18 c0       	rjmp	.+48     	; 0x12a0 <vListInsert+0x72>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1270:	8d 81       	ldd	r24, Y+5	; 0x05
    1272:	9e 81       	ldd	r25, Y+6	; 0x06
    1274:	03 96       	adiw	r24, 0x03	; 3
    1276:	9c 83       	std	Y+4, r25	; 0x04
    1278:	8b 83       	std	Y+3, r24	; 0x03
    127a:	06 c0       	rjmp	.+12     	; 0x1288 <vListInsert+0x5a>
    127c:	eb 81       	ldd	r30, Y+3	; 0x03
    127e:	fc 81       	ldd	r31, Y+4	; 0x04
    1280:	82 81       	ldd	r24, Z+2	; 0x02
    1282:	93 81       	ldd	r25, Z+3	; 0x03
    1284:	9c 83       	std	Y+4, r25	; 0x04
    1286:	8b 83       	std	Y+3, r24	; 0x03
    1288:	eb 81       	ldd	r30, Y+3	; 0x03
    128a:	fc 81       	ldd	r31, Y+4	; 0x04
    128c:	02 80       	ldd	r0, Z+2	; 0x02
    128e:	f3 81       	ldd	r31, Z+3	; 0x03
    1290:	e0 2d       	mov	r30, r0
    1292:	20 81       	ld	r18, Z
    1294:	31 81       	ldd	r19, Z+1	; 0x01
    1296:	89 81       	ldd	r24, Y+1	; 0x01
    1298:	9a 81       	ldd	r25, Y+2	; 0x02
    129a:	82 17       	cp	r24, r18
    129c:	93 07       	cpc	r25, r19
    129e:	70 f7       	brcc	.-36     	; 0x127c <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    12a0:	eb 81       	ldd	r30, Y+3	; 0x03
    12a2:	fc 81       	ldd	r31, Y+4	; 0x04
    12a4:	82 81       	ldd	r24, Z+2	; 0x02
    12a6:	93 81       	ldd	r25, Z+3	; 0x03
    12a8:	ef 81       	ldd	r30, Y+7	; 0x07
    12aa:	f8 85       	ldd	r31, Y+8	; 0x08
    12ac:	93 83       	std	Z+3, r25	; 0x03
    12ae:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    12b0:	ef 81       	ldd	r30, Y+7	; 0x07
    12b2:	f8 85       	ldd	r31, Y+8	; 0x08
    12b4:	02 80       	ldd	r0, Z+2	; 0x02
    12b6:	f3 81       	ldd	r31, Z+3	; 0x03
    12b8:	e0 2d       	mov	r30, r0
    12ba:	8f 81       	ldd	r24, Y+7	; 0x07
    12bc:	98 85       	ldd	r25, Y+8	; 0x08
    12be:	95 83       	std	Z+5, r25	; 0x05
    12c0:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    12c2:	ef 81       	ldd	r30, Y+7	; 0x07
    12c4:	f8 85       	ldd	r31, Y+8	; 0x08
    12c6:	8b 81       	ldd	r24, Y+3	; 0x03
    12c8:	9c 81       	ldd	r25, Y+4	; 0x04
    12ca:	95 83       	std	Z+5, r25	; 0x05
    12cc:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    12ce:	eb 81       	ldd	r30, Y+3	; 0x03
    12d0:	fc 81       	ldd	r31, Y+4	; 0x04
    12d2:	8f 81       	ldd	r24, Y+7	; 0x07
    12d4:	98 85       	ldd	r25, Y+8	; 0x08
    12d6:	93 83       	std	Z+3, r25	; 0x03
    12d8:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    12da:	ef 81       	ldd	r30, Y+7	; 0x07
    12dc:	f8 85       	ldd	r31, Y+8	; 0x08
    12de:	8d 81       	ldd	r24, Y+5	; 0x05
    12e0:	9e 81       	ldd	r25, Y+6	; 0x06
    12e2:	91 87       	std	Z+9, r25	; 0x09
    12e4:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    12e6:	ed 81       	ldd	r30, Y+5	; 0x05
    12e8:	fe 81       	ldd	r31, Y+6	; 0x06
    12ea:	80 81       	ld	r24, Z
    12ec:	8f 5f       	subi	r24, 0xFF	; 255
    12ee:	ed 81       	ldd	r30, Y+5	; 0x05
    12f0:	fe 81       	ldd	r31, Y+6	; 0x06
    12f2:	80 83       	st	Z, r24
}
    12f4:	28 96       	adiw	r28, 0x08	; 8
    12f6:	0f b6       	in	r0, 0x3f	; 63
    12f8:	f8 94       	cli
    12fa:	de bf       	out	0x3e, r29	; 62
    12fc:	0f be       	out	0x3f, r0	; 63
    12fe:	cd bf       	out	0x3d, r28	; 61
    1300:	cf 91       	pop	r28
    1302:	df 91       	pop	r29
    1304:	08 95       	ret

00001306 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1306:	df 93       	push	r29
    1308:	cf 93       	push	r28
    130a:	00 d0       	rcall	.+0      	; 0x130c <uxListRemove+0x6>
    130c:	00 d0       	rcall	.+0      	; 0x130e <uxListRemove+0x8>
    130e:	cd b7       	in	r28, 0x3d	; 61
    1310:	de b7       	in	r29, 0x3e	; 62
    1312:	9c 83       	std	Y+4, r25	; 0x04
    1314:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1316:	eb 81       	ldd	r30, Y+3	; 0x03
    1318:	fc 81       	ldd	r31, Y+4	; 0x04
    131a:	80 85       	ldd	r24, Z+8	; 0x08
    131c:	91 85       	ldd	r25, Z+9	; 0x09
    131e:	9a 83       	std	Y+2, r25	; 0x02
    1320:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1322:	eb 81       	ldd	r30, Y+3	; 0x03
    1324:	fc 81       	ldd	r31, Y+4	; 0x04
    1326:	a2 81       	ldd	r26, Z+2	; 0x02
    1328:	b3 81       	ldd	r27, Z+3	; 0x03
    132a:	eb 81       	ldd	r30, Y+3	; 0x03
    132c:	fc 81       	ldd	r31, Y+4	; 0x04
    132e:	84 81       	ldd	r24, Z+4	; 0x04
    1330:	95 81       	ldd	r25, Z+5	; 0x05
    1332:	15 96       	adiw	r26, 0x05	; 5
    1334:	9c 93       	st	X, r25
    1336:	8e 93       	st	-X, r24
    1338:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    133a:	eb 81       	ldd	r30, Y+3	; 0x03
    133c:	fc 81       	ldd	r31, Y+4	; 0x04
    133e:	a4 81       	ldd	r26, Z+4	; 0x04
    1340:	b5 81       	ldd	r27, Z+5	; 0x05
    1342:	eb 81       	ldd	r30, Y+3	; 0x03
    1344:	fc 81       	ldd	r31, Y+4	; 0x04
    1346:	82 81       	ldd	r24, Z+2	; 0x02
    1348:	93 81       	ldd	r25, Z+3	; 0x03
    134a:	13 96       	adiw	r26, 0x03	; 3
    134c:	9c 93       	st	X, r25
    134e:	8e 93       	st	-X, r24
    1350:	12 97       	sbiw	r26, 0x02	; 2

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1352:	e9 81       	ldd	r30, Y+1	; 0x01
    1354:	fa 81       	ldd	r31, Y+2	; 0x02
    1356:	21 81       	ldd	r18, Z+1	; 0x01
    1358:	32 81       	ldd	r19, Z+2	; 0x02
    135a:	8b 81       	ldd	r24, Y+3	; 0x03
    135c:	9c 81       	ldd	r25, Y+4	; 0x04
    135e:	28 17       	cp	r18, r24
    1360:	39 07       	cpc	r19, r25
    1362:	41 f4       	brne	.+16     	; 0x1374 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1364:	eb 81       	ldd	r30, Y+3	; 0x03
    1366:	fc 81       	ldd	r31, Y+4	; 0x04
    1368:	84 81       	ldd	r24, Z+4	; 0x04
    136a:	95 81       	ldd	r25, Z+5	; 0x05
    136c:	e9 81       	ldd	r30, Y+1	; 0x01
    136e:	fa 81       	ldd	r31, Y+2	; 0x02
    1370:	92 83       	std	Z+2, r25	; 0x02
    1372:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1374:	eb 81       	ldd	r30, Y+3	; 0x03
    1376:	fc 81       	ldd	r31, Y+4	; 0x04
    1378:	11 86       	std	Z+9, r1	; 0x09
    137a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    137c:	e9 81       	ldd	r30, Y+1	; 0x01
    137e:	fa 81       	ldd	r31, Y+2	; 0x02
    1380:	80 81       	ld	r24, Z
    1382:	81 50       	subi	r24, 0x01	; 1
    1384:	e9 81       	ldd	r30, Y+1	; 0x01
    1386:	fa 81       	ldd	r31, Y+2	; 0x02
    1388:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    138a:	e9 81       	ldd	r30, Y+1	; 0x01
    138c:	fa 81       	ldd	r31, Y+2	; 0x02
    138e:	80 81       	ld	r24, Z
}
    1390:	0f 90       	pop	r0
    1392:	0f 90       	pop	r0
    1394:	0f 90       	pop	r0
    1396:	0f 90       	pop	r0
    1398:	cf 91       	pop	r28
    139a:	df 91       	pop	r29
    139c:	08 95       	ret

0000139e <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    139e:	df 93       	push	r29
    13a0:	cf 93       	push	r28
    13a2:	cd b7       	in	r28, 0x3d	; 61
    13a4:	de b7       	in	r29, 0x3e	; 62
    13a6:	28 97       	sbiw	r28, 0x08	; 8
    13a8:	0f b6       	in	r0, 0x3f	; 63
    13aa:	f8 94       	cli
    13ac:	de bf       	out	0x3e, r29	; 62
    13ae:	0f be       	out	0x3f, r0	; 63
    13b0:	cd bf       	out	0x3d, r28	; 61
    13b2:	9c 83       	std	Y+4, r25	; 0x04
    13b4:	8b 83       	std	Y+3, r24	; 0x03
    13b6:	7e 83       	std	Y+6, r23	; 0x06
    13b8:	6d 83       	std	Y+5, r22	; 0x05
    13ba:	58 87       	std	Y+8, r21	; 0x08
    13bc:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    13be:	eb 81       	ldd	r30, Y+3	; 0x03
    13c0:	fc 81       	ldd	r31, Y+4	; 0x04
    13c2:	81 e1       	ldi	r24, 0x11	; 17
    13c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    13c6:	8b 81       	ldd	r24, Y+3	; 0x03
    13c8:	9c 81       	ldd	r25, Y+4	; 0x04
    13ca:	01 97       	sbiw	r24, 0x01	; 1
    13cc:	9c 83       	std	Y+4, r25	; 0x04
    13ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    13d0:	eb 81       	ldd	r30, Y+3	; 0x03
    13d2:	fc 81       	ldd	r31, Y+4	; 0x04
    13d4:	82 e2       	ldi	r24, 0x22	; 34
    13d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    13d8:	8b 81       	ldd	r24, Y+3	; 0x03
    13da:	9c 81       	ldd	r25, Y+4	; 0x04
    13dc:	01 97       	sbiw	r24, 0x01	; 1
    13de:	9c 83       	std	Y+4, r25	; 0x04
    13e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    13e2:	eb 81       	ldd	r30, Y+3	; 0x03
    13e4:	fc 81       	ldd	r31, Y+4	; 0x04
    13e6:	83 e3       	ldi	r24, 0x33	; 51
    13e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    13ea:	8b 81       	ldd	r24, Y+3	; 0x03
    13ec:	9c 81       	ldd	r25, Y+4	; 0x04
    13ee:	01 97       	sbiw	r24, 0x01	; 1
    13f0:	9c 83       	std	Y+4, r25	; 0x04
    13f2:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    13f4:	8d 81       	ldd	r24, Y+5	; 0x05
    13f6:	9e 81       	ldd	r25, Y+6	; 0x06
    13f8:	9a 83       	std	Y+2, r25	; 0x02
    13fa:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    13fc:	89 81       	ldd	r24, Y+1	; 0x01
    13fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1400:	fc 81       	ldd	r31, Y+4	; 0x04
    1402:	80 83       	st	Z, r24
	pxTopOfStack--;
    1404:	8b 81       	ldd	r24, Y+3	; 0x03
    1406:	9c 81       	ldd	r25, Y+4	; 0x04
    1408:	01 97       	sbiw	r24, 0x01	; 1
    140a:	9c 83       	std	Y+4, r25	; 0x04
    140c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    140e:	89 81       	ldd	r24, Y+1	; 0x01
    1410:	9a 81       	ldd	r25, Y+2	; 0x02
    1412:	89 2f       	mov	r24, r25
    1414:	99 27       	eor	r25, r25
    1416:	9a 83       	std	Y+2, r25	; 0x02
    1418:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    141a:	89 81       	ldd	r24, Y+1	; 0x01
    141c:	eb 81       	ldd	r30, Y+3	; 0x03
    141e:	fc 81       	ldd	r31, Y+4	; 0x04
    1420:	80 83       	st	Z, r24
	pxTopOfStack--;
    1422:	8b 81       	ldd	r24, Y+3	; 0x03
    1424:	9c 81       	ldd	r25, Y+4	; 0x04
    1426:	01 97       	sbiw	r24, 0x01	; 1
    1428:	9c 83       	std	Y+4, r25	; 0x04
    142a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    142c:	eb 81       	ldd	r30, Y+3	; 0x03
    142e:	fc 81       	ldd	r31, Y+4	; 0x04
    1430:	10 82       	st	Z, r1
	pxTopOfStack--;
    1432:	8b 81       	ldd	r24, Y+3	; 0x03
    1434:	9c 81       	ldd	r25, Y+4	; 0x04
    1436:	01 97       	sbiw	r24, 0x01	; 1
    1438:	9c 83       	std	Y+4, r25	; 0x04
    143a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    143c:	eb 81       	ldd	r30, Y+3	; 0x03
    143e:	fc 81       	ldd	r31, Y+4	; 0x04
    1440:	80 e8       	ldi	r24, 0x80	; 128
    1442:	80 83       	st	Z, r24
	pxTopOfStack--;
    1444:	8b 81       	ldd	r24, Y+3	; 0x03
    1446:	9c 81       	ldd	r25, Y+4	; 0x04
    1448:	01 97       	sbiw	r24, 0x01	; 1
    144a:	9c 83       	std	Y+4, r25	; 0x04
    144c:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    144e:	eb 81       	ldd	r30, Y+3	; 0x03
    1450:	fc 81       	ldd	r31, Y+4	; 0x04
    1452:	10 82       	st	Z, r1
	pxTopOfStack--;
    1454:	8b 81       	ldd	r24, Y+3	; 0x03
    1456:	9c 81       	ldd	r25, Y+4	; 0x04
    1458:	01 97       	sbiw	r24, 0x01	; 1
    145a:	9c 83       	std	Y+4, r25	; 0x04
    145c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    145e:	eb 81       	ldd	r30, Y+3	; 0x03
    1460:	fc 81       	ldd	r31, Y+4	; 0x04
    1462:	82 e0       	ldi	r24, 0x02	; 2
    1464:	80 83       	st	Z, r24
	pxTopOfStack--;
    1466:	8b 81       	ldd	r24, Y+3	; 0x03
    1468:	9c 81       	ldd	r25, Y+4	; 0x04
    146a:	01 97       	sbiw	r24, 0x01	; 1
    146c:	9c 83       	std	Y+4, r25	; 0x04
    146e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1470:	eb 81       	ldd	r30, Y+3	; 0x03
    1472:	fc 81       	ldd	r31, Y+4	; 0x04
    1474:	83 e0       	ldi	r24, 0x03	; 3
    1476:	80 83       	st	Z, r24
	pxTopOfStack--;
    1478:	8b 81       	ldd	r24, Y+3	; 0x03
    147a:	9c 81       	ldd	r25, Y+4	; 0x04
    147c:	01 97       	sbiw	r24, 0x01	; 1
    147e:	9c 83       	std	Y+4, r25	; 0x04
    1480:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1482:	eb 81       	ldd	r30, Y+3	; 0x03
    1484:	fc 81       	ldd	r31, Y+4	; 0x04
    1486:	84 e0       	ldi	r24, 0x04	; 4
    1488:	80 83       	st	Z, r24
	pxTopOfStack--;
    148a:	8b 81       	ldd	r24, Y+3	; 0x03
    148c:	9c 81       	ldd	r25, Y+4	; 0x04
    148e:	01 97       	sbiw	r24, 0x01	; 1
    1490:	9c 83       	std	Y+4, r25	; 0x04
    1492:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1494:	eb 81       	ldd	r30, Y+3	; 0x03
    1496:	fc 81       	ldd	r31, Y+4	; 0x04
    1498:	85 e0       	ldi	r24, 0x05	; 5
    149a:	80 83       	st	Z, r24
	pxTopOfStack--;
    149c:	8b 81       	ldd	r24, Y+3	; 0x03
    149e:	9c 81       	ldd	r25, Y+4	; 0x04
    14a0:	01 97       	sbiw	r24, 0x01	; 1
    14a2:	9c 83       	std	Y+4, r25	; 0x04
    14a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    14a6:	eb 81       	ldd	r30, Y+3	; 0x03
    14a8:	fc 81       	ldd	r31, Y+4	; 0x04
    14aa:	86 e0       	ldi	r24, 0x06	; 6
    14ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    14ae:	8b 81       	ldd	r24, Y+3	; 0x03
    14b0:	9c 81       	ldd	r25, Y+4	; 0x04
    14b2:	01 97       	sbiw	r24, 0x01	; 1
    14b4:	9c 83       	std	Y+4, r25	; 0x04
    14b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    14b8:	eb 81       	ldd	r30, Y+3	; 0x03
    14ba:	fc 81       	ldd	r31, Y+4	; 0x04
    14bc:	87 e0       	ldi	r24, 0x07	; 7
    14be:	80 83       	st	Z, r24
	pxTopOfStack--;
    14c0:	8b 81       	ldd	r24, Y+3	; 0x03
    14c2:	9c 81       	ldd	r25, Y+4	; 0x04
    14c4:	01 97       	sbiw	r24, 0x01	; 1
    14c6:	9c 83       	std	Y+4, r25	; 0x04
    14c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    14ca:	eb 81       	ldd	r30, Y+3	; 0x03
    14cc:	fc 81       	ldd	r31, Y+4	; 0x04
    14ce:	88 e0       	ldi	r24, 0x08	; 8
    14d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    14d2:	8b 81       	ldd	r24, Y+3	; 0x03
    14d4:	9c 81       	ldd	r25, Y+4	; 0x04
    14d6:	01 97       	sbiw	r24, 0x01	; 1
    14d8:	9c 83       	std	Y+4, r25	; 0x04
    14da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    14dc:	eb 81       	ldd	r30, Y+3	; 0x03
    14de:	fc 81       	ldd	r31, Y+4	; 0x04
    14e0:	89 e0       	ldi	r24, 0x09	; 9
    14e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    14e4:	8b 81       	ldd	r24, Y+3	; 0x03
    14e6:	9c 81       	ldd	r25, Y+4	; 0x04
    14e8:	01 97       	sbiw	r24, 0x01	; 1
    14ea:	9c 83       	std	Y+4, r25	; 0x04
    14ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    14ee:	eb 81       	ldd	r30, Y+3	; 0x03
    14f0:	fc 81       	ldd	r31, Y+4	; 0x04
    14f2:	80 e1       	ldi	r24, 0x10	; 16
    14f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    14f6:	8b 81       	ldd	r24, Y+3	; 0x03
    14f8:	9c 81       	ldd	r25, Y+4	; 0x04
    14fa:	01 97       	sbiw	r24, 0x01	; 1
    14fc:	9c 83       	std	Y+4, r25	; 0x04
    14fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1500:	eb 81       	ldd	r30, Y+3	; 0x03
    1502:	fc 81       	ldd	r31, Y+4	; 0x04
    1504:	81 e1       	ldi	r24, 0x11	; 17
    1506:	80 83       	st	Z, r24
	pxTopOfStack--;
    1508:	8b 81       	ldd	r24, Y+3	; 0x03
    150a:	9c 81       	ldd	r25, Y+4	; 0x04
    150c:	01 97       	sbiw	r24, 0x01	; 1
    150e:	9c 83       	std	Y+4, r25	; 0x04
    1510:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1512:	eb 81       	ldd	r30, Y+3	; 0x03
    1514:	fc 81       	ldd	r31, Y+4	; 0x04
    1516:	82 e1       	ldi	r24, 0x12	; 18
    1518:	80 83       	st	Z, r24
	pxTopOfStack--;
    151a:	8b 81       	ldd	r24, Y+3	; 0x03
    151c:	9c 81       	ldd	r25, Y+4	; 0x04
    151e:	01 97       	sbiw	r24, 0x01	; 1
    1520:	9c 83       	std	Y+4, r25	; 0x04
    1522:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1524:	eb 81       	ldd	r30, Y+3	; 0x03
    1526:	fc 81       	ldd	r31, Y+4	; 0x04
    1528:	83 e1       	ldi	r24, 0x13	; 19
    152a:	80 83       	st	Z, r24
	pxTopOfStack--;
    152c:	8b 81       	ldd	r24, Y+3	; 0x03
    152e:	9c 81       	ldd	r25, Y+4	; 0x04
    1530:	01 97       	sbiw	r24, 0x01	; 1
    1532:	9c 83       	std	Y+4, r25	; 0x04
    1534:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1536:	eb 81       	ldd	r30, Y+3	; 0x03
    1538:	fc 81       	ldd	r31, Y+4	; 0x04
    153a:	84 e1       	ldi	r24, 0x14	; 20
    153c:	80 83       	st	Z, r24
	pxTopOfStack--;
    153e:	8b 81       	ldd	r24, Y+3	; 0x03
    1540:	9c 81       	ldd	r25, Y+4	; 0x04
    1542:	01 97       	sbiw	r24, 0x01	; 1
    1544:	9c 83       	std	Y+4, r25	; 0x04
    1546:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1548:	eb 81       	ldd	r30, Y+3	; 0x03
    154a:	fc 81       	ldd	r31, Y+4	; 0x04
    154c:	85 e1       	ldi	r24, 0x15	; 21
    154e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1550:	8b 81       	ldd	r24, Y+3	; 0x03
    1552:	9c 81       	ldd	r25, Y+4	; 0x04
    1554:	01 97       	sbiw	r24, 0x01	; 1
    1556:	9c 83       	std	Y+4, r25	; 0x04
    1558:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    155a:	eb 81       	ldd	r30, Y+3	; 0x03
    155c:	fc 81       	ldd	r31, Y+4	; 0x04
    155e:	86 e1       	ldi	r24, 0x16	; 22
    1560:	80 83       	st	Z, r24
	pxTopOfStack--;
    1562:	8b 81       	ldd	r24, Y+3	; 0x03
    1564:	9c 81       	ldd	r25, Y+4	; 0x04
    1566:	01 97       	sbiw	r24, 0x01	; 1
    1568:	9c 83       	std	Y+4, r25	; 0x04
    156a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    156c:	eb 81       	ldd	r30, Y+3	; 0x03
    156e:	fc 81       	ldd	r31, Y+4	; 0x04
    1570:	87 e1       	ldi	r24, 0x17	; 23
    1572:	80 83       	st	Z, r24
	pxTopOfStack--;
    1574:	8b 81       	ldd	r24, Y+3	; 0x03
    1576:	9c 81       	ldd	r25, Y+4	; 0x04
    1578:	01 97       	sbiw	r24, 0x01	; 1
    157a:	9c 83       	std	Y+4, r25	; 0x04
    157c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    157e:	eb 81       	ldd	r30, Y+3	; 0x03
    1580:	fc 81       	ldd	r31, Y+4	; 0x04
    1582:	88 e1       	ldi	r24, 0x18	; 24
    1584:	80 83       	st	Z, r24
	pxTopOfStack--;
    1586:	8b 81       	ldd	r24, Y+3	; 0x03
    1588:	9c 81       	ldd	r25, Y+4	; 0x04
    158a:	01 97       	sbiw	r24, 0x01	; 1
    158c:	9c 83       	std	Y+4, r25	; 0x04
    158e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1590:	eb 81       	ldd	r30, Y+3	; 0x03
    1592:	fc 81       	ldd	r31, Y+4	; 0x04
    1594:	89 e1       	ldi	r24, 0x19	; 25
    1596:	80 83       	st	Z, r24
	pxTopOfStack--;
    1598:	8b 81       	ldd	r24, Y+3	; 0x03
    159a:	9c 81       	ldd	r25, Y+4	; 0x04
    159c:	01 97       	sbiw	r24, 0x01	; 1
    159e:	9c 83       	std	Y+4, r25	; 0x04
    15a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    15a2:	eb 81       	ldd	r30, Y+3	; 0x03
    15a4:	fc 81       	ldd	r31, Y+4	; 0x04
    15a6:	80 e2       	ldi	r24, 0x20	; 32
    15a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    15aa:	8b 81       	ldd	r24, Y+3	; 0x03
    15ac:	9c 81       	ldd	r25, Y+4	; 0x04
    15ae:	01 97       	sbiw	r24, 0x01	; 1
    15b0:	9c 83       	std	Y+4, r25	; 0x04
    15b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    15b4:	eb 81       	ldd	r30, Y+3	; 0x03
    15b6:	fc 81       	ldd	r31, Y+4	; 0x04
    15b8:	81 e2       	ldi	r24, 0x21	; 33
    15ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    15bc:	8b 81       	ldd	r24, Y+3	; 0x03
    15be:	9c 81       	ldd	r25, Y+4	; 0x04
    15c0:	01 97       	sbiw	r24, 0x01	; 1
    15c2:	9c 83       	std	Y+4, r25	; 0x04
    15c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    15c6:	eb 81       	ldd	r30, Y+3	; 0x03
    15c8:	fc 81       	ldd	r31, Y+4	; 0x04
    15ca:	82 e2       	ldi	r24, 0x22	; 34
    15cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    15ce:	8b 81       	ldd	r24, Y+3	; 0x03
    15d0:	9c 81       	ldd	r25, Y+4	; 0x04
    15d2:	01 97       	sbiw	r24, 0x01	; 1
    15d4:	9c 83       	std	Y+4, r25	; 0x04
    15d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    15d8:	eb 81       	ldd	r30, Y+3	; 0x03
    15da:	fc 81       	ldd	r31, Y+4	; 0x04
    15dc:	83 e2       	ldi	r24, 0x23	; 35
    15de:	80 83       	st	Z, r24
	pxTopOfStack--;
    15e0:	8b 81       	ldd	r24, Y+3	; 0x03
    15e2:	9c 81       	ldd	r25, Y+4	; 0x04
    15e4:	01 97       	sbiw	r24, 0x01	; 1
    15e6:	9c 83       	std	Y+4, r25	; 0x04
    15e8:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    15ea:	8f 81       	ldd	r24, Y+7	; 0x07
    15ec:	98 85       	ldd	r25, Y+8	; 0x08
    15ee:	9a 83       	std	Y+2, r25	; 0x02
    15f0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    15f2:	89 81       	ldd	r24, Y+1	; 0x01
    15f4:	eb 81       	ldd	r30, Y+3	; 0x03
    15f6:	fc 81       	ldd	r31, Y+4	; 0x04
    15f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    15fa:	8b 81       	ldd	r24, Y+3	; 0x03
    15fc:	9c 81       	ldd	r25, Y+4	; 0x04
    15fe:	01 97       	sbiw	r24, 0x01	; 1
    1600:	9c 83       	std	Y+4, r25	; 0x04
    1602:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1604:	89 81       	ldd	r24, Y+1	; 0x01
    1606:	9a 81       	ldd	r25, Y+2	; 0x02
    1608:	89 2f       	mov	r24, r25
    160a:	99 27       	eor	r25, r25
    160c:	9a 83       	std	Y+2, r25	; 0x02
    160e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1610:	89 81       	ldd	r24, Y+1	; 0x01
    1612:	eb 81       	ldd	r30, Y+3	; 0x03
    1614:	fc 81       	ldd	r31, Y+4	; 0x04
    1616:	80 83       	st	Z, r24
	pxTopOfStack--;
    1618:	8b 81       	ldd	r24, Y+3	; 0x03
    161a:	9c 81       	ldd	r25, Y+4	; 0x04
    161c:	01 97       	sbiw	r24, 0x01	; 1
    161e:	9c 83       	std	Y+4, r25	; 0x04
    1620:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1622:	eb 81       	ldd	r30, Y+3	; 0x03
    1624:	fc 81       	ldd	r31, Y+4	; 0x04
    1626:	86 e2       	ldi	r24, 0x26	; 38
    1628:	80 83       	st	Z, r24
	pxTopOfStack--;
    162a:	8b 81       	ldd	r24, Y+3	; 0x03
    162c:	9c 81       	ldd	r25, Y+4	; 0x04
    162e:	01 97       	sbiw	r24, 0x01	; 1
    1630:	9c 83       	std	Y+4, r25	; 0x04
    1632:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1634:	eb 81       	ldd	r30, Y+3	; 0x03
    1636:	fc 81       	ldd	r31, Y+4	; 0x04
    1638:	87 e2       	ldi	r24, 0x27	; 39
    163a:	80 83       	st	Z, r24
	pxTopOfStack--;
    163c:	8b 81       	ldd	r24, Y+3	; 0x03
    163e:	9c 81       	ldd	r25, Y+4	; 0x04
    1640:	01 97       	sbiw	r24, 0x01	; 1
    1642:	9c 83       	std	Y+4, r25	; 0x04
    1644:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1646:	eb 81       	ldd	r30, Y+3	; 0x03
    1648:	fc 81       	ldd	r31, Y+4	; 0x04
    164a:	88 e2       	ldi	r24, 0x28	; 40
    164c:	80 83       	st	Z, r24
	pxTopOfStack--;
    164e:	8b 81       	ldd	r24, Y+3	; 0x03
    1650:	9c 81       	ldd	r25, Y+4	; 0x04
    1652:	01 97       	sbiw	r24, 0x01	; 1
    1654:	9c 83       	std	Y+4, r25	; 0x04
    1656:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1658:	eb 81       	ldd	r30, Y+3	; 0x03
    165a:	fc 81       	ldd	r31, Y+4	; 0x04
    165c:	89 e2       	ldi	r24, 0x29	; 41
    165e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1660:	8b 81       	ldd	r24, Y+3	; 0x03
    1662:	9c 81       	ldd	r25, Y+4	; 0x04
    1664:	01 97       	sbiw	r24, 0x01	; 1
    1666:	9c 83       	std	Y+4, r25	; 0x04
    1668:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    166a:	eb 81       	ldd	r30, Y+3	; 0x03
    166c:	fc 81       	ldd	r31, Y+4	; 0x04
    166e:	80 e3       	ldi	r24, 0x30	; 48
    1670:	80 83       	st	Z, r24
	pxTopOfStack--;
    1672:	8b 81       	ldd	r24, Y+3	; 0x03
    1674:	9c 81       	ldd	r25, Y+4	; 0x04
    1676:	01 97       	sbiw	r24, 0x01	; 1
    1678:	9c 83       	std	Y+4, r25	; 0x04
    167a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    167c:	eb 81       	ldd	r30, Y+3	; 0x03
    167e:	fc 81       	ldd	r31, Y+4	; 0x04
    1680:	81 e3       	ldi	r24, 0x31	; 49
    1682:	80 83       	st	Z, r24
	pxTopOfStack--;
    1684:	8b 81       	ldd	r24, Y+3	; 0x03
    1686:	9c 81       	ldd	r25, Y+4	; 0x04
    1688:	01 97       	sbiw	r24, 0x01	; 1
    168a:	9c 83       	std	Y+4, r25	; 0x04
    168c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    168e:	8b 81       	ldd	r24, Y+3	; 0x03
    1690:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1692:	28 96       	adiw	r28, 0x08	; 8
    1694:	0f b6       	in	r0, 0x3f	; 63
    1696:	f8 94       	cli
    1698:	de bf       	out	0x3e, r29	; 62
    169a:	0f be       	out	0x3f, r0	; 63
    169c:	cd bf       	out	0x3d, r28	; 61
    169e:	cf 91       	pop	r28
    16a0:	df 91       	pop	r29
    16a2:	08 95       	ret

000016a4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    16a4:	df 93       	push	r29
    16a6:	cf 93       	push	r28
    16a8:	cd b7       	in	r28, 0x3d	; 61
    16aa:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    16ac:	0e 94 44 0c 	call	0x1888	; 0x1888 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    16b0:	a0 91 41 05 	lds	r26, 0x0541
    16b4:	b0 91 42 05 	lds	r27, 0x0542
    16b8:	cd 91       	ld	r28, X+
    16ba:	cd bf       	out	0x3d, r28	; 61
    16bc:	dd 91       	ld	r29, X+
    16be:	de bf       	out	0x3e, r29	; 62
    16c0:	ff 91       	pop	r31
    16c2:	ef 91       	pop	r30
    16c4:	df 91       	pop	r29
    16c6:	cf 91       	pop	r28
    16c8:	bf 91       	pop	r27
    16ca:	af 91       	pop	r26
    16cc:	9f 91       	pop	r25
    16ce:	8f 91       	pop	r24
    16d0:	7f 91       	pop	r23
    16d2:	6f 91       	pop	r22
    16d4:	5f 91       	pop	r21
    16d6:	4f 91       	pop	r20
    16d8:	3f 91       	pop	r19
    16da:	2f 91       	pop	r18
    16dc:	1f 91       	pop	r17
    16de:	0f 91       	pop	r16
    16e0:	ff 90       	pop	r15
    16e2:	ef 90       	pop	r14
    16e4:	df 90       	pop	r13
    16e6:	cf 90       	pop	r12
    16e8:	bf 90       	pop	r11
    16ea:	af 90       	pop	r10
    16ec:	9f 90       	pop	r9
    16ee:	8f 90       	pop	r8
    16f0:	7f 90       	pop	r7
    16f2:	6f 90       	pop	r6
    16f4:	5f 90       	pop	r5
    16f6:	4f 90       	pop	r4
    16f8:	3f 90       	pop	r3
    16fa:	2f 90       	pop	r2
    16fc:	1f 90       	pop	r1
    16fe:	0f 90       	pop	r0
    1700:	0f be       	out	0x3f, r0	; 63
    1702:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1704:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1706:	81 e0       	ldi	r24, 0x01	; 1
}
    1708:	cf 91       	pop	r28
    170a:	df 91       	pop	r29
    170c:	08 95       	ret

0000170e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    170e:	df 93       	push	r29
    1710:	cf 93       	push	r28
    1712:	cd b7       	in	r28, 0x3d	; 61
    1714:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1716:	cf 91       	pop	r28
    1718:	df 91       	pop	r29
    171a:	08 95       	ret

0000171c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    171c:	0f 92       	push	r0
    171e:	0f b6       	in	r0, 0x3f	; 63
    1720:	f8 94       	cli
    1722:	0f 92       	push	r0
    1724:	1f 92       	push	r1
    1726:	11 24       	eor	r1, r1
    1728:	2f 92       	push	r2
    172a:	3f 92       	push	r3
    172c:	4f 92       	push	r4
    172e:	5f 92       	push	r5
    1730:	6f 92       	push	r6
    1732:	7f 92       	push	r7
    1734:	8f 92       	push	r8
    1736:	9f 92       	push	r9
    1738:	af 92       	push	r10
    173a:	bf 92       	push	r11
    173c:	cf 92       	push	r12
    173e:	df 92       	push	r13
    1740:	ef 92       	push	r14
    1742:	ff 92       	push	r15
    1744:	0f 93       	push	r16
    1746:	1f 93       	push	r17
    1748:	2f 93       	push	r18
    174a:	3f 93       	push	r19
    174c:	4f 93       	push	r20
    174e:	5f 93       	push	r21
    1750:	6f 93       	push	r22
    1752:	7f 93       	push	r23
    1754:	8f 93       	push	r24
    1756:	9f 93       	push	r25
    1758:	af 93       	push	r26
    175a:	bf 93       	push	r27
    175c:	cf 93       	push	r28
    175e:	df 93       	push	r29
    1760:	ef 93       	push	r30
    1762:	ff 93       	push	r31
    1764:	a0 91 41 05 	lds	r26, 0x0541
    1768:	b0 91 42 05 	lds	r27, 0x0542
    176c:	0d b6       	in	r0, 0x3d	; 61
    176e:	0d 92       	st	X+, r0
    1770:	0e b6       	in	r0, 0x3e	; 62
    1772:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1774:	0e 94 2f 19 	call	0x325e	; 0x325e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1778:	a0 91 41 05 	lds	r26, 0x0541
    177c:	b0 91 42 05 	lds	r27, 0x0542
    1780:	cd 91       	ld	r28, X+
    1782:	cd bf       	out	0x3d, r28	; 61
    1784:	dd 91       	ld	r29, X+
    1786:	de bf       	out	0x3e, r29	; 62
    1788:	ff 91       	pop	r31
    178a:	ef 91       	pop	r30
    178c:	df 91       	pop	r29
    178e:	cf 91       	pop	r28
    1790:	bf 91       	pop	r27
    1792:	af 91       	pop	r26
    1794:	9f 91       	pop	r25
    1796:	8f 91       	pop	r24
    1798:	7f 91       	pop	r23
    179a:	6f 91       	pop	r22
    179c:	5f 91       	pop	r21
    179e:	4f 91       	pop	r20
    17a0:	3f 91       	pop	r19
    17a2:	2f 91       	pop	r18
    17a4:	1f 91       	pop	r17
    17a6:	0f 91       	pop	r16
    17a8:	ff 90       	pop	r15
    17aa:	ef 90       	pop	r14
    17ac:	df 90       	pop	r13
    17ae:	cf 90       	pop	r12
    17b0:	bf 90       	pop	r11
    17b2:	af 90       	pop	r10
    17b4:	9f 90       	pop	r9
    17b6:	8f 90       	pop	r8
    17b8:	7f 90       	pop	r7
    17ba:	6f 90       	pop	r6
    17bc:	5f 90       	pop	r5
    17be:	4f 90       	pop	r4
    17c0:	3f 90       	pop	r3
    17c2:	2f 90       	pop	r2
    17c4:	1f 90       	pop	r1
    17c6:	0f 90       	pop	r0
    17c8:	0f be       	out	0x3f, r0	; 63
    17ca:	0f 90       	pop	r0

	asm volatile ( "ret" );
    17cc:	08 95       	ret

000017ce <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    17ce:	0f 92       	push	r0
    17d0:	0f b6       	in	r0, 0x3f	; 63
    17d2:	f8 94       	cli
    17d4:	0f 92       	push	r0
    17d6:	1f 92       	push	r1
    17d8:	11 24       	eor	r1, r1
    17da:	2f 92       	push	r2
    17dc:	3f 92       	push	r3
    17de:	4f 92       	push	r4
    17e0:	5f 92       	push	r5
    17e2:	6f 92       	push	r6
    17e4:	7f 92       	push	r7
    17e6:	8f 92       	push	r8
    17e8:	9f 92       	push	r9
    17ea:	af 92       	push	r10
    17ec:	bf 92       	push	r11
    17ee:	cf 92       	push	r12
    17f0:	df 92       	push	r13
    17f2:	ef 92       	push	r14
    17f4:	ff 92       	push	r15
    17f6:	0f 93       	push	r16
    17f8:	1f 93       	push	r17
    17fa:	2f 93       	push	r18
    17fc:	3f 93       	push	r19
    17fe:	4f 93       	push	r20
    1800:	5f 93       	push	r21
    1802:	6f 93       	push	r22
    1804:	7f 93       	push	r23
    1806:	8f 93       	push	r24
    1808:	9f 93       	push	r25
    180a:	af 93       	push	r26
    180c:	bf 93       	push	r27
    180e:	cf 93       	push	r28
    1810:	df 93       	push	r29
    1812:	ef 93       	push	r30
    1814:	ff 93       	push	r31
    1816:	a0 91 41 05 	lds	r26, 0x0541
    181a:	b0 91 42 05 	lds	r27, 0x0542
    181e:	0d b6       	in	r0, 0x3d	; 61
    1820:	0d 92       	st	X+, r0
    1822:	0e b6       	in	r0, 0x3e	; 62
    1824:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1826:	0e 94 48 18 	call	0x3090	; 0x3090 <xTaskIncrementTick>
    182a:	88 23       	and	r24, r24
    182c:	11 f0       	breq	.+4      	; 0x1832 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    182e:	0e 94 2f 19 	call	0x325e	; 0x325e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1832:	a0 91 41 05 	lds	r26, 0x0541
    1836:	b0 91 42 05 	lds	r27, 0x0542
    183a:	cd 91       	ld	r28, X+
    183c:	cd bf       	out	0x3d, r28	; 61
    183e:	dd 91       	ld	r29, X+
    1840:	de bf       	out	0x3e, r29	; 62
    1842:	ff 91       	pop	r31
    1844:	ef 91       	pop	r30
    1846:	df 91       	pop	r29
    1848:	cf 91       	pop	r28
    184a:	bf 91       	pop	r27
    184c:	af 91       	pop	r26
    184e:	9f 91       	pop	r25
    1850:	8f 91       	pop	r24
    1852:	7f 91       	pop	r23
    1854:	6f 91       	pop	r22
    1856:	5f 91       	pop	r21
    1858:	4f 91       	pop	r20
    185a:	3f 91       	pop	r19
    185c:	2f 91       	pop	r18
    185e:	1f 91       	pop	r17
    1860:	0f 91       	pop	r16
    1862:	ff 90       	pop	r15
    1864:	ef 90       	pop	r14
    1866:	df 90       	pop	r13
    1868:	cf 90       	pop	r12
    186a:	bf 90       	pop	r11
    186c:	af 90       	pop	r10
    186e:	9f 90       	pop	r9
    1870:	8f 90       	pop	r8
    1872:	7f 90       	pop	r7
    1874:	6f 90       	pop	r6
    1876:	5f 90       	pop	r5
    1878:	4f 90       	pop	r4
    187a:	3f 90       	pop	r3
    187c:	2f 90       	pop	r2
    187e:	1f 90       	pop	r1
    1880:	0f 90       	pop	r0
    1882:	0f be       	out	0x3f, r0	; 63
    1884:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1886:	08 95       	ret

00001888 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1888:	df 93       	push	r29
    188a:	cf 93       	push	r28
    188c:	00 d0       	rcall	.+0      	; 0x188e <prvSetupTimerInterrupt+0x6>
    188e:	00 d0       	rcall	.+0      	; 0x1890 <prvSetupTimerInterrupt+0x8>
    1890:	00 d0       	rcall	.+0      	; 0x1892 <prvSetupTimerInterrupt+0xa>
    1892:	cd b7       	in	r28, 0x3d	; 61
    1894:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1896:	80 e4       	ldi	r24, 0x40	; 64
    1898:	9f e1       	ldi	r25, 0x1F	; 31
    189a:	a0 e0       	ldi	r26, 0x00	; 0
    189c:	b0 e0       	ldi	r27, 0x00	; 0
    189e:	8b 83       	std	Y+3, r24	; 0x03
    18a0:	9c 83       	std	Y+4, r25	; 0x04
    18a2:	ad 83       	std	Y+5, r26	; 0x05
    18a4:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    18a6:	8b 81       	ldd	r24, Y+3	; 0x03
    18a8:	9c 81       	ldd	r25, Y+4	; 0x04
    18aa:	ad 81       	ldd	r26, Y+5	; 0x05
    18ac:	be 81       	ldd	r27, Y+6	; 0x06
    18ae:	68 94       	set
    18b0:	15 f8       	bld	r1, 5
    18b2:	b6 95       	lsr	r27
    18b4:	a7 95       	ror	r26
    18b6:	97 95       	ror	r25
    18b8:	87 95       	ror	r24
    18ba:	16 94       	lsr	r1
    18bc:	d1 f7       	brne	.-12     	; 0x18b2 <prvSetupTimerInterrupt+0x2a>
    18be:	8b 83       	std	Y+3, r24	; 0x03
    18c0:	9c 83       	std	Y+4, r25	; 0x04
    18c2:	ad 83       	std	Y+5, r26	; 0x05
    18c4:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    18c6:	8b 81       	ldd	r24, Y+3	; 0x03
    18c8:	9c 81       	ldd	r25, Y+4	; 0x04
    18ca:	ad 81       	ldd	r26, Y+5	; 0x05
    18cc:	be 81       	ldd	r27, Y+6	; 0x06
    18ce:	01 97       	sbiw	r24, 0x01	; 1
    18d0:	a1 09       	sbc	r26, r1
    18d2:	b1 09       	sbc	r27, r1
    18d4:	8b 83       	std	Y+3, r24	; 0x03
    18d6:	9c 83       	std	Y+4, r25	; 0x04
    18d8:	ad 83       	std	Y+5, r26	; 0x05
    18da:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    18dc:	8b 81       	ldd	r24, Y+3	; 0x03
    18de:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    18e0:	8b 81       	ldd	r24, Y+3	; 0x03
    18e2:	9c 81       	ldd	r25, Y+4	; 0x04
    18e4:	ad 81       	ldd	r26, Y+5	; 0x05
    18e6:	be 81       	ldd	r27, Y+6	; 0x06
    18e8:	89 2f       	mov	r24, r25
    18ea:	9a 2f       	mov	r25, r26
    18ec:	ab 2f       	mov	r26, r27
    18ee:	bb 27       	eor	r27, r27
    18f0:	8b 83       	std	Y+3, r24	; 0x03
    18f2:	9c 83       	std	Y+4, r25	; 0x04
    18f4:	ad 83       	std	Y+5, r26	; 0x05
    18f6:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    18f8:	8b 81       	ldd	r24, Y+3	; 0x03
    18fa:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    18fc:	eb e4       	ldi	r30, 0x4B	; 75
    18fe:	f0 e0       	ldi	r31, 0x00	; 0
    1900:	8a 81       	ldd	r24, Y+2	; 0x02
    1902:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1904:	ea e4       	ldi	r30, 0x4A	; 74
    1906:	f0 e0       	ldi	r31, 0x00	; 0
    1908:	89 81       	ldd	r24, Y+1	; 0x01
    190a:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    190c:	8b e0       	ldi	r24, 0x0B	; 11
    190e:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1910:	ee e4       	ldi	r30, 0x4E	; 78
    1912:	f0 e0       	ldi	r31, 0x00	; 0
    1914:	89 81       	ldd	r24, Y+1	; 0x01
    1916:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1918:	e9 e5       	ldi	r30, 0x59	; 89
    191a:	f0 e0       	ldi	r31, 0x00	; 0
    191c:	80 81       	ld	r24, Z
    191e:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1920:	89 81       	ldd	r24, Y+1	; 0x01
    1922:	80 61       	ori	r24, 0x10	; 16
    1924:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1926:	e9 e5       	ldi	r30, 0x59	; 89
    1928:	f0 e0       	ldi	r31, 0x00	; 0
    192a:	89 81       	ldd	r24, Y+1	; 0x01
    192c:	80 83       	st	Z, r24
}
    192e:	26 96       	adiw	r28, 0x06	; 6
    1930:	0f b6       	in	r0, 0x3f	; 63
    1932:	f8 94       	cli
    1934:	de bf       	out	0x3e, r29	; 62
    1936:	0f be       	out	0x3f, r0	; 63
    1938:	cd bf       	out	0x3d, r28	; 61
    193a:	cf 91       	pop	r28
    193c:	df 91       	pop	r29
    193e:	08 95       	ret

00001940 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1940:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <vPortYieldFromTick>
		asm volatile ( "reti" );
    1944:	18 95       	reti

00001946 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1946:	df 93       	push	r29
    1948:	cf 93       	push	r28
    194a:	00 d0       	rcall	.+0      	; 0x194c <xQueueGenericReset+0x6>
    194c:	00 d0       	rcall	.+0      	; 0x194e <xQueueGenericReset+0x8>
    194e:	0f 92       	push	r0
    1950:	cd b7       	in	r28, 0x3d	; 61
    1952:	de b7       	in	r29, 0x3e	; 62
    1954:	9c 83       	std	Y+4, r25	; 0x04
    1956:	8b 83       	std	Y+3, r24	; 0x03
    1958:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    195a:	8b 81       	ldd	r24, Y+3	; 0x03
    195c:	9c 81       	ldd	r25, Y+4	; 0x04
    195e:	9a 83       	std	Y+2, r25	; 0x02
    1960:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1962:	0f b6       	in	r0, 0x3f	; 63
    1964:	f8 94       	cli
    1966:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1968:	e9 81       	ldd	r30, Y+1	; 0x01
    196a:	fa 81       	ldd	r31, Y+2	; 0x02
    196c:	40 81       	ld	r20, Z
    196e:	51 81       	ldd	r21, Z+1	; 0x01
    1970:	e9 81       	ldd	r30, Y+1	; 0x01
    1972:	fa 81       	ldd	r31, Y+2	; 0x02
    1974:	83 8d       	ldd	r24, Z+27	; 0x1b
    1976:	28 2f       	mov	r18, r24
    1978:	30 e0       	ldi	r19, 0x00	; 0
    197a:	e9 81       	ldd	r30, Y+1	; 0x01
    197c:	fa 81       	ldd	r31, Y+2	; 0x02
    197e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1980:	88 2f       	mov	r24, r24
    1982:	90 e0       	ldi	r25, 0x00	; 0
    1984:	bc 01       	movw	r22, r24
    1986:	26 9f       	mul	r18, r22
    1988:	c0 01       	movw	r24, r0
    198a:	27 9f       	mul	r18, r23
    198c:	90 0d       	add	r25, r0
    198e:	36 9f       	mul	r19, r22
    1990:	90 0d       	add	r25, r0
    1992:	11 24       	eor	r1, r1
    1994:	84 0f       	add	r24, r20
    1996:	95 1f       	adc	r25, r21
    1998:	e9 81       	ldd	r30, Y+1	; 0x01
    199a:	fa 81       	ldd	r31, Y+2	; 0x02
    199c:	93 83       	std	Z+3, r25	; 0x03
    199e:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    19a0:	e9 81       	ldd	r30, Y+1	; 0x01
    19a2:	fa 81       	ldd	r31, Y+2	; 0x02
    19a4:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    19a6:	e9 81       	ldd	r30, Y+1	; 0x01
    19a8:	fa 81       	ldd	r31, Y+2	; 0x02
    19aa:	80 81       	ld	r24, Z
    19ac:	91 81       	ldd	r25, Z+1	; 0x01
    19ae:	e9 81       	ldd	r30, Y+1	; 0x01
    19b0:	fa 81       	ldd	r31, Y+2	; 0x02
    19b2:	95 83       	std	Z+5, r25	; 0x05
    19b4:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    19b6:	e9 81       	ldd	r30, Y+1	; 0x01
    19b8:	fa 81       	ldd	r31, Y+2	; 0x02
    19ba:	40 81       	ld	r20, Z
    19bc:	51 81       	ldd	r21, Z+1	; 0x01
    19be:	e9 81       	ldd	r30, Y+1	; 0x01
    19c0:	fa 81       	ldd	r31, Y+2	; 0x02
    19c2:	83 8d       	ldd	r24, Z+27	; 0x1b
    19c4:	88 2f       	mov	r24, r24
    19c6:	90 e0       	ldi	r25, 0x00	; 0
    19c8:	9c 01       	movw	r18, r24
    19ca:	21 50       	subi	r18, 0x01	; 1
    19cc:	30 40       	sbci	r19, 0x00	; 0
    19ce:	e9 81       	ldd	r30, Y+1	; 0x01
    19d0:	fa 81       	ldd	r31, Y+2	; 0x02
    19d2:	84 8d       	ldd	r24, Z+28	; 0x1c
    19d4:	88 2f       	mov	r24, r24
    19d6:	90 e0       	ldi	r25, 0x00	; 0
    19d8:	bc 01       	movw	r22, r24
    19da:	26 9f       	mul	r18, r22
    19dc:	c0 01       	movw	r24, r0
    19de:	27 9f       	mul	r18, r23
    19e0:	90 0d       	add	r25, r0
    19e2:	36 9f       	mul	r19, r22
    19e4:	90 0d       	add	r25, r0
    19e6:	11 24       	eor	r1, r1
    19e8:	84 0f       	add	r24, r20
    19ea:	95 1f       	adc	r25, r21
    19ec:	e9 81       	ldd	r30, Y+1	; 0x01
    19ee:	fa 81       	ldd	r31, Y+2	; 0x02
    19f0:	97 83       	std	Z+7, r25	; 0x07
    19f2:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    19f4:	e9 81       	ldd	r30, Y+1	; 0x01
    19f6:	fa 81       	ldd	r31, Y+2	; 0x02
    19f8:	8f ef       	ldi	r24, 0xFF	; 255
    19fa:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    19fc:	e9 81       	ldd	r30, Y+1	; 0x01
    19fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1a00:	8f ef       	ldi	r24, 0xFF	; 255
    1a02:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1a04:	8d 81       	ldd	r24, Y+5	; 0x05
    1a06:	88 23       	and	r24, r24
    1a08:	79 f4       	brne	.+30     	; 0x1a28 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1a0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1a0e:	80 85       	ldd	r24, Z+8	; 0x08
    1a10:	88 23       	and	r24, r24
    1a12:	a1 f0       	breq	.+40     	; 0x1a3c <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1a14:	89 81       	ldd	r24, Y+1	; 0x01
    1a16:	9a 81       	ldd	r25, Y+2	; 0x02
    1a18:	08 96       	adiw	r24, 0x08	; 8
    1a1a:	0e 94 10 1a 	call	0x3420	; 0x3420 <xTaskRemoveFromEventList>
    1a1e:	81 30       	cpi	r24, 0x01	; 1
    1a20:	69 f4       	brne	.+26     	; 0x1a3c <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1a22:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    1a26:	0a c0       	rjmp	.+20     	; 0x1a3c <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1a28:	89 81       	ldd	r24, Y+1	; 0x01
    1a2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a2c:	08 96       	adiw	r24, 0x08	; 8
    1a2e:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1a32:	89 81       	ldd	r24, Y+1	; 0x01
    1a34:	9a 81       	ldd	r25, Y+2	; 0x02
    1a36:	41 96       	adiw	r24, 0x11	; 17
    1a38:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1a3c:	0f 90       	pop	r0
    1a3e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1a40:	81 e0       	ldi	r24, 0x01	; 1
}
    1a42:	0f 90       	pop	r0
    1a44:	0f 90       	pop	r0
    1a46:	0f 90       	pop	r0
    1a48:	0f 90       	pop	r0
    1a4a:	0f 90       	pop	r0
    1a4c:	cf 91       	pop	r28
    1a4e:	df 91       	pop	r29
    1a50:	08 95       	ret

00001a52 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1a52:	df 93       	push	r29
    1a54:	cf 93       	push	r28
    1a56:	cd b7       	in	r28, 0x3d	; 61
    1a58:	de b7       	in	r29, 0x3e	; 62
    1a5a:	29 97       	sbiw	r28, 0x09	; 9
    1a5c:	0f b6       	in	r0, 0x3f	; 63
    1a5e:	f8 94       	cli
    1a60:	de bf       	out	0x3e, r29	; 62
    1a62:	0f be       	out	0x3f, r0	; 63
    1a64:	cd bf       	out	0x3d, r28	; 61
    1a66:	8f 83       	std	Y+7, r24	; 0x07
    1a68:	68 87       	std	Y+8, r22	; 0x08
    1a6a:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1a6c:	1a 82       	std	Y+2, r1	; 0x02
    1a6e:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1a70:	8f 81       	ldd	r24, Y+7	; 0x07
    1a72:	88 23       	and	r24, r24
    1a74:	09 f4       	brne	.+2      	; 0x1a78 <xQueueGenericCreate+0x26>
    1a76:	3f c0       	rjmp	.+126    	; 0x1af6 <xQueueGenericCreate+0xa4>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1a78:	8f e1       	ldi	r24, 0x1F	; 31
    1a7a:	90 e0       	ldi	r25, 0x00	; 0
    1a7c:	0e 94 4b 07 	call	0xe96	; 0xe96 <pvPortMalloc>
    1a80:	9e 83       	std	Y+6, r25	; 0x06
    1a82:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1a84:	8d 81       	ldd	r24, Y+5	; 0x05
    1a86:	9e 81       	ldd	r25, Y+6	; 0x06
    1a88:	00 97       	sbiw	r24, 0x00	; 0
    1a8a:	a9 f1       	breq	.+106    	; 0x1af6 <xQueueGenericCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1a8c:	8f 81       	ldd	r24, Y+7	; 0x07
    1a8e:	28 2f       	mov	r18, r24
    1a90:	30 e0       	ldi	r19, 0x00	; 0
    1a92:	88 85       	ldd	r24, Y+8	; 0x08
    1a94:	88 2f       	mov	r24, r24
    1a96:	90 e0       	ldi	r25, 0x00	; 0
    1a98:	ac 01       	movw	r20, r24
    1a9a:	24 9f       	mul	r18, r20
    1a9c:	c0 01       	movw	r24, r0
    1a9e:	25 9f       	mul	r18, r21
    1aa0:	90 0d       	add	r25, r0
    1aa2:	34 9f       	mul	r19, r20
    1aa4:	90 0d       	add	r25, r0
    1aa6:	11 24       	eor	r1, r1
    1aa8:	01 96       	adiw	r24, 0x01	; 1
    1aaa:	9c 83       	std	Y+4, r25	; 0x04
    1aac:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1aae:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab2:	0e 94 4b 07 	call	0xe96	; 0xe96 <pvPortMalloc>
    1ab6:	ed 81       	ldd	r30, Y+5	; 0x05
    1ab8:	fe 81       	ldd	r31, Y+6	; 0x06
    1aba:	91 83       	std	Z+1, r25	; 0x01
    1abc:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1abe:	ed 81       	ldd	r30, Y+5	; 0x05
    1ac0:	fe 81       	ldd	r31, Y+6	; 0x06
    1ac2:	80 81       	ld	r24, Z
    1ac4:	91 81       	ldd	r25, Z+1	; 0x01
    1ac6:	00 97       	sbiw	r24, 0x00	; 0
    1ac8:	91 f0       	breq	.+36     	; 0x1aee <xQueueGenericCreate+0x9c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1aca:	ed 81       	ldd	r30, Y+5	; 0x05
    1acc:	fe 81       	ldd	r31, Y+6	; 0x06
    1ace:	8f 81       	ldd	r24, Y+7	; 0x07
    1ad0:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1ad2:	ed 81       	ldd	r30, Y+5	; 0x05
    1ad4:	fe 81       	ldd	r31, Y+6	; 0x06
    1ad6:	88 85       	ldd	r24, Y+8	; 0x08
    1ad8:	84 8f       	std	Z+28, r24	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1ada:	8d 81       	ldd	r24, Y+5	; 0x05
    1adc:	9e 81       	ldd	r25, Y+6	; 0x06
    1ade:	61 e0       	ldi	r22, 0x01	; 1
    1ae0:	0e 94 a3 0c 	call	0x1946	; 0x1946 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1ae4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ae6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ae8:	9a 83       	std	Y+2, r25	; 0x02
    1aea:	89 83       	std	Y+1, r24	; 0x01
    1aec:	04 c0       	rjmp	.+8      	; 0x1af6 <xQueueGenericCreate+0xa4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1aee:	8d 81       	ldd	r24, Y+5	; 0x05
    1af0:	9e 81       	ldd	r25, Y+6	; 0x06
    1af2:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    1af6:	89 81       	ldd	r24, Y+1	; 0x01
    1af8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1afa:	29 96       	adiw	r28, 0x09	; 9
    1afc:	0f b6       	in	r0, 0x3f	; 63
    1afe:	f8 94       	cli
    1b00:	de bf       	out	0x3e, r29	; 62
    1b02:	0f be       	out	0x3f, r0	; 63
    1b04:	cd bf       	out	0x3d, r28	; 61
    1b06:	cf 91       	pop	r28
    1b08:	df 91       	pop	r29
    1b0a:	08 95       	ret

00001b0c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1b0c:	df 93       	push	r29
    1b0e:	cf 93       	push	r28
    1b10:	00 d0       	rcall	.+0      	; 0x1b12 <xQueueCreateMutex+0x6>
    1b12:	0f 92       	push	r0
    1b14:	cd b7       	in	r28, 0x3d	; 61
    1b16:	de b7       	in	r29, 0x3e	; 62
    1b18:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1b1a:	8f e1       	ldi	r24, 0x1F	; 31
    1b1c:	90 e0       	ldi	r25, 0x00	; 0
    1b1e:	0e 94 4b 07 	call	0xe96	; 0xe96 <pvPortMalloc>
    1b22:	9a 83       	std	Y+2, r25	; 0x02
    1b24:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    1b26:	89 81       	ldd	r24, Y+1	; 0x01
    1b28:	9a 81       	ldd	r25, Y+2	; 0x02
    1b2a:	00 97       	sbiw	r24, 0x00	; 0
    1b2c:	a9 f1       	breq	.+106    	; 0x1b98 <xQueueCreateMutex+0x8c>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1b2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b30:	fa 81       	ldd	r31, Y+2	; 0x02
    1b32:	13 82       	std	Z+3, r1	; 0x03
    1b34:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1b36:	e9 81       	ldd	r30, Y+1	; 0x01
    1b38:	fa 81       	ldd	r31, Y+2	; 0x02
    1b3a:	11 82       	std	Z+1, r1	; 0x01
    1b3c:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1b3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b40:	fa 81       	ldd	r31, Y+2	; 0x02
    1b42:	15 82       	std	Z+5, r1	; 0x05
    1b44:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1b46:	e9 81       	ldd	r30, Y+1	; 0x01
    1b48:	fa 81       	ldd	r31, Y+2	; 0x02
    1b4a:	17 82       	std	Z+7, r1	; 0x07
    1b4c:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1b4e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b50:	fa 81       	ldd	r31, Y+2	; 0x02
    1b52:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1b54:	e9 81       	ldd	r30, Y+1	; 0x01
    1b56:	fa 81       	ldd	r31, Y+2	; 0x02
    1b58:	81 e0       	ldi	r24, 0x01	; 1
    1b5a:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1b5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b60:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1b62:	e9 81       	ldd	r30, Y+1	; 0x01
    1b64:	fa 81       	ldd	r31, Y+2	; 0x02
    1b66:	8f ef       	ldi	r24, 0xFF	; 255
    1b68:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1b6a:	e9 81       	ldd	r30, Y+1	; 0x01
    1b6c:	fa 81       	ldd	r31, Y+2	; 0x02
    1b6e:	8f ef       	ldi	r24, 0xFF	; 255
    1b70:	86 8f       	std	Z+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1b72:	89 81       	ldd	r24, Y+1	; 0x01
    1b74:	9a 81       	ldd	r25, Y+2	; 0x02
    1b76:	08 96       	adiw	r24, 0x08	; 8
    1b78:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1b7c:	89 81       	ldd	r24, Y+1	; 0x01
    1b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b80:	41 96       	adiw	r24, 0x11	; 17
    1b82:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1b86:	89 81       	ldd	r24, Y+1	; 0x01
    1b88:	9a 81       	ldd	r25, Y+2	; 0x02
    1b8a:	60 e0       	ldi	r22, 0x00	; 0
    1b8c:	70 e0       	ldi	r23, 0x00	; 0
    1b8e:	40 e0       	ldi	r20, 0x00	; 0
    1b90:	50 e0       	ldi	r21, 0x00	; 0
    1b92:	20 e0       	ldi	r18, 0x00	; 0
    1b94:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    1b98:	89 81       	ldd	r24, Y+1	; 0x01
    1b9a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1b9c:	0f 90       	pop	r0
    1b9e:	0f 90       	pop	r0
    1ba0:	0f 90       	pop	r0
    1ba2:	cf 91       	pop	r28
    1ba4:	df 91       	pop	r29
    1ba6:	08 95       	ret

00001ba8 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    1ba8:	df 93       	push	r29
    1baa:	cf 93       	push	r28
    1bac:	00 d0       	rcall	.+0      	; 0x1bae <xQueueCreateCountingSemaphore+0x6>
    1bae:	00 d0       	rcall	.+0      	; 0x1bb0 <xQueueCreateCountingSemaphore+0x8>
    1bb0:	cd b7       	in	r28, 0x3d	; 61
    1bb2:	de b7       	in	r29, 0x3e	; 62
    1bb4:	8b 83       	std	Y+3, r24	; 0x03
    1bb6:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    1bb8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bba:	60 e0       	ldi	r22, 0x00	; 0
    1bbc:	42 e0       	ldi	r20, 0x02	; 2
    1bbe:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <xQueueGenericCreate>
    1bc2:	9a 83       	std	Y+2, r25	; 0x02
    1bc4:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    1bc6:	89 81       	ldd	r24, Y+1	; 0x01
    1bc8:	9a 81       	ldd	r25, Y+2	; 0x02
    1bca:	00 97       	sbiw	r24, 0x00	; 0
    1bcc:	21 f0       	breq	.+8      	; 0x1bd6 <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    1bce:	e9 81       	ldd	r30, Y+1	; 0x01
    1bd0:	fa 81       	ldd	r31, Y+2	; 0x02
    1bd2:	8c 81       	ldd	r24, Y+4	; 0x04
    1bd4:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
    1bd6:	89 81       	ldd	r24, Y+1	; 0x01
    1bd8:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1bda:	0f 90       	pop	r0
    1bdc:	0f 90       	pop	r0
    1bde:	0f 90       	pop	r0
    1be0:	0f 90       	pop	r0
    1be2:	cf 91       	pop	r28
    1be4:	df 91       	pop	r29
    1be6:	08 95       	ret

00001be8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1be8:	df 93       	push	r29
    1bea:	cf 93       	push	r28
    1bec:	cd b7       	in	r28, 0x3d	; 61
    1bee:	de b7       	in	r29, 0x3e	; 62
    1bf0:	2f 97       	sbiw	r28, 0x0f	; 15
    1bf2:	0f b6       	in	r0, 0x3f	; 63
    1bf4:	f8 94       	cli
    1bf6:	de bf       	out	0x3e, r29	; 62
    1bf8:	0f be       	out	0x3f, r0	; 63
    1bfa:	cd bf       	out	0x3d, r28	; 61
    1bfc:	99 87       	std	Y+9, r25	; 0x09
    1bfe:	88 87       	std	Y+8, r24	; 0x08
    1c00:	7b 87       	std	Y+11, r23	; 0x0b
    1c02:	6a 87       	std	Y+10, r22	; 0x0a
    1c04:	5d 87       	std	Y+13, r21	; 0x0d
    1c06:	4c 87       	std	Y+12, r20	; 0x0c
    1c08:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1c0a:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1c0c:	88 85       	ldd	r24, Y+8	; 0x08
    1c0e:	99 85       	ldd	r25, Y+9	; 0x09
    1c10:	9a 83       	std	Y+2, r25	; 0x02
    1c12:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1c14:	0f b6       	in	r0, 0x3f	; 63
    1c16:	f8 94       	cli
    1c18:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1c1a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c1c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c1e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c20:	e9 81       	ldd	r30, Y+1	; 0x01
    1c22:	fa 81       	ldd	r31, Y+2	; 0x02
    1c24:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c26:	98 17       	cp	r25, r24
    1c28:	18 f0       	brcs	.+6      	; 0x1c30 <xQueueGenericSend+0x48>
    1c2a:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c2c:	82 30       	cpi	r24, 0x02	; 2
    1c2e:	11 f5       	brne	.+68     	; 0x1c74 <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1c30:	89 81       	ldd	r24, Y+1	; 0x01
    1c32:	9a 81       	ldd	r25, Y+2	; 0x02
    1c34:	2a 85       	ldd	r18, Y+10	; 0x0a
    1c36:	3b 85       	ldd	r19, Y+11	; 0x0b
    1c38:	b9 01       	movw	r22, r18
    1c3a:	4e 85       	ldd	r20, Y+14	; 0x0e
    1c3c:	0e 94 e6 10 	call	0x21cc	; 0x21cc <prvCopyDataToQueue>
    1c40:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c42:	e9 81       	ldd	r30, Y+1	; 0x01
    1c44:	fa 81       	ldd	r31, Y+2	; 0x02
    1c46:	81 89       	ldd	r24, Z+17	; 0x11
    1c48:	88 23       	and	r24, r24
    1c4a:	51 f0       	breq	.+20     	; 0x1c60 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1c4c:	89 81       	ldd	r24, Y+1	; 0x01
    1c4e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c50:	41 96       	adiw	r24, 0x11	; 17
    1c52:	0e 94 10 1a 	call	0x3420	; 0x3420 <xTaskRemoveFromEventList>
    1c56:	81 30       	cpi	r24, 0x01	; 1
    1c58:	41 f4       	brne	.+16     	; 0x1c6a <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1c5a:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    1c5e:	05 c0       	rjmp	.+10     	; 0x1c6a <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1c60:	8b 81       	ldd	r24, Y+3	; 0x03
    1c62:	88 23       	and	r24, r24
    1c64:	11 f0       	breq	.+4      	; 0x1c6a <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1c66:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1c6a:	0f 90       	pop	r0
    1c6c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	8f 87       	std	Y+15, r24	; 0x0f
    1c72:	5c c0       	rjmp	.+184    	; 0x1d2c <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1c74:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c76:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c78:	00 97       	sbiw	r24, 0x00	; 0
    1c7a:	21 f4       	brne	.+8      	; 0x1c84 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1c7c:	0f 90       	pop	r0
    1c7e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1c80:	1f 86       	std	Y+15, r1	; 0x0f
    1c82:	54 c0       	rjmp	.+168    	; 0x1d2c <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1c84:	8c 81       	ldd	r24, Y+4	; 0x04
    1c86:	88 23       	and	r24, r24
    1c88:	31 f4       	brne	.+12     	; 0x1c96 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1c8a:	ce 01       	movw	r24, r28
    1c8c:	05 96       	adiw	r24, 0x05	; 5
    1c8e:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1c92:	81 e0       	ldi	r24, 0x01	; 1
    1c94:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1c96:	0f 90       	pop	r0
    1c98:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c9a:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c9e:	0f b6       	in	r0, 0x3f	; 63
    1ca0:	f8 94       	cli
    1ca2:	0f 92       	push	r0
    1ca4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ca6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ca8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1caa:	8f 3f       	cpi	r24, 0xFF	; 255
    1cac:	19 f4       	brne	.+6      	; 0x1cb4 <xQueueGenericSend+0xcc>
    1cae:	e9 81       	ldd	r30, Y+1	; 0x01
    1cb0:	fa 81       	ldd	r31, Y+2	; 0x02
    1cb2:	15 8e       	std	Z+29, r1	; 0x1d
    1cb4:	e9 81       	ldd	r30, Y+1	; 0x01
    1cb6:	fa 81       	ldd	r31, Y+2	; 0x02
    1cb8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cba:	8f 3f       	cpi	r24, 0xFF	; 255
    1cbc:	19 f4       	brne	.+6      	; 0x1cc4 <xQueueGenericSend+0xdc>
    1cbe:	e9 81       	ldd	r30, Y+1	; 0x01
    1cc0:	fa 81       	ldd	r31, Y+2	; 0x02
    1cc2:	16 8e       	std	Z+30, r1	; 0x1e
    1cc4:	0f 90       	pop	r0
    1cc6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1cc8:	ce 01       	movw	r24, r28
    1cca:	05 96       	adiw	r24, 0x05	; 5
    1ccc:	9e 01       	movw	r18, r28
    1cce:	24 5f       	subi	r18, 0xF4	; 244
    1cd0:	3f 4f       	sbci	r19, 0xFF	; 255
    1cd2:	b9 01       	movw	r22, r18
    1cd4:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <xTaskCheckForTimeOut>
    1cd8:	88 23       	and	r24, r24
    1cda:	09 f5       	brne	.+66     	; 0x1d1e <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1cdc:	89 81       	ldd	r24, Y+1	; 0x01
    1cde:	9a 81       	ldd	r25, Y+2	; 0x02
    1ce0:	0e 94 6f 12 	call	0x24de	; 0x24de <prvIsQueueFull>
    1ce4:	88 23       	and	r24, r24
    1ce6:	a1 f0       	breq	.+40     	; 0x1d10 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1ce8:	89 81       	ldd	r24, Y+1	; 0x01
    1cea:	9a 81       	ldd	r25, Y+2	; 0x02
    1cec:	08 96       	adiw	r24, 0x08	; 8
    1cee:	2c 85       	ldd	r18, Y+12	; 0x0c
    1cf0:	3d 85       	ldd	r19, Y+13	; 0x0d
    1cf2:	b9 01       	movw	r22, r18
    1cf4:	0e 94 98 19 	call	0x3330	; 0x3330 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1cf8:	89 81       	ldd	r24, Y+1	; 0x01
    1cfa:	9a 81       	ldd	r25, Y+2	; 0x02
    1cfc:	0e 94 e6 11 	call	0x23cc	; 0x23cc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1d00:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>
    1d04:	88 23       	and	r24, r24
    1d06:	09 f0       	breq	.+2      	; 0x1d0a <xQueueGenericSend+0x122>
    1d08:	85 cf       	rjmp	.-246    	; 0x1c14 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1d0a:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    1d0e:	82 cf       	rjmp	.-252    	; 0x1c14 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1d10:	89 81       	ldd	r24, Y+1	; 0x01
    1d12:	9a 81       	ldd	r25, Y+2	; 0x02
    1d14:	0e 94 e6 11 	call	0x23cc	; 0x23cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d18:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>
    1d1c:	7b cf       	rjmp	.-266    	; 0x1c14 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1d1e:	89 81       	ldd	r24, Y+1	; 0x01
    1d20:	9a 81       	ldd	r25, Y+2	; 0x02
    1d22:	0e 94 e6 11 	call	0x23cc	; 0x23cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d26:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1d2a:	1f 86       	std	Y+15, r1	; 0x0f
    1d2c:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    1d2e:	2f 96       	adiw	r28, 0x0f	; 15
    1d30:	0f b6       	in	r0, 0x3f	; 63
    1d32:	f8 94       	cli
    1d34:	de bf       	out	0x3e, r29	; 62
    1d36:	0f be       	out	0x3f, r0	; 63
    1d38:	cd bf       	out	0x3d, r28	; 61
    1d3a:	cf 91       	pop	r28
    1d3c:	df 91       	pop	r29
    1d3e:	08 95       	ret

00001d40 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1d40:	df 93       	push	r29
    1d42:	cf 93       	push	r28
    1d44:	cd b7       	in	r28, 0x3d	; 61
    1d46:	de b7       	in	r29, 0x3e	; 62
    1d48:	2b 97       	sbiw	r28, 0x0b	; 11
    1d4a:	0f b6       	in	r0, 0x3f	; 63
    1d4c:	f8 94       	cli
    1d4e:	de bf       	out	0x3e, r29	; 62
    1d50:	0f be       	out	0x3f, r0	; 63
    1d52:	cd bf       	out	0x3d, r28	; 61
    1d54:	9e 83       	std	Y+6, r25	; 0x06
    1d56:	8d 83       	std	Y+5, r24	; 0x05
    1d58:	78 87       	std	Y+8, r23	; 0x08
    1d5a:	6f 83       	std	Y+7, r22	; 0x07
    1d5c:	5a 87       	std	Y+10, r21	; 0x0a
    1d5e:	49 87       	std	Y+9, r20	; 0x09
    1d60:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1d62:	8d 81       	ldd	r24, Y+5	; 0x05
    1d64:	9e 81       	ldd	r25, Y+6	; 0x06
    1d66:	9a 83       	std	Y+2, r25	; 0x02
    1d68:	89 83       	std	Y+1, r24	; 0x01
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1d6a:	1b 82       	std	Y+3, r1	; 0x03
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1d6c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d6e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d70:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d72:	e9 81       	ldd	r30, Y+1	; 0x01
    1d74:	fa 81       	ldd	r31, Y+2	; 0x02
    1d76:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d78:	98 17       	cp	r25, r24
    1d7a:	18 f0       	brcs	.+6      	; 0x1d82 <xQueueGenericSendFromISR+0x42>
    1d7c:	8b 85       	ldd	r24, Y+11	; 0x0b
    1d7e:	82 30       	cpi	r24, 0x02	; 2
    1d80:	b1 f5       	brne	.+108    	; 0x1dee <xQueueGenericSendFromISR+0xae>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1d82:	89 81       	ldd	r24, Y+1	; 0x01
    1d84:	9a 81       	ldd	r25, Y+2	; 0x02
    1d86:	2f 81       	ldd	r18, Y+7	; 0x07
    1d88:	38 85       	ldd	r19, Y+8	; 0x08
    1d8a:	b9 01       	movw	r22, r18
    1d8c:	4b 85       	ldd	r20, Y+11	; 0x0b
    1d8e:	0e 94 e6 10 	call	0x21cc	; 0x21cc <prvCopyDataToQueue>
    1d92:	88 23       	and	r24, r24
    1d94:	41 f0       	breq	.+16     	; 0x1da6 <xQueueGenericSendFromISR+0x66>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1d96:	89 85       	ldd	r24, Y+9	; 0x09
    1d98:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d9a:	00 97       	sbiw	r24, 0x00	; 0
    1d9c:	21 f0       	breq	.+8      	; 0x1da6 <xQueueGenericSendFromISR+0x66>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1d9e:	e9 85       	ldd	r30, Y+9	; 0x09
    1da0:	fa 85       	ldd	r31, Y+10	; 0x0a
    1da2:	81 e0       	ldi	r24, 0x01	; 1
    1da4:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1da6:	e9 81       	ldd	r30, Y+1	; 0x01
    1da8:	fa 81       	ldd	r31, Y+2	; 0x02
    1daa:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dac:	8f 3f       	cpi	r24, 0xFF	; 255
    1dae:	a9 f4       	brne	.+42     	; 0x1dda <xQueueGenericSendFromISR+0x9a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1db0:	e9 81       	ldd	r30, Y+1	; 0x01
    1db2:	fa 81       	ldd	r31, Y+2	; 0x02
    1db4:	81 89       	ldd	r24, Z+17	; 0x11
    1db6:	88 23       	and	r24, r24
    1db8:	b9 f0       	breq	.+46     	; 0x1de8 <xQueueGenericSendFromISR+0xa8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1dba:	89 81       	ldd	r24, Y+1	; 0x01
    1dbc:	9a 81       	ldd	r25, Y+2	; 0x02
    1dbe:	41 96       	adiw	r24, 0x11	; 17
    1dc0:	0e 94 10 1a 	call	0x3420	; 0x3420 <xTaskRemoveFromEventList>
    1dc4:	88 23       	and	r24, r24
    1dc6:	81 f0       	breq	.+32     	; 0x1de8 <xQueueGenericSendFromISR+0xa8>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1dc8:	89 85       	ldd	r24, Y+9	; 0x09
    1dca:	9a 85       	ldd	r25, Y+10	; 0x0a
    1dcc:	00 97       	sbiw	r24, 0x00	; 0
    1dce:	61 f0       	breq	.+24     	; 0x1de8 <xQueueGenericSendFromISR+0xa8>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1dd0:	e9 85       	ldd	r30, Y+9	; 0x09
    1dd2:	fa 85       	ldd	r31, Y+10	; 0x0a
    1dd4:	81 e0       	ldi	r24, 0x01	; 1
    1dd6:	80 83       	st	Z, r24
    1dd8:	07 c0       	rjmp	.+14     	; 0x1de8 <xQueueGenericSendFromISR+0xa8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1dda:	e9 81       	ldd	r30, Y+1	; 0x01
    1ddc:	fa 81       	ldd	r31, Y+2	; 0x02
    1dde:	86 8d       	ldd	r24, Z+30	; 0x1e
    1de0:	8f 5f       	subi	r24, 0xFF	; 255
    1de2:	e9 81       	ldd	r30, Y+1	; 0x01
    1de4:	fa 81       	ldd	r31, Y+2	; 0x02
    1de6:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1de8:	81 e0       	ldi	r24, 0x01	; 1
    1dea:	8c 83       	std	Y+4, r24	; 0x04
    1dec:	01 c0       	rjmp	.+2      	; 0x1df0 <xQueueGenericSendFromISR+0xb0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1dee:	1c 82       	std	Y+4, r1	; 0x04
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1df0:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1df2:	2b 96       	adiw	r28, 0x0b	; 11
    1df4:	0f b6       	in	r0, 0x3f	; 63
    1df6:	f8 94       	cli
    1df8:	de bf       	out	0x3e, r29	; 62
    1dfa:	0f be       	out	0x3f, r0	; 63
    1dfc:	cd bf       	out	0x3d, r28	; 61
    1dfe:	cf 91       	pop	r28
    1e00:	df 91       	pop	r29
    1e02:	08 95       	ret

00001e04 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1e04:	df 93       	push	r29
    1e06:	cf 93       	push	r28
    1e08:	cd b7       	in	r28, 0x3d	; 61
    1e0a:	de b7       	in	r29, 0x3e	; 62
    1e0c:	60 97       	sbiw	r28, 0x10	; 16
    1e0e:	0f b6       	in	r0, 0x3f	; 63
    1e10:	f8 94       	cli
    1e12:	de bf       	out	0x3e, r29	; 62
    1e14:	0f be       	out	0x3f, r0	; 63
    1e16:	cd bf       	out	0x3d, r28	; 61
    1e18:	9a 87       	std	Y+10, r25	; 0x0a
    1e1a:	89 87       	std	Y+9, r24	; 0x09
    1e1c:	7c 87       	std	Y+12, r23	; 0x0c
    1e1e:	6b 87       	std	Y+11, r22	; 0x0b
    1e20:	5e 87       	std	Y+14, r21	; 0x0e
    1e22:	4d 87       	std	Y+13, r20	; 0x0d
    1e24:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    1e26:	1d 82       	std	Y+5, r1	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1e28:	89 85       	ldd	r24, Y+9	; 0x09
    1e2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e2c:	9a 83       	std	Y+2, r25	; 0x02
    1e2e:	89 83       	std	Y+1, r24	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1e30:	0f b6       	in	r0, 0x3f	; 63
    1e32:	f8 94       	cli
    1e34:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e36:	e9 81       	ldd	r30, Y+1	; 0x01
    1e38:	fa 81       	ldd	r31, Y+2	; 0x02
    1e3a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e3c:	88 23       	and	r24, r24
    1e3e:	09 f4       	brne	.+2      	; 0x1e42 <xQueueGenericReceive+0x3e>
    1e40:	4b c0       	rjmp	.+150    	; 0x1ed8 <xQueueGenericReceive+0xd4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1e42:	e9 81       	ldd	r30, Y+1	; 0x01
    1e44:	fa 81       	ldd	r31, Y+2	; 0x02
    1e46:	86 81       	ldd	r24, Z+6	; 0x06
    1e48:	97 81       	ldd	r25, Z+7	; 0x07
    1e4a:	9c 83       	std	Y+4, r25	; 0x04
    1e4c:	8b 83       	std	Y+3, r24	; 0x03

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1e4e:	89 81       	ldd	r24, Y+1	; 0x01
    1e50:	9a 81       	ldd	r25, Y+2	; 0x02
    1e52:	2b 85       	ldd	r18, Y+11	; 0x0b
    1e54:	3c 85       	ldd	r19, Y+12	; 0x0c
    1e56:	b9 01       	movw	r22, r18
    1e58:	0e 94 9f 11 	call	0x233e	; 0x233e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1e5c:	8f 85       	ldd	r24, Y+15	; 0x0f
    1e5e:	88 23       	and	r24, r24
    1e60:	11 f5       	brne	.+68     	; 0x1ea6 <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1e62:	e9 81       	ldd	r30, Y+1	; 0x01
    1e64:	fa 81       	ldd	r31, Y+2	; 0x02
    1e66:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e68:	81 50       	subi	r24, 0x01	; 1
    1e6a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e6c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e6e:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1e70:	e9 81       	ldd	r30, Y+1	; 0x01
    1e72:	fa 81       	ldd	r31, Y+2	; 0x02
    1e74:	80 81       	ld	r24, Z
    1e76:	91 81       	ldd	r25, Z+1	; 0x01
    1e78:	00 97       	sbiw	r24, 0x00	; 0
    1e7a:	31 f4       	brne	.+12     	; 0x1e88 <xQueueGenericReceive+0x84>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1e7c:	0e 94 70 1e 	call	0x3ce0	; 0x3ce0 <pvTaskIncrementMutexHeldCount>
    1e80:	e9 81       	ldd	r30, Y+1	; 0x01
    1e82:	fa 81       	ldd	r31, Y+2	; 0x02
    1e84:	93 83       	std	Z+3, r25	; 0x03
    1e86:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e88:	e9 81       	ldd	r30, Y+1	; 0x01
    1e8a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e8c:	80 85       	ldd	r24, Z+8	; 0x08
    1e8e:	88 23       	and	r24, r24
    1e90:	f1 f0       	breq	.+60     	; 0x1ece <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1e92:	89 81       	ldd	r24, Y+1	; 0x01
    1e94:	9a 81       	ldd	r25, Y+2	; 0x02
    1e96:	08 96       	adiw	r24, 0x08	; 8
    1e98:	0e 94 10 1a 	call	0x3420	; 0x3420 <xTaskRemoveFromEventList>
    1e9c:	81 30       	cpi	r24, 0x01	; 1
    1e9e:	b9 f4       	brne	.+46     	; 0x1ece <xQueueGenericReceive+0xca>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1ea0:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    1ea4:	14 c0       	rjmp	.+40     	; 0x1ece <xQueueGenericReceive+0xca>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1ea6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ea8:	fa 81       	ldd	r31, Y+2	; 0x02
    1eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    1eac:	9c 81       	ldd	r25, Y+4	; 0x04
    1eae:	97 83       	std	Z+7, r25	; 0x07
    1eb0:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1eb2:	e9 81       	ldd	r30, Y+1	; 0x01
    1eb4:	fa 81       	ldd	r31, Y+2	; 0x02
    1eb6:	81 89       	ldd	r24, Z+17	; 0x11
    1eb8:	88 23       	and	r24, r24
    1eba:	49 f0       	breq	.+18     	; 0x1ece <xQueueGenericReceive+0xca>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ebc:	89 81       	ldd	r24, Y+1	; 0x01
    1ebe:	9a 81       	ldd	r25, Y+2	; 0x02
    1ec0:	41 96       	adiw	r24, 0x11	; 17
    1ec2:	0e 94 10 1a 	call	0x3420	; 0x3420 <xTaskRemoveFromEventList>
    1ec6:	88 23       	and	r24, r24
    1ec8:	11 f0       	breq	.+4      	; 0x1ece <xQueueGenericReceive+0xca>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1eca:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1ece:	0f 90       	pop	r0
    1ed0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1ed2:	81 e0       	ldi	r24, 0x01	; 1
    1ed4:	88 8b       	std	Y+16, r24	; 0x10
    1ed6:	6d c0       	rjmp	.+218    	; 0x1fb2 <xQueueGenericReceive+0x1ae>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1ed8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1eda:	9e 85       	ldd	r25, Y+14	; 0x0e
    1edc:	00 97       	sbiw	r24, 0x00	; 0
    1ede:	21 f4       	brne	.+8      	; 0x1ee8 <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ee0:	0f 90       	pop	r0
    1ee2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1ee4:	18 8a       	std	Y+16, r1	; 0x10
    1ee6:	65 c0       	rjmp	.+202    	; 0x1fb2 <xQueueGenericReceive+0x1ae>
				}
				else if( xEntryTimeSet == pdFALSE )
    1ee8:	8d 81       	ldd	r24, Y+5	; 0x05
    1eea:	88 23       	and	r24, r24
    1eec:	31 f4       	brne	.+12     	; 0x1efa <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1eee:	ce 01       	movw	r24, r28
    1ef0:	06 96       	adiw	r24, 0x06	; 6
    1ef2:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1ef6:	81 e0       	ldi	r24, 0x01	; 1
    1ef8:	8d 83       	std	Y+5, r24	; 0x05
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1efa:	0f 90       	pop	r0
    1efc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1efe:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f02:	0f b6       	in	r0, 0x3f	; 63
    1f04:	f8 94       	cli
    1f06:	0f 92       	push	r0
    1f08:	e9 81       	ldd	r30, Y+1	; 0x01
    1f0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f0c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f0e:	8f 3f       	cpi	r24, 0xFF	; 255
    1f10:	19 f4       	brne	.+6      	; 0x1f18 <xQueueGenericReceive+0x114>
    1f12:	e9 81       	ldd	r30, Y+1	; 0x01
    1f14:	fa 81       	ldd	r31, Y+2	; 0x02
    1f16:	15 8e       	std	Z+29, r1	; 0x1d
    1f18:	e9 81       	ldd	r30, Y+1	; 0x01
    1f1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f1c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f1e:	8f 3f       	cpi	r24, 0xFF	; 255
    1f20:	19 f4       	brne	.+6      	; 0x1f28 <xQueueGenericReceive+0x124>
    1f22:	e9 81       	ldd	r30, Y+1	; 0x01
    1f24:	fa 81       	ldd	r31, Y+2	; 0x02
    1f26:	16 8e       	std	Z+30, r1	; 0x1e
    1f28:	0f 90       	pop	r0
    1f2a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f2c:	ce 01       	movw	r24, r28
    1f2e:	06 96       	adiw	r24, 0x06	; 6
    1f30:	9e 01       	movw	r18, r28
    1f32:	23 5f       	subi	r18, 0xF3	; 243
    1f34:	3f 4f       	sbci	r19, 0xFF	; 255
    1f36:	b9 01       	movw	r22, r18
    1f38:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <xTaskCheckForTimeOut>
    1f3c:	88 23       	and	r24, r24
    1f3e:	91 f5       	brne	.+100    	; 0x1fa4 <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1f40:	89 81       	ldd	r24, Y+1	; 0x01
    1f42:	9a 81       	ldd	r25, Y+2	; 0x02
    1f44:	0e 94 3a 12 	call	0x2474	; 0x2474 <prvIsQueueEmpty>
    1f48:	88 23       	and	r24, r24
    1f4a:	29 f1       	breq	.+74     	; 0x1f96 <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1f4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f50:	80 81       	ld	r24, Z
    1f52:	91 81       	ldd	r25, Z+1	; 0x01
    1f54:	00 97       	sbiw	r24, 0x00	; 0
    1f56:	59 f4       	brne	.+22     	; 0x1f6e <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
    1f58:	0f b6       	in	r0, 0x3f	; 63
    1f5a:	f8 94       	cli
    1f5c:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1f5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1f60:	fa 81       	ldd	r31, Y+2	; 0x02
    1f62:	82 81       	ldd	r24, Z+2	; 0x02
    1f64:	93 81       	ldd	r25, Z+3	; 0x03
    1f66:	0e 94 4c 1d 	call	0x3a98	; 0x3a98 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1f6a:	0f 90       	pop	r0
    1f6c:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f6e:	89 81       	ldd	r24, Y+1	; 0x01
    1f70:	9a 81       	ldd	r25, Y+2	; 0x02
    1f72:	41 96       	adiw	r24, 0x11	; 17
    1f74:	2d 85       	ldd	r18, Y+13	; 0x0d
    1f76:	3e 85       	ldd	r19, Y+14	; 0x0e
    1f78:	b9 01       	movw	r22, r18
    1f7a:	0e 94 98 19 	call	0x3330	; 0x3330 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1f7e:	89 81       	ldd	r24, Y+1	; 0x01
    1f80:	9a 81       	ldd	r25, Y+2	; 0x02
    1f82:	0e 94 e6 11 	call	0x23cc	; 0x23cc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1f86:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>
    1f8a:	88 23       	and	r24, r24
    1f8c:	09 f0       	breq	.+2      	; 0x1f90 <xQueueGenericReceive+0x18c>
    1f8e:	50 cf       	rjmp	.-352    	; 0x1e30 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    1f90:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    1f94:	4d cf       	rjmp	.-358    	; 0x1e30 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1f96:	89 81       	ldd	r24, Y+1	; 0x01
    1f98:	9a 81       	ldd	r25, Y+2	; 0x02
    1f9a:	0e 94 e6 11 	call	0x23cc	; 0x23cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1f9e:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>
    1fa2:	46 cf       	rjmp	.-372    	; 0x1e30 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1fa4:	89 81       	ldd	r24, Y+1	; 0x01
    1fa6:	9a 81       	ldd	r25, Y+2	; 0x02
    1fa8:	0e 94 e6 11 	call	0x23cc	; 0x23cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1fac:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1fb0:	18 8a       	std	Y+16, r1	; 0x10
    1fb2:	88 89       	ldd	r24, Y+16	; 0x10
		}
	}
}
    1fb4:	60 96       	adiw	r28, 0x10	; 16
    1fb6:	0f b6       	in	r0, 0x3f	; 63
    1fb8:	f8 94       	cli
    1fba:	de bf       	out	0x3e, r29	; 62
    1fbc:	0f be       	out	0x3f, r0	; 63
    1fbe:	cd bf       	out	0x3d, r28	; 61
    1fc0:	cf 91       	pop	r28
    1fc2:	df 91       	pop	r29
    1fc4:	08 95       	ret

00001fc6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1fc6:	df 93       	push	r29
    1fc8:	cf 93       	push	r28
    1fca:	cd b7       	in	r28, 0x3d	; 61
    1fcc:	de b7       	in	r29, 0x3e	; 62
    1fce:	2a 97       	sbiw	r28, 0x0a	; 10
    1fd0:	0f b6       	in	r0, 0x3f	; 63
    1fd2:	f8 94       	cli
    1fd4:	de bf       	out	0x3e, r29	; 62
    1fd6:	0f be       	out	0x3f, r0	; 63
    1fd8:	cd bf       	out	0x3d, r28	; 61
    1fda:	9e 83       	std	Y+6, r25	; 0x06
    1fdc:	8d 83       	std	Y+5, r24	; 0x05
    1fde:	78 87       	std	Y+8, r23	; 0x08
    1fe0:	6f 83       	std	Y+7, r22	; 0x07
    1fe2:	5a 87       	std	Y+10, r21	; 0x0a
    1fe4:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1fe6:	8d 81       	ldd	r24, Y+5	; 0x05
    1fe8:	9e 81       	ldd	r25, Y+6	; 0x06
    1fea:	9a 83       	std	Y+2, r25	; 0x02
    1fec:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1fee:	1b 82       	std	Y+3, r1	; 0x03
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ff0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ff2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ff4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ff6:	88 23       	and	r24, r24
    1ff8:	91 f1       	breq	.+100    	; 0x205e <xQueueReceiveFromISR+0x98>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1ffa:	89 81       	ldd	r24, Y+1	; 0x01
    1ffc:	9a 81       	ldd	r25, Y+2	; 0x02
    1ffe:	2f 81       	ldd	r18, Y+7	; 0x07
    2000:	38 85       	ldd	r19, Y+8	; 0x08
    2002:	b9 01       	movw	r22, r18
    2004:	0e 94 9f 11 	call	0x233e	; 0x233e <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2008:	e9 81       	ldd	r30, Y+1	; 0x01
    200a:	fa 81       	ldd	r31, Y+2	; 0x02
    200c:	82 8d       	ldd	r24, Z+26	; 0x1a
    200e:	81 50       	subi	r24, 0x01	; 1
    2010:	e9 81       	ldd	r30, Y+1	; 0x01
    2012:	fa 81       	ldd	r31, Y+2	; 0x02
    2014:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2016:	e9 81       	ldd	r30, Y+1	; 0x01
    2018:	fa 81       	ldd	r31, Y+2	; 0x02
    201a:	85 8d       	ldd	r24, Z+29	; 0x1d
    201c:	8f 3f       	cpi	r24, 0xFF	; 255
    201e:	a9 f4       	brne	.+42     	; 0x204a <xQueueReceiveFromISR+0x84>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2020:	e9 81       	ldd	r30, Y+1	; 0x01
    2022:	fa 81       	ldd	r31, Y+2	; 0x02
    2024:	80 85       	ldd	r24, Z+8	; 0x08
    2026:	88 23       	and	r24, r24
    2028:	b9 f0       	breq	.+46     	; 0x2058 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    202a:	89 81       	ldd	r24, Y+1	; 0x01
    202c:	9a 81       	ldd	r25, Y+2	; 0x02
    202e:	08 96       	adiw	r24, 0x08	; 8
    2030:	0e 94 10 1a 	call	0x3420	; 0x3420 <xTaskRemoveFromEventList>
    2034:	88 23       	and	r24, r24
    2036:	81 f0       	breq	.+32     	; 0x2058 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2038:	89 85       	ldd	r24, Y+9	; 0x09
    203a:	9a 85       	ldd	r25, Y+10	; 0x0a
    203c:	00 97       	sbiw	r24, 0x00	; 0
    203e:	61 f0       	breq	.+24     	; 0x2058 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2040:	e9 85       	ldd	r30, Y+9	; 0x09
    2042:	fa 85       	ldd	r31, Y+10	; 0x0a
    2044:	81 e0       	ldi	r24, 0x01	; 1
    2046:	80 83       	st	Z, r24
    2048:	07 c0       	rjmp	.+14     	; 0x2058 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    204a:	e9 81       	ldd	r30, Y+1	; 0x01
    204c:	fa 81       	ldd	r31, Y+2	; 0x02
    204e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2050:	8f 5f       	subi	r24, 0xFF	; 255
    2052:	e9 81       	ldd	r30, Y+1	; 0x01
    2054:	fa 81       	ldd	r31, Y+2	; 0x02
    2056:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2058:	81 e0       	ldi	r24, 0x01	; 1
    205a:	8c 83       	std	Y+4, r24	; 0x04
    205c:	01 c0       	rjmp	.+2      	; 0x2060 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    205e:	1c 82       	std	Y+4, r1	; 0x04
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2060:	8c 81       	ldd	r24, Y+4	; 0x04
}
    2062:	2a 96       	adiw	r28, 0x0a	; 10
    2064:	0f b6       	in	r0, 0x3f	; 63
    2066:	f8 94       	cli
    2068:	de bf       	out	0x3e, r29	; 62
    206a:	0f be       	out	0x3f, r0	; 63
    206c:	cd bf       	out	0x3d, r28	; 61
    206e:	cf 91       	pop	r28
    2070:	df 91       	pop	r29
    2072:	08 95       	ret

00002074 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2074:	df 93       	push	r29
    2076:	cf 93       	push	r28
    2078:	cd b7       	in	r28, 0x3d	; 61
    207a:	de b7       	in	r29, 0x3e	; 62
    207c:	2a 97       	sbiw	r28, 0x0a	; 10
    207e:	0f b6       	in	r0, 0x3f	; 63
    2080:	f8 94       	cli
    2082:	de bf       	out	0x3e, r29	; 62
    2084:	0f be       	out	0x3f, r0	; 63
    2086:	cd bf       	out	0x3d, r28	; 61
    2088:	98 87       	std	Y+8, r25	; 0x08
    208a:	8f 83       	std	Y+7, r24	; 0x07
    208c:	7a 87       	std	Y+10, r23	; 0x0a
    208e:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2090:	8f 81       	ldd	r24, Y+7	; 0x07
    2092:	98 85       	ldd	r25, Y+8	; 0x08
    2094:	9a 83       	std	Y+2, r25	; 0x02
    2096:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2098:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    209a:	e9 81       	ldd	r30, Y+1	; 0x01
    209c:	fa 81       	ldd	r31, Y+2	; 0x02
    209e:	82 8d       	ldd	r24, Z+26	; 0x1a
    20a0:	88 23       	and	r24, r24
    20a2:	b1 f0       	breq	.+44     	; 0x20d0 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    20a4:	e9 81       	ldd	r30, Y+1	; 0x01
    20a6:	fa 81       	ldd	r31, Y+2	; 0x02
    20a8:	86 81       	ldd	r24, Z+6	; 0x06
    20aa:	97 81       	ldd	r25, Z+7	; 0x07
    20ac:	9c 83       	std	Y+4, r25	; 0x04
    20ae:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    20b0:	89 81       	ldd	r24, Y+1	; 0x01
    20b2:	9a 81       	ldd	r25, Y+2	; 0x02
    20b4:	29 85       	ldd	r18, Y+9	; 0x09
    20b6:	3a 85       	ldd	r19, Y+10	; 0x0a
    20b8:	b9 01       	movw	r22, r18
    20ba:	0e 94 9f 11 	call	0x233e	; 0x233e <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    20be:	e9 81       	ldd	r30, Y+1	; 0x01
    20c0:	fa 81       	ldd	r31, Y+2	; 0x02
    20c2:	8b 81       	ldd	r24, Y+3	; 0x03
    20c4:	9c 81       	ldd	r25, Y+4	; 0x04
    20c6:	97 83       	std	Z+7, r25	; 0x07
    20c8:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    20ca:	81 e0       	ldi	r24, 0x01	; 1
    20cc:	8e 83       	std	Y+6, r24	; 0x06
    20ce:	01 c0       	rjmp	.+2      	; 0x20d2 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    20d0:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    20d2:	8e 81       	ldd	r24, Y+6	; 0x06
}
    20d4:	2a 96       	adiw	r28, 0x0a	; 10
    20d6:	0f b6       	in	r0, 0x3f	; 63
    20d8:	f8 94       	cli
    20da:	de bf       	out	0x3e, r29	; 62
    20dc:	0f be       	out	0x3f, r0	; 63
    20de:	cd bf       	out	0x3d, r28	; 61
    20e0:	cf 91       	pop	r28
    20e2:	df 91       	pop	r29
    20e4:	08 95       	ret

000020e6 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    20e6:	df 93       	push	r29
    20e8:	cf 93       	push	r28
    20ea:	00 d0       	rcall	.+0      	; 0x20ec <uxQueueMessagesWaiting+0x6>
    20ec:	0f 92       	push	r0
    20ee:	cd b7       	in	r28, 0x3d	; 61
    20f0:	de b7       	in	r29, 0x3e	; 62
    20f2:	9b 83       	std	Y+3, r25	; 0x03
    20f4:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    20f6:	0f b6       	in	r0, 0x3f	; 63
    20f8:	f8 94       	cli
    20fa:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    20fc:	ea 81       	ldd	r30, Y+2	; 0x02
    20fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2100:	82 8d       	ldd	r24, Z+26	; 0x1a
    2102:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2104:	0f 90       	pop	r0
    2106:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2108:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    210a:	0f 90       	pop	r0
    210c:	0f 90       	pop	r0
    210e:	0f 90       	pop	r0
    2110:	cf 91       	pop	r28
    2112:	df 91       	pop	r29
    2114:	08 95       	ret

00002116 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2116:	df 93       	push	r29
    2118:	cf 93       	push	r28
    211a:	00 d0       	rcall	.+0      	; 0x211c <uxQueueSpacesAvailable+0x6>
    211c:	00 d0       	rcall	.+0      	; 0x211e <uxQueueSpacesAvailable+0x8>
    211e:	0f 92       	push	r0
    2120:	cd b7       	in	r28, 0x3d	; 61
    2122:	de b7       	in	r29, 0x3e	; 62
    2124:	9d 83       	std	Y+5, r25	; 0x05
    2126:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    2128:	8c 81       	ldd	r24, Y+4	; 0x04
    212a:	9d 81       	ldd	r25, Y+5	; 0x05
    212c:	9a 83       	std	Y+2, r25	; 0x02
    212e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2130:	0f b6       	in	r0, 0x3f	; 63
    2132:	f8 94       	cli
    2134:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2136:	e9 81       	ldd	r30, Y+1	; 0x01
    2138:	fa 81       	ldd	r31, Y+2	; 0x02
    213a:	93 8d       	ldd	r25, Z+27	; 0x1b
    213c:	e9 81       	ldd	r30, Y+1	; 0x01
    213e:	fa 81       	ldd	r31, Y+2	; 0x02
    2140:	82 8d       	ldd	r24, Z+26	; 0x1a
    2142:	29 2f       	mov	r18, r25
    2144:	28 1b       	sub	r18, r24
    2146:	82 2f       	mov	r24, r18
    2148:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    214a:	0f 90       	pop	r0
    214c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    214e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2150:	0f 90       	pop	r0
    2152:	0f 90       	pop	r0
    2154:	0f 90       	pop	r0
    2156:	0f 90       	pop	r0
    2158:	0f 90       	pop	r0
    215a:	cf 91       	pop	r28
    215c:	df 91       	pop	r29
    215e:	08 95       	ret

00002160 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2160:	df 93       	push	r29
    2162:	cf 93       	push	r28
    2164:	00 d0       	rcall	.+0      	; 0x2166 <uxQueueMessagesWaitingFromISR+0x6>
    2166:	0f 92       	push	r0
    2168:	cd b7       	in	r28, 0x3d	; 61
    216a:	de b7       	in	r29, 0x3e	; 62
    216c:	9b 83       	std	Y+3, r25	; 0x03
    216e:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2170:	ea 81       	ldd	r30, Y+2	; 0x02
    2172:	fb 81       	ldd	r31, Y+3	; 0x03
    2174:	82 8d       	ldd	r24, Z+26	; 0x1a
    2176:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    2178:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    217a:	0f 90       	pop	r0
    217c:	0f 90       	pop	r0
    217e:	0f 90       	pop	r0
    2180:	cf 91       	pop	r28
    2182:	df 91       	pop	r29
    2184:	08 95       	ret

00002186 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2186:	df 93       	push	r29
    2188:	cf 93       	push	r28
    218a:	00 d0       	rcall	.+0      	; 0x218c <vQueueDelete+0x6>
    218c:	00 d0       	rcall	.+0      	; 0x218e <vQueueDelete+0x8>
    218e:	cd b7       	in	r28, 0x3d	; 61
    2190:	de b7       	in	r29, 0x3e	; 62
    2192:	9c 83       	std	Y+4, r25	; 0x04
    2194:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2196:	8b 81       	ldd	r24, Y+3	; 0x03
    2198:	9c 81       	ldd	r25, Y+4	; 0x04
    219a:	9a 83       	std	Y+2, r25	; 0x02
    219c:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    219e:	e9 81       	ldd	r30, Y+1	; 0x01
    21a0:	fa 81       	ldd	r31, Y+2	; 0x02
    21a2:	80 81       	ld	r24, Z
    21a4:	91 81       	ldd	r25, Z+1	; 0x01
    21a6:	00 97       	sbiw	r24, 0x00	; 0
    21a8:	31 f0       	breq	.+12     	; 0x21b6 <vQueueDelete+0x30>
	{
		vPortFree( pxQueue->pcHead );
    21aa:	e9 81       	ldd	r30, Y+1	; 0x01
    21ac:	fa 81       	ldd	r31, Y+2	; 0x02
    21ae:	80 81       	ld	r24, Z
    21b0:	91 81       	ldd	r25, Z+1	; 0x01
    21b2:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
	}
	vPortFree( pxQueue );
    21b6:	89 81       	ldd	r24, Y+1	; 0x01
    21b8:	9a 81       	ldd	r25, Y+2	; 0x02
    21ba:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
}
    21be:	0f 90       	pop	r0
    21c0:	0f 90       	pop	r0
    21c2:	0f 90       	pop	r0
    21c4:	0f 90       	pop	r0
    21c6:	cf 91       	pop	r28
    21c8:	df 91       	pop	r29
    21ca:	08 95       	ret

000021cc <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    21cc:	df 93       	push	r29
    21ce:	cf 93       	push	r28
    21d0:	00 d0       	rcall	.+0      	; 0x21d2 <prvCopyDataToQueue+0x6>
    21d2:	00 d0       	rcall	.+0      	; 0x21d4 <prvCopyDataToQueue+0x8>
    21d4:	00 d0       	rcall	.+0      	; 0x21d6 <prvCopyDataToQueue+0xa>
    21d6:	cd b7       	in	r28, 0x3d	; 61
    21d8:	de b7       	in	r29, 0x3e	; 62
    21da:	9b 83       	std	Y+3, r25	; 0x03
    21dc:	8a 83       	std	Y+2, r24	; 0x02
    21de:	7d 83       	std	Y+5, r23	; 0x05
    21e0:	6c 83       	std	Y+4, r22	; 0x04
    21e2:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    21e4:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    21e6:	ea 81       	ldd	r30, Y+2	; 0x02
    21e8:	fb 81       	ldd	r31, Y+3	; 0x03
    21ea:	84 8d       	ldd	r24, Z+28	; 0x1c
    21ec:	88 23       	and	r24, r24
    21ee:	99 f4       	brne	.+38     	; 0x2216 <prvCopyDataToQueue+0x4a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    21f0:	ea 81       	ldd	r30, Y+2	; 0x02
    21f2:	fb 81       	ldd	r31, Y+3	; 0x03
    21f4:	80 81       	ld	r24, Z
    21f6:	91 81       	ldd	r25, Z+1	; 0x01
    21f8:	00 97       	sbiw	r24, 0x00	; 0
    21fa:	09 f0       	breq	.+2      	; 0x21fe <prvCopyDataToQueue+0x32>
    21fc:	8f c0       	rjmp	.+286    	; 0x231c <prvCopyDataToQueue+0x150>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    21fe:	ea 81       	ldd	r30, Y+2	; 0x02
    2200:	fb 81       	ldd	r31, Y+3	; 0x03
    2202:	82 81       	ldd	r24, Z+2	; 0x02
    2204:	93 81       	ldd	r25, Z+3	; 0x03
    2206:	0e 94 d7 1d 	call	0x3bae	; 0x3bae <xTaskPriorityDisinherit>
    220a:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->pxMutexHolder = NULL;
    220c:	ea 81       	ldd	r30, Y+2	; 0x02
    220e:	fb 81       	ldd	r31, Y+3	; 0x03
    2210:	13 82       	std	Z+3, r1	; 0x03
    2212:	12 82       	std	Z+2, r1	; 0x02
    2214:	83 c0       	rjmp	.+262    	; 0x231c <prvCopyDataToQueue+0x150>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2216:	8e 81       	ldd	r24, Y+6	; 0x06
    2218:	88 23       	and	r24, r24
    221a:	99 f5       	brne	.+102    	; 0x2282 <prvCopyDataToQueue+0xb6>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    221c:	ea 81       	ldd	r30, Y+2	; 0x02
    221e:	fb 81       	ldd	r31, Y+3	; 0x03
    2220:	64 81       	ldd	r22, Z+4	; 0x04
    2222:	75 81       	ldd	r23, Z+5	; 0x05
    2224:	ea 81       	ldd	r30, Y+2	; 0x02
    2226:	fb 81       	ldd	r31, Y+3	; 0x03
    2228:	84 8d       	ldd	r24, Z+28	; 0x1c
    222a:	48 2f       	mov	r20, r24
    222c:	50 e0       	ldi	r21, 0x00	; 0
    222e:	2c 81       	ldd	r18, Y+4	; 0x04
    2230:	3d 81       	ldd	r19, Y+5	; 0x05
    2232:	cb 01       	movw	r24, r22
    2234:	b9 01       	movw	r22, r18
    2236:	0e 94 b7 24 	call	0x496e	; 0x496e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    223a:	ea 81       	ldd	r30, Y+2	; 0x02
    223c:	fb 81       	ldd	r31, Y+3	; 0x03
    223e:	24 81       	ldd	r18, Z+4	; 0x04
    2240:	35 81       	ldd	r19, Z+5	; 0x05
    2242:	ea 81       	ldd	r30, Y+2	; 0x02
    2244:	fb 81       	ldd	r31, Y+3	; 0x03
    2246:	84 8d       	ldd	r24, Z+28	; 0x1c
    2248:	88 2f       	mov	r24, r24
    224a:	90 e0       	ldi	r25, 0x00	; 0
    224c:	82 0f       	add	r24, r18
    224e:	93 1f       	adc	r25, r19
    2250:	ea 81       	ldd	r30, Y+2	; 0x02
    2252:	fb 81       	ldd	r31, Y+3	; 0x03
    2254:	95 83       	std	Z+5, r25	; 0x05
    2256:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2258:	ea 81       	ldd	r30, Y+2	; 0x02
    225a:	fb 81       	ldd	r31, Y+3	; 0x03
    225c:	24 81       	ldd	r18, Z+4	; 0x04
    225e:	35 81       	ldd	r19, Z+5	; 0x05
    2260:	ea 81       	ldd	r30, Y+2	; 0x02
    2262:	fb 81       	ldd	r31, Y+3	; 0x03
    2264:	82 81       	ldd	r24, Z+2	; 0x02
    2266:	93 81       	ldd	r25, Z+3	; 0x03
    2268:	28 17       	cp	r18, r24
    226a:	39 07       	cpc	r19, r25
    226c:	08 f4       	brcc	.+2      	; 0x2270 <prvCopyDataToQueue+0xa4>
    226e:	56 c0       	rjmp	.+172    	; 0x231c <prvCopyDataToQueue+0x150>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2270:	ea 81       	ldd	r30, Y+2	; 0x02
    2272:	fb 81       	ldd	r31, Y+3	; 0x03
    2274:	80 81       	ld	r24, Z
    2276:	91 81       	ldd	r25, Z+1	; 0x01
    2278:	ea 81       	ldd	r30, Y+2	; 0x02
    227a:	fb 81       	ldd	r31, Y+3	; 0x03
    227c:	95 83       	std	Z+5, r25	; 0x05
    227e:	84 83       	std	Z+4, r24	; 0x04
    2280:	4d c0       	rjmp	.+154    	; 0x231c <prvCopyDataToQueue+0x150>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2282:	ea 81       	ldd	r30, Y+2	; 0x02
    2284:	fb 81       	ldd	r31, Y+3	; 0x03
    2286:	66 81       	ldd	r22, Z+6	; 0x06
    2288:	77 81       	ldd	r23, Z+7	; 0x07
    228a:	ea 81       	ldd	r30, Y+2	; 0x02
    228c:	fb 81       	ldd	r31, Y+3	; 0x03
    228e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2290:	48 2f       	mov	r20, r24
    2292:	50 e0       	ldi	r21, 0x00	; 0
    2294:	2c 81       	ldd	r18, Y+4	; 0x04
    2296:	3d 81       	ldd	r19, Y+5	; 0x05
    2298:	cb 01       	movw	r24, r22
    229a:	b9 01       	movw	r22, r18
    229c:	0e 94 b7 24 	call	0x496e	; 0x496e <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    22a0:	ea 81       	ldd	r30, Y+2	; 0x02
    22a2:	fb 81       	ldd	r31, Y+3	; 0x03
    22a4:	26 81       	ldd	r18, Z+6	; 0x06
    22a6:	37 81       	ldd	r19, Z+7	; 0x07
    22a8:	ea 81       	ldd	r30, Y+2	; 0x02
    22aa:	fb 81       	ldd	r31, Y+3	; 0x03
    22ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    22ae:	88 2f       	mov	r24, r24
    22b0:	90 e0       	ldi	r25, 0x00	; 0
    22b2:	90 95       	com	r25
    22b4:	81 95       	neg	r24
    22b6:	9f 4f       	sbci	r25, 0xFF	; 255
    22b8:	82 0f       	add	r24, r18
    22ba:	93 1f       	adc	r25, r19
    22bc:	ea 81       	ldd	r30, Y+2	; 0x02
    22be:	fb 81       	ldd	r31, Y+3	; 0x03
    22c0:	97 83       	std	Z+7, r25	; 0x07
    22c2:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    22c4:	ea 81       	ldd	r30, Y+2	; 0x02
    22c6:	fb 81       	ldd	r31, Y+3	; 0x03
    22c8:	26 81       	ldd	r18, Z+6	; 0x06
    22ca:	37 81       	ldd	r19, Z+7	; 0x07
    22cc:	ea 81       	ldd	r30, Y+2	; 0x02
    22ce:	fb 81       	ldd	r31, Y+3	; 0x03
    22d0:	80 81       	ld	r24, Z
    22d2:	91 81       	ldd	r25, Z+1	; 0x01
    22d4:	28 17       	cp	r18, r24
    22d6:	39 07       	cpc	r19, r25
    22d8:	90 f4       	brcc	.+36     	; 0x22fe <prvCopyDataToQueue+0x132>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    22da:	ea 81       	ldd	r30, Y+2	; 0x02
    22dc:	fb 81       	ldd	r31, Y+3	; 0x03
    22de:	22 81       	ldd	r18, Z+2	; 0x02
    22e0:	33 81       	ldd	r19, Z+3	; 0x03
    22e2:	ea 81       	ldd	r30, Y+2	; 0x02
    22e4:	fb 81       	ldd	r31, Y+3	; 0x03
    22e6:	84 8d       	ldd	r24, Z+28	; 0x1c
    22e8:	88 2f       	mov	r24, r24
    22ea:	90 e0       	ldi	r25, 0x00	; 0
    22ec:	90 95       	com	r25
    22ee:	81 95       	neg	r24
    22f0:	9f 4f       	sbci	r25, 0xFF	; 255
    22f2:	82 0f       	add	r24, r18
    22f4:	93 1f       	adc	r25, r19
    22f6:	ea 81       	ldd	r30, Y+2	; 0x02
    22f8:	fb 81       	ldd	r31, Y+3	; 0x03
    22fa:	97 83       	std	Z+7, r25	; 0x07
    22fc:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    22fe:	8e 81       	ldd	r24, Y+6	; 0x06
    2300:	82 30       	cpi	r24, 0x02	; 2
    2302:	61 f4       	brne	.+24     	; 0x231c <prvCopyDataToQueue+0x150>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2304:	ea 81       	ldd	r30, Y+2	; 0x02
    2306:	fb 81       	ldd	r31, Y+3	; 0x03
    2308:	82 8d       	ldd	r24, Z+26	; 0x1a
    230a:	88 23       	and	r24, r24
    230c:	39 f0       	breq	.+14     	; 0x231c <prvCopyDataToQueue+0x150>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    230e:	ea 81       	ldd	r30, Y+2	; 0x02
    2310:	fb 81       	ldd	r31, Y+3	; 0x03
    2312:	82 8d       	ldd	r24, Z+26	; 0x1a
    2314:	81 50       	subi	r24, 0x01	; 1
    2316:	ea 81       	ldd	r30, Y+2	; 0x02
    2318:	fb 81       	ldd	r31, Y+3	; 0x03
    231a:	82 8f       	std	Z+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    231c:	ea 81       	ldd	r30, Y+2	; 0x02
    231e:	fb 81       	ldd	r31, Y+3	; 0x03
    2320:	82 8d       	ldd	r24, Z+26	; 0x1a
    2322:	8f 5f       	subi	r24, 0xFF	; 255
    2324:	ea 81       	ldd	r30, Y+2	; 0x02
    2326:	fb 81       	ldd	r31, Y+3	; 0x03
    2328:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    232a:	89 81       	ldd	r24, Y+1	; 0x01
}
    232c:	26 96       	adiw	r28, 0x06	; 6
    232e:	0f b6       	in	r0, 0x3f	; 63
    2330:	f8 94       	cli
    2332:	de bf       	out	0x3e, r29	; 62
    2334:	0f be       	out	0x3f, r0	; 63
    2336:	cd bf       	out	0x3d, r28	; 61
    2338:	cf 91       	pop	r28
    233a:	df 91       	pop	r29
    233c:	08 95       	ret

0000233e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    233e:	df 93       	push	r29
    2340:	cf 93       	push	r28
    2342:	00 d0       	rcall	.+0      	; 0x2344 <prvCopyDataFromQueue+0x6>
    2344:	00 d0       	rcall	.+0      	; 0x2346 <prvCopyDataFromQueue+0x8>
    2346:	cd b7       	in	r28, 0x3d	; 61
    2348:	de b7       	in	r29, 0x3e	; 62
    234a:	9a 83       	std	Y+2, r25	; 0x02
    234c:	89 83       	std	Y+1, r24	; 0x01
    234e:	7c 83       	std	Y+4, r23	; 0x04
    2350:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2352:	e9 81       	ldd	r30, Y+1	; 0x01
    2354:	fa 81       	ldd	r31, Y+2	; 0x02
    2356:	84 8d       	ldd	r24, Z+28	; 0x1c
    2358:	88 23       	and	r24, r24
    235a:	89 f1       	breq	.+98     	; 0x23be <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    235c:	e9 81       	ldd	r30, Y+1	; 0x01
    235e:	fa 81       	ldd	r31, Y+2	; 0x02
    2360:	26 81       	ldd	r18, Z+6	; 0x06
    2362:	37 81       	ldd	r19, Z+7	; 0x07
    2364:	e9 81       	ldd	r30, Y+1	; 0x01
    2366:	fa 81       	ldd	r31, Y+2	; 0x02
    2368:	84 8d       	ldd	r24, Z+28	; 0x1c
    236a:	88 2f       	mov	r24, r24
    236c:	90 e0       	ldi	r25, 0x00	; 0
    236e:	82 0f       	add	r24, r18
    2370:	93 1f       	adc	r25, r19
    2372:	e9 81       	ldd	r30, Y+1	; 0x01
    2374:	fa 81       	ldd	r31, Y+2	; 0x02
    2376:	97 83       	std	Z+7, r25	; 0x07
    2378:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    237a:	e9 81       	ldd	r30, Y+1	; 0x01
    237c:	fa 81       	ldd	r31, Y+2	; 0x02
    237e:	26 81       	ldd	r18, Z+6	; 0x06
    2380:	37 81       	ldd	r19, Z+7	; 0x07
    2382:	e9 81       	ldd	r30, Y+1	; 0x01
    2384:	fa 81       	ldd	r31, Y+2	; 0x02
    2386:	82 81       	ldd	r24, Z+2	; 0x02
    2388:	93 81       	ldd	r25, Z+3	; 0x03
    238a:	28 17       	cp	r18, r24
    238c:	39 07       	cpc	r19, r25
    238e:	40 f0       	brcs	.+16     	; 0x23a0 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2390:	e9 81       	ldd	r30, Y+1	; 0x01
    2392:	fa 81       	ldd	r31, Y+2	; 0x02
    2394:	80 81       	ld	r24, Z
    2396:	91 81       	ldd	r25, Z+1	; 0x01
    2398:	e9 81       	ldd	r30, Y+1	; 0x01
    239a:	fa 81       	ldd	r31, Y+2	; 0x02
    239c:	97 83       	std	Z+7, r25	; 0x07
    239e:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    23a0:	e9 81       	ldd	r30, Y+1	; 0x01
    23a2:	fa 81       	ldd	r31, Y+2	; 0x02
    23a4:	46 81       	ldd	r20, Z+6	; 0x06
    23a6:	57 81       	ldd	r21, Z+7	; 0x07
    23a8:	e9 81       	ldd	r30, Y+1	; 0x01
    23aa:	fa 81       	ldd	r31, Y+2	; 0x02
    23ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    23ae:	28 2f       	mov	r18, r24
    23b0:	30 e0       	ldi	r19, 0x00	; 0
    23b2:	8b 81       	ldd	r24, Y+3	; 0x03
    23b4:	9c 81       	ldd	r25, Y+4	; 0x04
    23b6:	ba 01       	movw	r22, r20
    23b8:	a9 01       	movw	r20, r18
    23ba:	0e 94 b7 24 	call	0x496e	; 0x496e <memcpy>
	}
}
    23be:	0f 90       	pop	r0
    23c0:	0f 90       	pop	r0
    23c2:	0f 90       	pop	r0
    23c4:	0f 90       	pop	r0
    23c6:	cf 91       	pop	r28
    23c8:	df 91       	pop	r29
    23ca:	08 95       	ret

000023cc <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    23cc:	df 93       	push	r29
    23ce:	cf 93       	push	r28
    23d0:	00 d0       	rcall	.+0      	; 0x23d2 <prvUnlockQueue+0x6>
    23d2:	cd b7       	in	r28, 0x3d	; 61
    23d4:	de b7       	in	r29, 0x3e	; 62
    23d6:	9a 83       	std	Y+2, r25	; 0x02
    23d8:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    23da:	0f b6       	in	r0, 0x3f	; 63
    23dc:	f8 94       	cli
    23de:	0f 92       	push	r0
    23e0:	15 c0       	rjmp	.+42     	; 0x240c <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    23e2:	e9 81       	ldd	r30, Y+1	; 0x01
    23e4:	fa 81       	ldd	r31, Y+2	; 0x02
    23e6:	81 89       	ldd	r24, Z+17	; 0x11
    23e8:	88 23       	and	r24, r24
    23ea:	a9 f0       	breq	.+42     	; 0x2416 <prvUnlockQueue+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    23ec:	89 81       	ldd	r24, Y+1	; 0x01
    23ee:	9a 81       	ldd	r25, Y+2	; 0x02
    23f0:	41 96       	adiw	r24, 0x11	; 17
    23f2:	0e 94 10 1a 	call	0x3420	; 0x3420 <xTaskRemoveFromEventList>
    23f6:	88 23       	and	r24, r24
    23f8:	11 f0       	breq	.+4      	; 0x23fe <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    23fa:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    23fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2400:	fa 81       	ldd	r31, Y+2	; 0x02
    2402:	86 8d       	ldd	r24, Z+30	; 0x1e
    2404:	81 50       	subi	r24, 0x01	; 1
    2406:	e9 81       	ldd	r30, Y+1	; 0x01
    2408:	fa 81       	ldd	r31, Y+2	; 0x02
    240a:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    240c:	e9 81       	ldd	r30, Y+1	; 0x01
    240e:	fa 81       	ldd	r31, Y+2	; 0x02
    2410:	86 8d       	ldd	r24, Z+30	; 0x1e
    2412:	18 16       	cp	r1, r24
    2414:	34 f3       	brlt	.-52     	; 0x23e2 <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2416:	e9 81       	ldd	r30, Y+1	; 0x01
    2418:	fa 81       	ldd	r31, Y+2	; 0x02
    241a:	8f ef       	ldi	r24, 0xFF	; 255
    241c:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    241e:	0f 90       	pop	r0
    2420:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2422:	0f b6       	in	r0, 0x3f	; 63
    2424:	f8 94       	cli
    2426:	0f 92       	push	r0
    2428:	15 c0       	rjmp	.+42     	; 0x2454 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    242a:	e9 81       	ldd	r30, Y+1	; 0x01
    242c:	fa 81       	ldd	r31, Y+2	; 0x02
    242e:	80 85       	ldd	r24, Z+8	; 0x08
    2430:	88 23       	and	r24, r24
    2432:	a9 f0       	breq	.+42     	; 0x245e <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2434:	89 81       	ldd	r24, Y+1	; 0x01
    2436:	9a 81       	ldd	r25, Y+2	; 0x02
    2438:	08 96       	adiw	r24, 0x08	; 8
    243a:	0e 94 10 1a 	call	0x3420	; 0x3420 <xTaskRemoveFromEventList>
    243e:	88 23       	and	r24, r24
    2440:	11 f0       	breq	.+4      	; 0x2446 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2442:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2446:	e9 81       	ldd	r30, Y+1	; 0x01
    2448:	fa 81       	ldd	r31, Y+2	; 0x02
    244a:	85 8d       	ldd	r24, Z+29	; 0x1d
    244c:	81 50       	subi	r24, 0x01	; 1
    244e:	e9 81       	ldd	r30, Y+1	; 0x01
    2450:	fa 81       	ldd	r31, Y+2	; 0x02
    2452:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2454:	e9 81       	ldd	r30, Y+1	; 0x01
    2456:	fa 81       	ldd	r31, Y+2	; 0x02
    2458:	85 8d       	ldd	r24, Z+29	; 0x1d
    245a:	18 16       	cp	r1, r24
    245c:	34 f3       	brlt	.-52     	; 0x242a <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    245e:	e9 81       	ldd	r30, Y+1	; 0x01
    2460:	fa 81       	ldd	r31, Y+2	; 0x02
    2462:	8f ef       	ldi	r24, 0xFF	; 255
    2464:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2466:	0f 90       	pop	r0
    2468:	0f be       	out	0x3f, r0	; 63
}
    246a:	0f 90       	pop	r0
    246c:	0f 90       	pop	r0
    246e:	cf 91       	pop	r28
    2470:	df 91       	pop	r29
    2472:	08 95       	ret

00002474 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2474:	df 93       	push	r29
    2476:	cf 93       	push	r28
    2478:	00 d0       	rcall	.+0      	; 0x247a <prvIsQueueEmpty+0x6>
    247a:	0f 92       	push	r0
    247c:	cd b7       	in	r28, 0x3d	; 61
    247e:	de b7       	in	r29, 0x3e	; 62
    2480:	9b 83       	std	Y+3, r25	; 0x03
    2482:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2484:	0f b6       	in	r0, 0x3f	; 63
    2486:	f8 94       	cli
    2488:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    248a:	ea 81       	ldd	r30, Y+2	; 0x02
    248c:	fb 81       	ldd	r31, Y+3	; 0x03
    248e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2490:	88 23       	and	r24, r24
    2492:	19 f4       	brne	.+6      	; 0x249a <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2494:	81 e0       	ldi	r24, 0x01	; 1
    2496:	89 83       	std	Y+1, r24	; 0x01
    2498:	01 c0       	rjmp	.+2      	; 0x249c <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    249a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    249c:	0f 90       	pop	r0
    249e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    24a0:	89 81       	ldd	r24, Y+1	; 0x01
}
    24a2:	0f 90       	pop	r0
    24a4:	0f 90       	pop	r0
    24a6:	0f 90       	pop	r0
    24a8:	cf 91       	pop	r28
    24aa:	df 91       	pop	r29
    24ac:	08 95       	ret

000024ae <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    24ae:	df 93       	push	r29
    24b0:	cf 93       	push	r28
    24b2:	00 d0       	rcall	.+0      	; 0x24b4 <xQueueIsQueueEmptyFromISR+0x6>
    24b4:	0f 92       	push	r0
    24b6:	cd b7       	in	r28, 0x3d	; 61
    24b8:	de b7       	in	r29, 0x3e	; 62
    24ba:	9b 83       	std	Y+3, r25	; 0x03
    24bc:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    24be:	ea 81       	ldd	r30, Y+2	; 0x02
    24c0:	fb 81       	ldd	r31, Y+3	; 0x03
    24c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    24c4:	88 23       	and	r24, r24
    24c6:	19 f4       	brne	.+6      	; 0x24ce <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    24c8:	81 e0       	ldi	r24, 0x01	; 1
    24ca:	89 83       	std	Y+1, r24	; 0x01
    24cc:	01 c0       	rjmp	.+2      	; 0x24d0 <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    24ce:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    24d0:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    24d2:	0f 90       	pop	r0
    24d4:	0f 90       	pop	r0
    24d6:	0f 90       	pop	r0
    24d8:	cf 91       	pop	r28
    24da:	df 91       	pop	r29
    24dc:	08 95       	ret

000024de <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    24de:	df 93       	push	r29
    24e0:	cf 93       	push	r28
    24e2:	00 d0       	rcall	.+0      	; 0x24e4 <prvIsQueueFull+0x6>
    24e4:	0f 92       	push	r0
    24e6:	cd b7       	in	r28, 0x3d	; 61
    24e8:	de b7       	in	r29, 0x3e	; 62
    24ea:	9b 83       	std	Y+3, r25	; 0x03
    24ec:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    24ee:	0f b6       	in	r0, 0x3f	; 63
    24f0:	f8 94       	cli
    24f2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    24f4:	ea 81       	ldd	r30, Y+2	; 0x02
    24f6:	fb 81       	ldd	r31, Y+3	; 0x03
    24f8:	92 8d       	ldd	r25, Z+26	; 0x1a
    24fa:	ea 81       	ldd	r30, Y+2	; 0x02
    24fc:	fb 81       	ldd	r31, Y+3	; 0x03
    24fe:	83 8d       	ldd	r24, Z+27	; 0x1b
    2500:	98 17       	cp	r25, r24
    2502:	19 f4       	brne	.+6      	; 0x250a <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2504:	81 e0       	ldi	r24, 0x01	; 1
    2506:	89 83       	std	Y+1, r24	; 0x01
    2508:	01 c0       	rjmp	.+2      	; 0x250c <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    250a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    250c:	0f 90       	pop	r0
    250e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2510:	89 81       	ldd	r24, Y+1	; 0x01
}
    2512:	0f 90       	pop	r0
    2514:	0f 90       	pop	r0
    2516:	0f 90       	pop	r0
    2518:	cf 91       	pop	r28
    251a:	df 91       	pop	r29
    251c:	08 95       	ret

0000251e <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    251e:	df 93       	push	r29
    2520:	cf 93       	push	r28
    2522:	00 d0       	rcall	.+0      	; 0x2524 <xQueueIsQueueFullFromISR+0x6>
    2524:	0f 92       	push	r0
    2526:	cd b7       	in	r28, 0x3d	; 61
    2528:	de b7       	in	r29, 0x3e	; 62
    252a:	9b 83       	std	Y+3, r25	; 0x03
    252c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    252e:	ea 81       	ldd	r30, Y+2	; 0x02
    2530:	fb 81       	ldd	r31, Y+3	; 0x03
    2532:	92 8d       	ldd	r25, Z+26	; 0x1a
    2534:	ea 81       	ldd	r30, Y+2	; 0x02
    2536:	fb 81       	ldd	r31, Y+3	; 0x03
    2538:	83 8d       	ldd	r24, Z+27	; 0x1b
    253a:	98 17       	cp	r25, r24
    253c:	19 f4       	brne	.+6      	; 0x2544 <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    253e:	81 e0       	ldi	r24, 0x01	; 1
    2540:	89 83       	std	Y+1, r24	; 0x01
    2542:	01 c0       	rjmp	.+2      	; 0x2546 <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    2544:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2546:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2548:	0f 90       	pop	r0
    254a:	0f 90       	pop	r0
    254c:	0f 90       	pop	r0
    254e:	cf 91       	pop	r28
    2550:	df 91       	pop	r29
    2552:	08 95       	ret

00002554 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    2554:	df 93       	push	r29
    2556:	cf 93       	push	r28
    2558:	cd b7       	in	r28, 0x3d	; 61
    255a:	de b7       	in	r29, 0x3e	; 62
    255c:	2a 97       	sbiw	r28, 0x0a	; 10
    255e:	0f b6       	in	r0, 0x3f	; 63
    2560:	f8 94       	cli
    2562:	de bf       	out	0x3e, r29	; 62
    2564:	0f be       	out	0x3f, r0	; 63
    2566:	cd bf       	out	0x3d, r28	; 61
    2568:	9d 83       	std	Y+5, r25	; 0x05
    256a:	8c 83       	std	Y+4, r24	; 0x04
    256c:	7f 83       	std	Y+7, r23	; 0x07
    256e:	6e 83       	std	Y+6, r22	; 0x06
    2570:	59 87       	std	Y+9, r21	; 0x09
    2572:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2574:	8c 81       	ldd	r24, Y+4	; 0x04
    2576:	9d 81       	ldd	r25, Y+5	; 0x05
    2578:	9a 83       	std	Y+2, r25	; 0x02
    257a:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    257c:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    257e:	89 81       	ldd	r24, Y+1	; 0x01
    2580:	9a 81       	ldd	r25, Y+2	; 0x02
    2582:	0e 94 6f 12 	call	0x24de	; 0x24de <prvIsQueueFull>
    2586:	88 23       	and	r24, r24
    2588:	a9 f0       	breq	.+42     	; 0x25b4 <xQueueCRSend+0x60>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    258a:	88 85       	ldd	r24, Y+8	; 0x08
    258c:	99 85       	ldd	r25, Y+9	; 0x09
    258e:	00 97       	sbiw	r24, 0x00	; 0
    2590:	71 f0       	breq	.+28     	; 0x25ae <xQueueCRSend+0x5a>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    2592:	89 81       	ldd	r24, Y+1	; 0x01
    2594:	9a 81       	ldd	r25, Y+2	; 0x02
    2596:	9c 01       	movw	r18, r24
    2598:	28 5f       	subi	r18, 0xF8	; 248
    259a:	3f 4f       	sbci	r19, 0xFF	; 255
    259c:	88 85       	ldd	r24, Y+8	; 0x08
    259e:	99 85       	ldd	r25, Y+9	; 0x09
    25a0:	b9 01       	movw	r22, r18
    25a2:	0e 94 c7 01 	call	0x38e	; 0x38e <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    25a6:	78 94       	sei
					return errQUEUE_BLOCKED;
    25a8:	8c ef       	ldi	r24, 0xFC	; 252
    25aa:	8a 87       	std	Y+10, r24	; 0x0a
    25ac:	2a c0       	rjmp	.+84     	; 0x2602 <xQueueCRSend+0xae>
				}
				else
				{
					portENABLE_INTERRUPTS();
    25ae:	78 94       	sei
					return errQUEUE_FULL;
    25b0:	1a 86       	std	Y+10, r1	; 0x0a
    25b2:	27 c0       	rjmp	.+78     	; 0x2602 <xQueueCRSend+0xae>
				}
			}
		}
		portENABLE_INTERRUPTS();
    25b4:	78 94       	sei

		portDISABLE_INTERRUPTS();
    25b6:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    25b8:	e9 81       	ldd	r30, Y+1	; 0x01
    25ba:	fa 81       	ldd	r31, Y+2	; 0x02
    25bc:	92 8d       	ldd	r25, Z+26	; 0x1a
    25be:	e9 81       	ldd	r30, Y+1	; 0x01
    25c0:	fa 81       	ldd	r31, Y+2	; 0x02
    25c2:	83 8d       	ldd	r24, Z+27	; 0x1b
    25c4:	98 17       	cp	r25, r24
    25c6:	c8 f4       	brcc	.+50     	; 0x25fa <xQueueCRSend+0xa6>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    25c8:	89 81       	ldd	r24, Y+1	; 0x01
    25ca:	9a 81       	ldd	r25, Y+2	; 0x02
    25cc:	2e 81       	ldd	r18, Y+6	; 0x06
    25ce:	3f 81       	ldd	r19, Y+7	; 0x07
    25d0:	b9 01       	movw	r22, r18
    25d2:	40 e0       	ldi	r20, 0x00	; 0
    25d4:	0e 94 e6 10 	call	0x21cc	; 0x21cc <prvCopyDataToQueue>
				xReturn = pdPASS;
    25d8:	81 e0       	ldi	r24, 0x01	; 1
    25da:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    25dc:	e9 81       	ldd	r30, Y+1	; 0x01
    25de:	fa 81       	ldd	r31, Y+2	; 0x02
    25e0:	81 89       	ldd	r24, Z+17	; 0x11
    25e2:	88 23       	and	r24, r24
    25e4:	59 f0       	breq	.+22     	; 0x25fc <xQueueCRSend+0xa8>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    25e6:	89 81       	ldd	r24, Y+1	; 0x01
    25e8:	9a 81       	ldd	r25, Y+2	; 0x02
    25ea:	41 96       	adiw	r24, 0x11	; 17
    25ec:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <xCoRoutineRemoveFromEventList>
    25f0:	88 23       	and	r24, r24
    25f2:	21 f0       	breq	.+8      	; 0x25fc <xQueueCRSend+0xa8>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    25f4:	8b ef       	ldi	r24, 0xFB	; 251
    25f6:	8b 83       	std	Y+3, r24	; 0x03
    25f8:	01 c0       	rjmp	.+2      	; 0x25fc <xQueueCRSend+0xa8>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    25fa:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    25fc:	78 94       	sei

		return xReturn;
    25fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2600:	8a 87       	std	Y+10, r24	; 0x0a
    2602:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    2604:	2a 96       	adiw	r28, 0x0a	; 10
    2606:	0f b6       	in	r0, 0x3f	; 63
    2608:	f8 94       	cli
    260a:	de bf       	out	0x3e, r29	; 62
    260c:	0f be       	out	0x3f, r0	; 63
    260e:	cd bf       	out	0x3d, r28	; 61
    2610:	cf 91       	pop	r28
    2612:	df 91       	pop	r29
    2614:	08 95       	ret

00002616 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    2616:	df 93       	push	r29
    2618:	cf 93       	push	r28
    261a:	cd b7       	in	r28, 0x3d	; 61
    261c:	de b7       	in	r29, 0x3e	; 62
    261e:	2a 97       	sbiw	r28, 0x0a	; 10
    2620:	0f b6       	in	r0, 0x3f	; 63
    2622:	f8 94       	cli
    2624:	de bf       	out	0x3e, r29	; 62
    2626:	0f be       	out	0x3f, r0	; 63
    2628:	cd bf       	out	0x3d, r28	; 61
    262a:	9d 83       	std	Y+5, r25	; 0x05
    262c:	8c 83       	std	Y+4, r24	; 0x04
    262e:	7f 83       	std	Y+7, r23	; 0x07
    2630:	6e 83       	std	Y+6, r22	; 0x06
    2632:	59 87       	std	Y+9, r21	; 0x09
    2634:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2636:	8c 81       	ldd	r24, Y+4	; 0x04
    2638:	9d 81       	ldd	r25, Y+5	; 0x05
    263a:	9a 83       	std	Y+2, r25	; 0x02
    263c:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    263e:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2640:	e9 81       	ldd	r30, Y+1	; 0x01
    2642:	fa 81       	ldd	r31, Y+2	; 0x02
    2644:	82 8d       	ldd	r24, Z+26	; 0x1a
    2646:	88 23       	and	r24, r24
    2648:	a9 f4       	brne	.+42     	; 0x2674 <xQueueCRReceive+0x5e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    264a:	88 85       	ldd	r24, Y+8	; 0x08
    264c:	99 85       	ldd	r25, Y+9	; 0x09
    264e:	00 97       	sbiw	r24, 0x00	; 0
    2650:	71 f0       	breq	.+28     	; 0x266e <xQueueCRReceive+0x58>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2652:	89 81       	ldd	r24, Y+1	; 0x01
    2654:	9a 81       	ldd	r25, Y+2	; 0x02
    2656:	9c 01       	movw	r18, r24
    2658:	2f 5e       	subi	r18, 0xEF	; 239
    265a:	3f 4f       	sbci	r19, 0xFF	; 255
    265c:	88 85       	ldd	r24, Y+8	; 0x08
    265e:	99 85       	ldd	r25, Y+9	; 0x09
    2660:	b9 01       	movw	r22, r18
    2662:	0e 94 c7 01 	call	0x38e	; 0x38e <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    2666:	78 94       	sei
					return errQUEUE_BLOCKED;
    2668:	8c ef       	ldi	r24, 0xFC	; 252
    266a:	8a 87       	std	Y+10, r24	; 0x0a
    266c:	58 c0       	rjmp	.+176    	; 0x271e <xQueueCRReceive+0x108>
				}
				else
				{
					portENABLE_INTERRUPTS();
    266e:	78 94       	sei
					return errQUEUE_FULL;
    2670:	1a 86       	std	Y+10, r1	; 0x0a
    2672:	55 c0       	rjmp	.+170    	; 0x271e <xQueueCRReceive+0x108>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    2674:	78 94       	sei

		portDISABLE_INTERRUPTS();
    2676:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2678:	e9 81       	ldd	r30, Y+1	; 0x01
    267a:	fa 81       	ldd	r31, Y+2	; 0x02
    267c:	82 8d       	ldd	r24, Z+26	; 0x1a
    267e:	88 23       	and	r24, r24
    2680:	09 f4       	brne	.+2      	; 0x2684 <xQueueCRReceive+0x6e>
    2682:	49 c0       	rjmp	.+146    	; 0x2716 <xQueueCRReceive+0x100>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2684:	e9 81       	ldd	r30, Y+1	; 0x01
    2686:	fa 81       	ldd	r31, Y+2	; 0x02
    2688:	26 81       	ldd	r18, Z+6	; 0x06
    268a:	37 81       	ldd	r19, Z+7	; 0x07
    268c:	e9 81       	ldd	r30, Y+1	; 0x01
    268e:	fa 81       	ldd	r31, Y+2	; 0x02
    2690:	84 8d       	ldd	r24, Z+28	; 0x1c
    2692:	88 2f       	mov	r24, r24
    2694:	90 e0       	ldi	r25, 0x00	; 0
    2696:	82 0f       	add	r24, r18
    2698:	93 1f       	adc	r25, r19
    269a:	e9 81       	ldd	r30, Y+1	; 0x01
    269c:	fa 81       	ldd	r31, Y+2	; 0x02
    269e:	97 83       	std	Z+7, r25	; 0x07
    26a0:	86 83       	std	Z+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    26a2:	e9 81       	ldd	r30, Y+1	; 0x01
    26a4:	fa 81       	ldd	r31, Y+2	; 0x02
    26a6:	26 81       	ldd	r18, Z+6	; 0x06
    26a8:	37 81       	ldd	r19, Z+7	; 0x07
    26aa:	e9 81       	ldd	r30, Y+1	; 0x01
    26ac:	fa 81       	ldd	r31, Y+2	; 0x02
    26ae:	82 81       	ldd	r24, Z+2	; 0x02
    26b0:	93 81       	ldd	r25, Z+3	; 0x03
    26b2:	28 17       	cp	r18, r24
    26b4:	39 07       	cpc	r19, r25
    26b6:	40 f0       	brcs	.+16     	; 0x26c8 <xQueueCRReceive+0xb2>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    26b8:	e9 81       	ldd	r30, Y+1	; 0x01
    26ba:	fa 81       	ldd	r31, Y+2	; 0x02
    26bc:	80 81       	ld	r24, Z
    26be:	91 81       	ldd	r25, Z+1	; 0x01
    26c0:	e9 81       	ldd	r30, Y+1	; 0x01
    26c2:	fa 81       	ldd	r31, Y+2	; 0x02
    26c4:	97 83       	std	Z+7, r25	; 0x07
    26c6:	86 83       	std	Z+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    26c8:	e9 81       	ldd	r30, Y+1	; 0x01
    26ca:	fa 81       	ldd	r31, Y+2	; 0x02
    26cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    26ce:	81 50       	subi	r24, 0x01	; 1
    26d0:	e9 81       	ldd	r30, Y+1	; 0x01
    26d2:	fa 81       	ldd	r31, Y+2	; 0x02
    26d4:	82 8f       	std	Z+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    26d6:	e9 81       	ldd	r30, Y+1	; 0x01
    26d8:	fa 81       	ldd	r31, Y+2	; 0x02
    26da:	46 81       	ldd	r20, Z+6	; 0x06
    26dc:	57 81       	ldd	r21, Z+7	; 0x07
    26de:	e9 81       	ldd	r30, Y+1	; 0x01
    26e0:	fa 81       	ldd	r31, Y+2	; 0x02
    26e2:	84 8d       	ldd	r24, Z+28	; 0x1c
    26e4:	28 2f       	mov	r18, r24
    26e6:	30 e0       	ldi	r19, 0x00	; 0
    26e8:	8e 81       	ldd	r24, Y+6	; 0x06
    26ea:	9f 81       	ldd	r25, Y+7	; 0x07
    26ec:	ba 01       	movw	r22, r20
    26ee:	a9 01       	movw	r20, r18
    26f0:	0e 94 b7 24 	call	0x496e	; 0x496e <memcpy>

				xReturn = pdPASS;
    26f4:	81 e0       	ldi	r24, 0x01	; 1
    26f6:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    26f8:	e9 81       	ldd	r30, Y+1	; 0x01
    26fa:	fa 81       	ldd	r31, Y+2	; 0x02
    26fc:	80 85       	ldd	r24, Z+8	; 0x08
    26fe:	88 23       	and	r24, r24
    2700:	59 f0       	breq	.+22     	; 0x2718 <xQueueCRReceive+0x102>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2702:	89 81       	ldd	r24, Y+1	; 0x01
    2704:	9a 81       	ldd	r25, Y+2	; 0x02
    2706:	08 96       	adiw	r24, 0x08	; 8
    2708:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <xCoRoutineRemoveFromEventList>
    270c:	88 23       	and	r24, r24
    270e:	21 f0       	breq	.+8      	; 0x2718 <xQueueCRReceive+0x102>
					{
						xReturn = errQUEUE_YIELD;
    2710:	8b ef       	ldi	r24, 0xFB	; 251
    2712:	8b 83       	std	Y+3, r24	; 0x03
    2714:	01 c0       	rjmp	.+2      	; 0x2718 <xQueueCRReceive+0x102>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    2716:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    2718:	78 94       	sei

		return xReturn;
    271a:	8b 81       	ldd	r24, Y+3	; 0x03
    271c:	8a 87       	std	Y+10, r24	; 0x0a
    271e:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    2720:	2a 96       	adiw	r28, 0x0a	; 10
    2722:	0f b6       	in	r0, 0x3f	; 63
    2724:	f8 94       	cli
    2726:	de bf       	out	0x3e, r29	; 62
    2728:	0f be       	out	0x3f, r0	; 63
    272a:	cd bf       	out	0x3d, r28	; 61
    272c:	cf 91       	pop	r28
    272e:	df 91       	pop	r29
    2730:	08 95       	ret

00002732 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    2732:	df 93       	push	r29
    2734:	cf 93       	push	r28
    2736:	cd b7       	in	r28, 0x3d	; 61
    2738:	de b7       	in	r29, 0x3e	; 62
    273a:	28 97       	sbiw	r28, 0x08	; 8
    273c:	0f b6       	in	r0, 0x3f	; 63
    273e:	f8 94       	cli
    2740:	de bf       	out	0x3e, r29	; 62
    2742:	0f be       	out	0x3f, r0	; 63
    2744:	cd bf       	out	0x3d, r28	; 61
    2746:	9c 83       	std	Y+4, r25	; 0x04
    2748:	8b 83       	std	Y+3, r24	; 0x03
    274a:	7e 83       	std	Y+6, r23	; 0x06
    274c:	6d 83       	std	Y+5, r22	; 0x05
    274e:	4f 83       	std	Y+7, r20	; 0x07
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2750:	8b 81       	ldd	r24, Y+3	; 0x03
    2752:	9c 81       	ldd	r25, Y+4	; 0x04
    2754:	9a 83       	std	Y+2, r25	; 0x02
    2756:	89 83       	std	Y+1, r24	; 0x01

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2758:	e9 81       	ldd	r30, Y+1	; 0x01
    275a:	fa 81       	ldd	r31, Y+2	; 0x02
    275c:	92 8d       	ldd	r25, Z+26	; 0x1a
    275e:	e9 81       	ldd	r30, Y+1	; 0x01
    2760:	fa 81       	ldd	r31, Y+2	; 0x02
    2762:	83 8d       	ldd	r24, Z+27	; 0x1b
    2764:	98 17       	cp	r25, r24
    2766:	d0 f4       	brcc	.+52     	; 0x279c <xQueueCRSendFromISR+0x6a>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2768:	89 81       	ldd	r24, Y+1	; 0x01
    276a:	9a 81       	ldd	r25, Y+2	; 0x02
    276c:	2d 81       	ldd	r18, Y+5	; 0x05
    276e:	3e 81       	ldd	r19, Y+6	; 0x06
    2770:	b9 01       	movw	r22, r18
    2772:	40 e0       	ldi	r20, 0x00	; 0
    2774:	0e 94 e6 10 	call	0x21cc	; 0x21cc <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    2778:	8f 81       	ldd	r24, Y+7	; 0x07
    277a:	88 23       	and	r24, r24
    277c:	79 f4       	brne	.+30     	; 0x279c <xQueueCRSendFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    277e:	e9 81       	ldd	r30, Y+1	; 0x01
    2780:	fa 81       	ldd	r31, Y+2	; 0x02
    2782:	81 89       	ldd	r24, Z+17	; 0x11
    2784:	88 23       	and	r24, r24
    2786:	51 f0       	breq	.+20     	; 0x279c <xQueueCRSendFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2788:	89 81       	ldd	r24, Y+1	; 0x01
    278a:	9a 81       	ldd	r25, Y+2	; 0x02
    278c:	41 96       	adiw	r24, 0x11	; 17
    278e:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <xCoRoutineRemoveFromEventList>
    2792:	88 23       	and	r24, r24
    2794:	19 f0       	breq	.+6      	; 0x279c <xQueueCRSendFromISR+0x6a>
					{
						return pdTRUE;
    2796:	81 e0       	ldi	r24, 0x01	; 1
    2798:	88 87       	std	Y+8, r24	; 0x08
    279a:	02 c0       	rjmp	.+4      	; 0x27a0 <xQueueCRSendFromISR+0x6e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    279c:	8f 81       	ldd	r24, Y+7	; 0x07
    279e:	88 87       	std	Y+8, r24	; 0x08
    27a0:	88 85       	ldd	r24, Y+8	; 0x08
	}
    27a2:	28 96       	adiw	r28, 0x08	; 8
    27a4:	0f b6       	in	r0, 0x3f	; 63
    27a6:	f8 94       	cli
    27a8:	de bf       	out	0x3e, r29	; 62
    27aa:	0f be       	out	0x3f, r0	; 63
    27ac:	cd bf       	out	0x3d, r28	; 61
    27ae:	cf 91       	pop	r28
    27b0:	df 91       	pop	r29
    27b2:	08 95       	ret

000027b4 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    27b4:	df 93       	push	r29
    27b6:	cf 93       	push	r28
    27b8:	cd b7       	in	r28, 0x3d	; 61
    27ba:	de b7       	in	r29, 0x3e	; 62
    27bc:	29 97       	sbiw	r28, 0x09	; 9
    27be:	0f b6       	in	r0, 0x3f	; 63
    27c0:	f8 94       	cli
    27c2:	de bf       	out	0x3e, r29	; 62
    27c4:	0f be       	out	0x3f, r0	; 63
    27c6:	cd bf       	out	0x3d, r28	; 61
    27c8:	9d 83       	std	Y+5, r25	; 0x05
    27ca:	8c 83       	std	Y+4, r24	; 0x04
    27cc:	7f 83       	std	Y+7, r23	; 0x07
    27ce:	6e 83       	std	Y+6, r22	; 0x06
    27d0:	59 87       	std	Y+9, r21	; 0x09
    27d2:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    27d4:	8c 81       	ldd	r24, Y+4	; 0x04
    27d6:	9d 81       	ldd	r25, Y+5	; 0x05
    27d8:	9a 83       	std	Y+2, r25	; 0x02
    27da:	89 83       	std	Y+1, r24	; 0x01

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    27dc:	e9 81       	ldd	r30, Y+1	; 0x01
    27de:	fa 81       	ldd	r31, Y+2	; 0x02
    27e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    27e2:	88 23       	and	r24, r24
    27e4:	09 f4       	brne	.+2      	; 0x27e8 <xQueueCRReceiveFromISR+0x34>
    27e6:	50 c0       	rjmp	.+160    	; 0x2888 <xQueueCRReceiveFromISR+0xd4>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    27e8:	e9 81       	ldd	r30, Y+1	; 0x01
    27ea:	fa 81       	ldd	r31, Y+2	; 0x02
    27ec:	26 81       	ldd	r18, Z+6	; 0x06
    27ee:	37 81       	ldd	r19, Z+7	; 0x07
    27f0:	e9 81       	ldd	r30, Y+1	; 0x01
    27f2:	fa 81       	ldd	r31, Y+2	; 0x02
    27f4:	84 8d       	ldd	r24, Z+28	; 0x1c
    27f6:	88 2f       	mov	r24, r24
    27f8:	90 e0       	ldi	r25, 0x00	; 0
    27fa:	82 0f       	add	r24, r18
    27fc:	93 1f       	adc	r25, r19
    27fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2800:	fa 81       	ldd	r31, Y+2	; 0x02
    2802:	97 83       	std	Z+7, r25	; 0x07
    2804:	86 83       	std	Z+6, r24	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    2806:	e9 81       	ldd	r30, Y+1	; 0x01
    2808:	fa 81       	ldd	r31, Y+2	; 0x02
    280a:	26 81       	ldd	r18, Z+6	; 0x06
    280c:	37 81       	ldd	r19, Z+7	; 0x07
    280e:	e9 81       	ldd	r30, Y+1	; 0x01
    2810:	fa 81       	ldd	r31, Y+2	; 0x02
    2812:	82 81       	ldd	r24, Z+2	; 0x02
    2814:	93 81       	ldd	r25, Z+3	; 0x03
    2816:	28 17       	cp	r18, r24
    2818:	39 07       	cpc	r19, r25
    281a:	40 f0       	brcs	.+16     	; 0x282c <xQueueCRReceiveFromISR+0x78>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    281c:	e9 81       	ldd	r30, Y+1	; 0x01
    281e:	fa 81       	ldd	r31, Y+2	; 0x02
    2820:	80 81       	ld	r24, Z
    2822:	91 81       	ldd	r25, Z+1	; 0x01
    2824:	e9 81       	ldd	r30, Y+1	; 0x01
    2826:	fa 81       	ldd	r31, Y+2	; 0x02
    2828:	97 83       	std	Z+7, r25	; 0x07
    282a:	86 83       	std	Z+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    282c:	e9 81       	ldd	r30, Y+1	; 0x01
    282e:	fa 81       	ldd	r31, Y+2	; 0x02
    2830:	82 8d       	ldd	r24, Z+26	; 0x1a
    2832:	81 50       	subi	r24, 0x01	; 1
    2834:	e9 81       	ldd	r30, Y+1	; 0x01
    2836:	fa 81       	ldd	r31, Y+2	; 0x02
    2838:	82 8f       	std	Z+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    283a:	e9 81       	ldd	r30, Y+1	; 0x01
    283c:	fa 81       	ldd	r31, Y+2	; 0x02
    283e:	46 81       	ldd	r20, Z+6	; 0x06
    2840:	57 81       	ldd	r21, Z+7	; 0x07
    2842:	e9 81       	ldd	r30, Y+1	; 0x01
    2844:	fa 81       	ldd	r31, Y+2	; 0x02
    2846:	84 8d       	ldd	r24, Z+28	; 0x1c
    2848:	28 2f       	mov	r18, r24
    284a:	30 e0       	ldi	r19, 0x00	; 0
    284c:	8e 81       	ldd	r24, Y+6	; 0x06
    284e:	9f 81       	ldd	r25, Y+7	; 0x07
    2850:	ba 01       	movw	r22, r20
    2852:	a9 01       	movw	r20, r18
    2854:	0e 94 b7 24 	call	0x496e	; 0x496e <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    2858:	e8 85       	ldd	r30, Y+8	; 0x08
    285a:	f9 85       	ldd	r31, Y+9	; 0x09
    285c:	80 81       	ld	r24, Z
    285e:	88 23       	and	r24, r24
    2860:	81 f4       	brne	.+32     	; 0x2882 <xQueueCRReceiveFromISR+0xce>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2862:	e9 81       	ldd	r30, Y+1	; 0x01
    2864:	fa 81       	ldd	r31, Y+2	; 0x02
    2866:	80 85       	ldd	r24, Z+8	; 0x08
    2868:	88 23       	and	r24, r24
    286a:	59 f0       	breq	.+22     	; 0x2882 <xQueueCRReceiveFromISR+0xce>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    286c:	89 81       	ldd	r24, Y+1	; 0x01
    286e:	9a 81       	ldd	r25, Y+2	; 0x02
    2870:	08 96       	adiw	r24, 0x08	; 8
    2872:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <xCoRoutineRemoveFromEventList>
    2876:	88 23       	and	r24, r24
    2878:	21 f0       	breq	.+8      	; 0x2882 <xQueueCRReceiveFromISR+0xce>
					{
						*pxCoRoutineWoken = pdTRUE;
    287a:	e8 85       	ldd	r30, Y+8	; 0x08
    287c:	f9 85       	ldd	r31, Y+9	; 0x09
    287e:	81 e0       	ldi	r24, 0x01	; 1
    2880:	80 83       	st	Z, r24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    2882:	81 e0       	ldi	r24, 0x01	; 1
    2884:	8b 83       	std	Y+3, r24	; 0x03
    2886:	01 c0       	rjmp	.+2      	; 0x288a <xQueueCRReceiveFromISR+0xd6>
		}
		else
		{
			xReturn = pdFAIL;
    2888:	1b 82       	std	Y+3, r1	; 0x03
		}

		return xReturn;
    288a:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    288c:	29 96       	adiw	r28, 0x09	; 9
    288e:	0f b6       	in	r0, 0x3f	; 63
    2890:	f8 94       	cli
    2892:	de bf       	out	0x3e, r29	; 62
    2894:	0f be       	out	0x3f, r0	; 63
    2896:	cd bf       	out	0x3d, r28	; 61
    2898:	cf 91       	pop	r28
    289a:	df 91       	pop	r29
    289c:	08 95       	ret

0000289e <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    289e:	af 92       	push	r10
    28a0:	bf 92       	push	r11
    28a2:	cf 92       	push	r12
    28a4:	df 92       	push	r13
    28a6:	ef 92       	push	r14
    28a8:	ff 92       	push	r15
    28aa:	0f 93       	push	r16
    28ac:	1f 93       	push	r17
    28ae:	df 93       	push	r29
    28b0:	cf 93       	push	r28
    28b2:	cd b7       	in	r28, 0x3d	; 61
    28b4:	de b7       	in	r29, 0x3e	; 62
    28b6:	64 97       	sbiw	r28, 0x14	; 20
    28b8:	0f b6       	in	r0, 0x3f	; 63
    28ba:	f8 94       	cli
    28bc:	de bf       	out	0x3e, r29	; 62
    28be:	0f be       	out	0x3f, r0	; 63
    28c0:	cd bf       	out	0x3d, r28	; 61
    28c2:	9f 83       	std	Y+7, r25	; 0x07
    28c4:	8e 83       	std	Y+6, r24	; 0x06
    28c6:	79 87       	std	Y+9, r23	; 0x09
    28c8:	68 87       	std	Y+8, r22	; 0x08
    28ca:	5b 87       	std	Y+11, r21	; 0x0b
    28cc:	4a 87       	std	Y+10, r20	; 0x0a
    28ce:	3d 87       	std	Y+13, r19	; 0x0d
    28d0:	2c 87       	std	Y+12, r18	; 0x0c
    28d2:	0e 87       	std	Y+14, r16	; 0x0e
    28d4:	f8 8a       	std	Y+16, r15	; 0x10
    28d6:	ef 86       	std	Y+15, r14	; 0x0f
    28d8:	da 8a       	std	Y+18, r13	; 0x12
    28da:	c9 8a       	std	Y+17, r12	; 0x11
    28dc:	bc 8a       	std	Y+20, r11	; 0x14
    28de:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    28e0:	8a 85       	ldd	r24, Y+10	; 0x0a
    28e2:	9b 85       	ldd	r25, Y+11	; 0x0b
    28e4:	29 89       	ldd	r18, Y+17	; 0x11
    28e6:	3a 89       	ldd	r19, Y+18	; 0x12
    28e8:	b9 01       	movw	r22, r18
    28ea:	0e 94 b5 1c 	call	0x396a	; 0x396a <prvAllocateTCBAndStack>
    28ee:	9c 83       	std	Y+4, r25	; 0x04
    28f0:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    28f2:	8b 81       	ldd	r24, Y+3	; 0x03
    28f4:	9c 81       	ldd	r25, Y+4	; 0x04
    28f6:	00 97       	sbiw	r24, 0x00	; 0
    28f8:	09 f4       	brne	.+2      	; 0x28fc <xTaskGenericCreate+0x5e>
    28fa:	8d c0       	rjmp	.+282    	; 0x2a16 <xTaskGenericCreate+0x178>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    28fc:	eb 81       	ldd	r30, Y+3	; 0x03
    28fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2900:	27 89       	ldd	r18, Z+23	; 0x17
    2902:	30 8d       	ldd	r19, Z+24	; 0x18
    2904:	8a 85       	ldd	r24, Y+10	; 0x0a
    2906:	9b 85       	ldd	r25, Y+11	; 0x0b
    2908:	01 97       	sbiw	r24, 0x01	; 1
    290a:	82 0f       	add	r24, r18
    290c:	93 1f       	adc	r25, r19
    290e:	9a 83       	std	Y+2, r25	; 0x02
    2910:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    2912:	8b 81       	ldd	r24, Y+3	; 0x03
    2914:	9c 81       	ldd	r25, Y+4	; 0x04
    2916:	28 85       	ldd	r18, Y+8	; 0x08
    2918:	39 85       	ldd	r19, Y+9	; 0x09
    291a:	eb 89       	ldd	r30, Y+19	; 0x13
    291c:	fc 89       	ldd	r31, Y+20	; 0x14
    291e:	aa 85       	ldd	r26, Y+10	; 0x0a
    2920:	bb 85       	ldd	r27, Y+11	; 0x0b
    2922:	b9 01       	movw	r22, r18
    2924:	4e 85       	ldd	r20, Y+14	; 0x0e
    2926:	9f 01       	movw	r18, r30
    2928:	8d 01       	movw	r16, r26
    292a:	0e 94 76 1b 	call	0x36ec	; 0x36ec <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    292e:	89 81       	ldd	r24, Y+1	; 0x01
    2930:	9a 81       	ldd	r25, Y+2	; 0x02
    2932:	2e 81       	ldd	r18, Y+6	; 0x06
    2934:	3f 81       	ldd	r19, Y+7	; 0x07
    2936:	4c 85       	ldd	r20, Y+12	; 0x0c
    2938:	5d 85       	ldd	r21, Y+13	; 0x0d
    293a:	b9 01       	movw	r22, r18
    293c:	0e 94 cf 09 	call	0x139e	; 0x139e <pxPortInitialiseStack>
    2940:	eb 81       	ldd	r30, Y+3	; 0x03
    2942:	fc 81       	ldd	r31, Y+4	; 0x04
    2944:	91 83       	std	Z+1, r25	; 0x01
    2946:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    2948:	8f 85       	ldd	r24, Y+15	; 0x0f
    294a:	98 89       	ldd	r25, Y+16	; 0x10
    294c:	00 97       	sbiw	r24, 0x00	; 0
    294e:	31 f0       	breq	.+12     	; 0x295c <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2950:	ef 85       	ldd	r30, Y+15	; 0x0f
    2952:	f8 89       	ldd	r31, Y+16	; 0x10
    2954:	8b 81       	ldd	r24, Y+3	; 0x03
    2956:	9c 81       	ldd	r25, Y+4	; 0x04
    2958:	91 83       	std	Z+1, r25	; 0x01
    295a:	80 83       	st	Z, r24
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    295c:	0f b6       	in	r0, 0x3f	; 63
    295e:	f8 94       	cli
    2960:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2962:	80 91 44 05 	lds	r24, 0x0544
    2966:	8f 5f       	subi	r24, 0xFF	; 255
    2968:	80 93 44 05 	sts	0x0544, r24
			if( pxCurrentTCB == NULL )
    296c:	80 91 41 05 	lds	r24, 0x0541
    2970:	90 91 42 05 	lds	r25, 0x0542
    2974:	00 97       	sbiw	r24, 0x00	; 0
    2976:	69 f4       	brne	.+26     	; 0x2992 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2978:	8b 81       	ldd	r24, Y+3	; 0x03
    297a:	9c 81       	ldd	r25, Y+4	; 0x04
    297c:	90 93 42 05 	sts	0x0542, r25
    2980:	80 93 41 05 	sts	0x0541, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2984:	80 91 44 05 	lds	r24, 0x0544
    2988:	81 30       	cpi	r24, 0x01	; 1
    298a:	a9 f4       	brne	.+42     	; 0x29b6 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    298c:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <prvInitialiseTaskLists>
    2990:	12 c0       	rjmp	.+36     	; 0x29b6 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2992:	80 91 48 05 	lds	r24, 0x0548
    2996:	88 23       	and	r24, r24
    2998:	71 f4       	brne	.+28     	; 0x29b6 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    299a:	e0 91 41 05 	lds	r30, 0x0541
    299e:	f0 91 42 05 	lds	r31, 0x0542
    29a2:	96 89       	ldd	r25, Z+22	; 0x16
    29a4:	8e 85       	ldd	r24, Y+14	; 0x0e
    29a6:	89 17       	cp	r24, r25
    29a8:	30 f0       	brcs	.+12     	; 0x29b6 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    29aa:	8b 81       	ldd	r24, Y+3	; 0x03
    29ac:	9c 81       	ldd	r25, Y+4	; 0x04
    29ae:	90 93 42 05 	sts	0x0542, r25
    29b2:	80 93 41 05 	sts	0x0541, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    29b6:	80 91 4c 05 	lds	r24, 0x054C
    29ba:	8f 5f       	subi	r24, 0xFF	; 255
    29bc:	80 93 4c 05 	sts	0x054C, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    29c0:	eb 81       	ldd	r30, Y+3	; 0x03
    29c2:	fc 81       	ldd	r31, Y+4	; 0x04
    29c4:	96 89       	ldd	r25, Z+22	; 0x16
    29c6:	80 91 47 05 	lds	r24, 0x0547
    29ca:	89 17       	cp	r24, r25
    29cc:	28 f4       	brcc	.+10     	; 0x29d8 <xTaskGenericCreate+0x13a>
    29ce:	eb 81       	ldd	r30, Y+3	; 0x03
    29d0:	fc 81       	ldd	r31, Y+4	; 0x04
    29d2:	86 89       	ldd	r24, Z+22	; 0x16
    29d4:	80 93 47 05 	sts	0x0547, r24
    29d8:	eb 81       	ldd	r30, Y+3	; 0x03
    29da:	fc 81       	ldd	r31, Y+4	; 0x04
    29dc:	86 89       	ldd	r24, Z+22	; 0x16
    29de:	28 2f       	mov	r18, r24
    29e0:	30 e0       	ldi	r19, 0x00	; 0
    29e2:	c9 01       	movw	r24, r18
    29e4:	88 0f       	add	r24, r24
    29e6:	99 1f       	adc	r25, r25
    29e8:	88 0f       	add	r24, r24
    29ea:	99 1f       	adc	r25, r25
    29ec:	88 0f       	add	r24, r24
    29ee:	99 1f       	adc	r25, r25
    29f0:	82 0f       	add	r24, r18
    29f2:	93 1f       	adc	r25, r19
    29f4:	ac 01       	movw	r20, r24
    29f6:	42 5b       	subi	r20, 0xB2	; 178
    29f8:	5a 4f       	sbci	r21, 0xFA	; 250
    29fa:	8b 81       	ldd	r24, Y+3	; 0x03
    29fc:	9c 81       	ldd	r25, Y+4	; 0x04
    29fe:	9c 01       	movw	r18, r24
    2a00:	2e 5f       	subi	r18, 0xFE	; 254
    2a02:	3f 4f       	sbci	r19, 0xFF	; 255
    2a04:	ca 01       	movw	r24, r20
    2a06:	b9 01       	movw	r22, r18
    2a08:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

			xReturn = pdPASS;
    2a0c:	81 e0       	ldi	r24, 0x01	; 1
    2a0e:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2a10:	0f 90       	pop	r0
    2a12:	0f be       	out	0x3f, r0	; 63
    2a14:	02 c0       	rjmp	.+4      	; 0x2a1a <xTaskGenericCreate+0x17c>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2a16:	8f ef       	ldi	r24, 0xFF	; 255
    2a18:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    2a1a:	8d 81       	ldd	r24, Y+5	; 0x05
    2a1c:	81 30       	cpi	r24, 0x01	; 1
    2a1e:	71 f4       	brne	.+28     	; 0x2a3c <xTaskGenericCreate+0x19e>
	{
		if( xSchedulerRunning != pdFALSE )
    2a20:	80 91 48 05 	lds	r24, 0x0548
    2a24:	88 23       	and	r24, r24
    2a26:	51 f0       	breq	.+20     	; 0x2a3c <xTaskGenericCreate+0x19e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2a28:	e0 91 41 05 	lds	r30, 0x0541
    2a2c:	f0 91 42 05 	lds	r31, 0x0542
    2a30:	96 89       	ldd	r25, Z+22	; 0x16
    2a32:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a34:	98 17       	cp	r25, r24
    2a36:	10 f4       	brcc	.+4      	; 0x2a3c <xTaskGenericCreate+0x19e>
			{
				taskYIELD_IF_USING_PREEMPTION();
    2a38:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    2a3c:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2a3e:	64 96       	adiw	r28, 0x14	; 20
    2a40:	0f b6       	in	r0, 0x3f	; 63
    2a42:	f8 94       	cli
    2a44:	de bf       	out	0x3e, r29	; 62
    2a46:	0f be       	out	0x3f, r0	; 63
    2a48:	cd bf       	out	0x3d, r28	; 61
    2a4a:	cf 91       	pop	r28
    2a4c:	df 91       	pop	r29
    2a4e:	1f 91       	pop	r17
    2a50:	0f 91       	pop	r16
    2a52:	ff 90       	pop	r15
    2a54:	ef 90       	pop	r14
    2a56:	df 90       	pop	r13
    2a58:	cf 90       	pop	r12
    2a5a:	bf 90       	pop	r11
    2a5c:	af 90       	pop	r10
    2a5e:	08 95       	ret

00002a60 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    2a60:	df 93       	push	r29
    2a62:	cf 93       	push	r28
    2a64:	00 d0       	rcall	.+0      	; 0x2a66 <vTaskDelete+0x6>
    2a66:	00 d0       	rcall	.+0      	; 0x2a68 <vTaskDelete+0x8>
    2a68:	00 d0       	rcall	.+0      	; 0x2a6a <vTaskDelete+0xa>
    2a6a:	cd b7       	in	r28, 0x3d	; 61
    2a6c:	de b7       	in	r29, 0x3e	; 62
    2a6e:	9c 83       	std	Y+4, r25	; 0x04
    2a70:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2a72:	0f b6       	in	r0, 0x3f	; 63
    2a74:	f8 94       	cli
    2a76:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    2a78:	8b 81       	ldd	r24, Y+3	; 0x03
    2a7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a7c:	00 97       	sbiw	r24, 0x00	; 0
    2a7e:	39 f4       	brne	.+14     	; 0x2a8e <vTaskDelete+0x2e>
    2a80:	80 91 41 05 	lds	r24, 0x0541
    2a84:	90 91 42 05 	lds	r25, 0x0542
    2a88:	9e 83       	std	Y+6, r25	; 0x06
    2a8a:	8d 83       	std	Y+5, r24	; 0x05
    2a8c:	04 c0       	rjmp	.+8      	; 0x2a96 <vTaskDelete+0x36>
    2a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a90:	9c 81       	ldd	r25, Y+4	; 0x04
    2a92:	9e 83       	std	Y+6, r25	; 0x06
    2a94:	8d 83       	std	Y+5, r24	; 0x05
    2a96:	8d 81       	ldd	r24, Y+5	; 0x05
    2a98:	9e 81       	ldd	r25, Y+6	; 0x06
    2a9a:	9a 83       	std	Y+2, r25	; 0x02
    2a9c:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2a9e:	89 81       	ldd	r24, Y+1	; 0x01
    2aa0:	9a 81       	ldd	r25, Y+2	; 0x02
    2aa2:	02 96       	adiw	r24, 0x02	; 2
    2aa4:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    2aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    2aac:	84 89       	ldd	r24, Z+20	; 0x14
    2aae:	95 89       	ldd	r25, Z+21	; 0x15
    2ab0:	00 97       	sbiw	r24, 0x00	; 0
    2ab2:	29 f0       	breq	.+10     	; 0x2abe <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2ab4:	89 81       	ldd	r24, Y+1	; 0x01
    2ab6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ab8:	0c 96       	adiw	r24, 0x0c	; 12
    2aba:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2abe:	89 81       	ldd	r24, Y+1	; 0x01
    2ac0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ac2:	9c 01       	movw	r18, r24
    2ac4:	2e 5f       	subi	r18, 0xFE	; 254
    2ac6:	3f 4f       	sbci	r19, 0xFF	; 255
    2ac8:	81 e9       	ldi	r24, 0x91	; 145
    2aca:	95 e0       	ldi	r25, 0x05	; 5
    2acc:	b9 01       	movw	r22, r18
    2ace:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    2ad2:	80 91 43 05 	lds	r24, 0x0543
    2ad6:	8f 5f       	subi	r24, 0xFF	; 255
    2ad8:	80 93 43 05 	sts	0x0543, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    2adc:	80 91 4c 05 	lds	r24, 0x054C
    2ae0:	8f 5f       	subi	r24, 0xFF	; 255
    2ae2:	80 93 4c 05 	sts	0x054C, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2ae6:	0f 90       	pop	r0
    2ae8:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    2aea:	80 91 48 05 	lds	r24, 0x0548
    2aee:	88 23       	and	r24, r24
    2af0:	99 f0       	breq	.+38     	; 0x2b18 <vTaskDelete+0xb8>
		{
			if( pxTCB == pxCurrentTCB )
    2af2:	20 91 41 05 	lds	r18, 0x0541
    2af6:	30 91 42 05 	lds	r19, 0x0542
    2afa:	89 81       	ldd	r24, Y+1	; 0x01
    2afc:	9a 81       	ldd	r25, Y+2	; 0x02
    2afe:	82 17       	cp	r24, r18
    2b00:	93 07       	cpc	r25, r19
    2b02:	19 f4       	brne	.+6      	; 0x2b0a <vTaskDelete+0xaa>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    2b04:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    2b08:	07 c0       	rjmp	.+14     	; 0x2b18 <vTaskDelete+0xb8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    2b0a:	0f b6       	in	r0, 0x3f	; 63
    2b0c:	f8 94       	cli
    2b0e:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    2b10:	0e 94 0f 1d 	call	0x3a1e	; 0x3a1e <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    2b14:	0f 90       	pop	r0
    2b16:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    2b18:	26 96       	adiw	r28, 0x06	; 6
    2b1a:	0f b6       	in	r0, 0x3f	; 63
    2b1c:	f8 94       	cli
    2b1e:	de bf       	out	0x3e, r29	; 62
    2b20:	0f be       	out	0x3f, r0	; 63
    2b22:	cd bf       	out	0x3d, r28	; 61
    2b24:	cf 91       	pop	r28
    2b26:	df 91       	pop	r29
    2b28:	08 95       	ret

00002b2a <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2b2a:	df 93       	push	r29
    2b2c:	cf 93       	push	r28
    2b2e:	cd b7       	in	r28, 0x3d	; 61
    2b30:	de b7       	in	r29, 0x3e	; 62
    2b32:	2a 97       	sbiw	r28, 0x0a	; 10
    2b34:	0f b6       	in	r0, 0x3f	; 63
    2b36:	f8 94       	cli
    2b38:	de bf       	out	0x3e, r29	; 62
    2b3a:	0f be       	out	0x3f, r0	; 63
    2b3c:	cd bf       	out	0x3d, r28	; 61
    2b3e:	98 87       	std	Y+8, r25	; 0x08
    2b40:	8f 83       	std	Y+7, r24	; 0x07
    2b42:	7a 87       	std	Y+10, r23	; 0x0a
    2b44:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2b46:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2b48:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2b4c:	80 91 45 05 	lds	r24, 0x0545
    2b50:	90 91 46 05 	lds	r25, 0x0546
    2b54:	9a 83       	std	Y+2, r25	; 0x02
    2b56:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2b58:	ef 81       	ldd	r30, Y+7	; 0x07
    2b5a:	f8 85       	ldd	r31, Y+8	; 0x08
    2b5c:	20 81       	ld	r18, Z
    2b5e:	31 81       	ldd	r19, Z+1	; 0x01
    2b60:	89 85       	ldd	r24, Y+9	; 0x09
    2b62:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b64:	82 0f       	add	r24, r18
    2b66:	93 1f       	adc	r25, r19
    2b68:	9e 83       	std	Y+6, r25	; 0x06
    2b6a:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    2b6c:	ef 81       	ldd	r30, Y+7	; 0x07
    2b6e:	f8 85       	ldd	r31, Y+8	; 0x08
    2b70:	20 81       	ld	r18, Z
    2b72:	31 81       	ldd	r19, Z+1	; 0x01
    2b74:	89 81       	ldd	r24, Y+1	; 0x01
    2b76:	9a 81       	ldd	r25, Y+2	; 0x02
    2b78:	82 17       	cp	r24, r18
    2b7a:	93 07       	cpc	r25, r19
    2b7c:	98 f4       	brcc	.+38     	; 0x2ba4 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2b7e:	ef 81       	ldd	r30, Y+7	; 0x07
    2b80:	f8 85       	ldd	r31, Y+8	; 0x08
    2b82:	20 81       	ld	r18, Z
    2b84:	31 81       	ldd	r19, Z+1	; 0x01
    2b86:	8d 81       	ldd	r24, Y+5	; 0x05
    2b88:	9e 81       	ldd	r25, Y+6	; 0x06
    2b8a:	82 17       	cp	r24, r18
    2b8c:	93 07       	cpc	r25, r19
    2b8e:	e0 f4       	brcc	.+56     	; 0x2bc8 <vTaskDelayUntil+0x9e>
    2b90:	2d 81       	ldd	r18, Y+5	; 0x05
    2b92:	3e 81       	ldd	r19, Y+6	; 0x06
    2b94:	89 81       	ldd	r24, Y+1	; 0x01
    2b96:	9a 81       	ldd	r25, Y+2	; 0x02
    2b98:	82 17       	cp	r24, r18
    2b9a:	93 07       	cpc	r25, r19
    2b9c:	a8 f4       	brcc	.+42     	; 0x2bc8 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2b9e:	81 e0       	ldi	r24, 0x01	; 1
    2ba0:	8b 83       	std	Y+3, r24	; 0x03
    2ba2:	12 c0       	rjmp	.+36     	; 0x2bc8 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2ba4:	ef 81       	ldd	r30, Y+7	; 0x07
    2ba6:	f8 85       	ldd	r31, Y+8	; 0x08
    2ba8:	20 81       	ld	r18, Z
    2baa:	31 81       	ldd	r19, Z+1	; 0x01
    2bac:	8d 81       	ldd	r24, Y+5	; 0x05
    2bae:	9e 81       	ldd	r25, Y+6	; 0x06
    2bb0:	82 17       	cp	r24, r18
    2bb2:	93 07       	cpc	r25, r19
    2bb4:	38 f0       	brcs	.+14     	; 0x2bc4 <vTaskDelayUntil+0x9a>
    2bb6:	2d 81       	ldd	r18, Y+5	; 0x05
    2bb8:	3e 81       	ldd	r19, Y+6	; 0x06
    2bba:	89 81       	ldd	r24, Y+1	; 0x01
    2bbc:	9a 81       	ldd	r25, Y+2	; 0x02
    2bbe:	82 17       	cp	r24, r18
    2bc0:	93 07       	cpc	r25, r19
    2bc2:	10 f4       	brcc	.+4      	; 0x2bc8 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2bc4:	81 e0       	ldi	r24, 0x01	; 1
    2bc6:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2bc8:	ef 81       	ldd	r30, Y+7	; 0x07
    2bca:	f8 85       	ldd	r31, Y+8	; 0x08
    2bcc:	8d 81       	ldd	r24, Y+5	; 0x05
    2bce:	9e 81       	ldd	r25, Y+6	; 0x06
    2bd0:	91 83       	std	Z+1, r25	; 0x01
    2bd2:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2bd4:	8b 81       	ldd	r24, Y+3	; 0x03
    2bd6:	88 23       	and	r24, r24
    2bd8:	59 f0       	breq	.+22     	; 0x2bf0 <vTaskDelayUntil+0xc6>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2bda:	80 91 41 05 	lds	r24, 0x0541
    2bde:	90 91 42 05 	lds	r25, 0x0542
    2be2:	02 96       	adiw	r24, 0x02	; 2
    2be4:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2be8:	8d 81       	ldd	r24, Y+5	; 0x05
    2bea:	9e 81       	ldd	r25, Y+6	; 0x06
    2bec:	0e 94 6c 1c 	call	0x38d8	; 0x38d8 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2bf0:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>
    2bf4:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2bf6:	8c 81       	ldd	r24, Y+4	; 0x04
    2bf8:	88 23       	and	r24, r24
    2bfa:	11 f4       	brne	.+4      	; 0x2c00 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    2bfc:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2c00:	2a 96       	adiw	r28, 0x0a	; 10
    2c02:	0f b6       	in	r0, 0x3f	; 63
    2c04:	f8 94       	cli
    2c06:	de bf       	out	0x3e, r29	; 62
    2c08:	0f be       	out	0x3f, r0	; 63
    2c0a:	cd bf       	out	0x3d, r28	; 61
    2c0c:	cf 91       	pop	r28
    2c0e:	df 91       	pop	r29
    2c10:	08 95       	ret

00002c12 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2c12:	df 93       	push	r29
    2c14:	cf 93       	push	r28
    2c16:	00 d0       	rcall	.+0      	; 0x2c18 <vTaskDelay+0x6>
    2c18:	00 d0       	rcall	.+0      	; 0x2c1a <vTaskDelay+0x8>
    2c1a:	0f 92       	push	r0
    2c1c:	cd b7       	in	r28, 0x3d	; 61
    2c1e:	de b7       	in	r29, 0x3e	; 62
    2c20:	9d 83       	std	Y+5, r25	; 0x05
    2c22:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    2c24:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2c26:	8c 81       	ldd	r24, Y+4	; 0x04
    2c28:	9d 81       	ldd	r25, Y+5	; 0x05
    2c2a:	00 97       	sbiw	r24, 0x00	; 0
    2c2c:	d1 f0       	breq	.+52     	; 0x2c62 <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2c2e:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2c32:	20 91 45 05 	lds	r18, 0x0545
    2c36:	30 91 46 05 	lds	r19, 0x0546
    2c3a:	8c 81       	ldd	r24, Y+4	; 0x04
    2c3c:	9d 81       	ldd	r25, Y+5	; 0x05
    2c3e:	82 0f       	add	r24, r18
    2c40:	93 1f       	adc	r25, r19
    2c42:	9b 83       	std	Y+3, r25	; 0x03
    2c44:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2c46:	80 91 41 05 	lds	r24, 0x0541
    2c4a:	90 91 42 05 	lds	r25, 0x0542
    2c4e:	02 96       	adiw	r24, 0x02	; 2
    2c50:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2c54:	8a 81       	ldd	r24, Y+2	; 0x02
    2c56:	9b 81       	ldd	r25, Y+3	; 0x03
    2c58:	0e 94 6c 1c 	call	0x38d8	; 0x38d8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2c5c:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>
    2c60:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2c62:	89 81       	ldd	r24, Y+1	; 0x01
    2c64:	88 23       	and	r24, r24
    2c66:	11 f4       	brne	.+4      	; 0x2c6c <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    2c68:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2c6c:	0f 90       	pop	r0
    2c6e:	0f 90       	pop	r0
    2c70:	0f 90       	pop	r0
    2c72:	0f 90       	pop	r0
    2c74:	0f 90       	pop	r0
    2c76:	cf 91       	pop	r28
    2c78:	df 91       	pop	r29
    2c7a:	08 95       	ret

00002c7c <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
    2c7c:	df 93       	push	r29
    2c7e:	cf 93       	push	r28
    2c80:	cd b7       	in	r28, 0x3d	; 61
    2c82:	de b7       	in	r29, 0x3e	; 62
    2c84:	27 97       	sbiw	r28, 0x07	; 7
    2c86:	0f b6       	in	r0, 0x3f	; 63
    2c88:	f8 94       	cli
    2c8a:	de bf       	out	0x3e, r29	; 62
    2c8c:	0f be       	out	0x3f, r0	; 63
    2c8e:	cd bf       	out	0x3d, r28	; 61
    2c90:	9d 83       	std	Y+5, r25	; 0x05
    2c92:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    2c94:	0f b6       	in	r0, 0x3f	; 63
    2c96:	f8 94       	cli
    2c98:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
    2c9a:	8c 81       	ldd	r24, Y+4	; 0x04
    2c9c:	9d 81       	ldd	r25, Y+5	; 0x05
    2c9e:	00 97       	sbiw	r24, 0x00	; 0
    2ca0:	39 f4       	brne	.+14     	; 0x2cb0 <uxTaskPriorityGet+0x34>
    2ca2:	80 91 41 05 	lds	r24, 0x0541
    2ca6:	90 91 42 05 	lds	r25, 0x0542
    2caa:	9f 83       	std	Y+7, r25	; 0x07
    2cac:	8e 83       	std	Y+6, r24	; 0x06
    2cae:	04 c0       	rjmp	.+8      	; 0x2cb8 <uxTaskPriorityGet+0x3c>
    2cb0:	8c 81       	ldd	r24, Y+4	; 0x04
    2cb2:	9d 81       	ldd	r25, Y+5	; 0x05
    2cb4:	9f 83       	std	Y+7, r25	; 0x07
    2cb6:	8e 83       	std	Y+6, r24	; 0x06
    2cb8:	8e 81       	ldd	r24, Y+6	; 0x06
    2cba:	9f 81       	ldd	r25, Y+7	; 0x07
    2cbc:	9b 83       	std	Y+3, r25	; 0x03
    2cbe:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    2cc0:	ea 81       	ldd	r30, Y+2	; 0x02
    2cc2:	fb 81       	ldd	r31, Y+3	; 0x03
    2cc4:	86 89       	ldd	r24, Z+22	; 0x16
    2cc6:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    2cc8:	0f 90       	pop	r0
    2cca:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    2ccc:	89 81       	ldd	r24, Y+1	; 0x01
	}
    2cce:	27 96       	adiw	r28, 0x07	; 7
    2cd0:	0f b6       	in	r0, 0x3f	; 63
    2cd2:	f8 94       	cli
    2cd4:	de bf       	out	0x3e, r29	; 62
    2cd6:	0f be       	out	0x3f, r0	; 63
    2cd8:	cd bf       	out	0x3d, r28	; 61
    2cda:	cf 91       	pop	r28
    2cdc:	df 91       	pop	r29
    2cde:	08 95       	ret

00002ce0 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    2ce0:	df 93       	push	r29
    2ce2:	cf 93       	push	r28
    2ce4:	cd b7       	in	r28, 0x3d	; 61
    2ce6:	de b7       	in	r29, 0x3e	; 62
    2ce8:	2a 97       	sbiw	r28, 0x0a	; 10
    2cea:	0f b6       	in	r0, 0x3f	; 63
    2cec:	f8 94       	cli
    2cee:	de bf       	out	0x3e, r29	; 62
    2cf0:	0f be       	out	0x3f, r0	; 63
    2cf2:	cd bf       	out	0x3d, r28	; 61
    2cf4:	9f 83       	std	Y+7, r25	; 0x07
    2cf6:	8e 83       	std	Y+6, r24	; 0x06
    2cf8:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    2cfa:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2cfc:	88 85       	ldd	r24, Y+8	; 0x08
    2cfe:	84 30       	cpi	r24, 0x04	; 4
    2d00:	10 f0       	brcs	.+4      	; 0x2d06 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2d02:	83 e0       	ldi	r24, 0x03	; 3
    2d04:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    2d06:	0f b6       	in	r0, 0x3f	; 63
    2d08:	f8 94       	cli
    2d0a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    2d0c:	8e 81       	ldd	r24, Y+6	; 0x06
    2d0e:	9f 81       	ldd	r25, Y+7	; 0x07
    2d10:	00 97       	sbiw	r24, 0x00	; 0
    2d12:	39 f4       	brne	.+14     	; 0x2d22 <vTaskPrioritySet+0x42>
    2d14:	80 91 41 05 	lds	r24, 0x0541
    2d18:	90 91 42 05 	lds	r25, 0x0542
    2d1c:	9a 87       	std	Y+10, r25	; 0x0a
    2d1e:	89 87       	std	Y+9, r24	; 0x09
    2d20:	04 c0       	rjmp	.+8      	; 0x2d2a <vTaskPrioritySet+0x4a>
    2d22:	8e 81       	ldd	r24, Y+6	; 0x06
    2d24:	9f 81       	ldd	r25, Y+7	; 0x07
    2d26:	9a 87       	std	Y+10, r25	; 0x0a
    2d28:	89 87       	std	Y+9, r24	; 0x09
    2d2a:	89 85       	ldd	r24, Y+9	; 0x09
    2d2c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d2e:	9d 83       	std	Y+5, r25	; 0x05
    2d30:	8c 83       	std	Y+4, r24	; 0x04

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    2d32:	ec 81       	ldd	r30, Y+4	; 0x04
    2d34:	fd 81       	ldd	r31, Y+5	; 0x05
    2d36:	85 a5       	ldd	r24, Z+45	; 0x2d
    2d38:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    2d3a:	9b 81       	ldd	r25, Y+3	; 0x03
    2d3c:	88 85       	ldd	r24, Y+8	; 0x08
    2d3e:	98 17       	cp	r25, r24
    2d40:	09 f4       	brne	.+2      	; 0x2d44 <vTaskPrioritySet+0x64>
    2d42:	8d c0       	rjmp	.+282    	; 0x2e5e <vTaskPrioritySet+0x17e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    2d44:	98 85       	ldd	r25, Y+8	; 0x08
    2d46:	8b 81       	ldd	r24, Y+3	; 0x03
    2d48:	89 17       	cp	r24, r25
    2d4a:	a0 f4       	brcc	.+40     	; 0x2d74 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    2d4c:	20 91 41 05 	lds	r18, 0x0541
    2d50:	30 91 42 05 	lds	r19, 0x0542
    2d54:	8c 81       	ldd	r24, Y+4	; 0x04
    2d56:	9d 81       	ldd	r25, Y+5	; 0x05
    2d58:	82 17       	cp	r24, r18
    2d5a:	93 07       	cpc	r25, r19
    2d5c:	b1 f0       	breq	.+44     	; 0x2d8a <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    2d5e:	e0 91 41 05 	lds	r30, 0x0541
    2d62:	f0 91 42 05 	lds	r31, 0x0542
    2d66:	96 89       	ldd	r25, Z+22	; 0x16
    2d68:	88 85       	ldd	r24, Y+8	; 0x08
    2d6a:	89 17       	cp	r24, r25
    2d6c:	70 f0       	brcs	.+28     	; 0x2d8a <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    2d6e:	81 e0       	ldi	r24, 0x01	; 1
    2d70:	89 83       	std	Y+1, r24	; 0x01
    2d72:	0b c0       	rjmp	.+22     	; 0x2d8a <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    2d74:	20 91 41 05 	lds	r18, 0x0541
    2d78:	30 91 42 05 	lds	r19, 0x0542
    2d7c:	8c 81       	ldd	r24, Y+4	; 0x04
    2d7e:	9d 81       	ldd	r25, Y+5	; 0x05
    2d80:	82 17       	cp	r24, r18
    2d82:	93 07       	cpc	r25, r19
    2d84:	11 f4       	brne	.+4      	; 0x2d8a <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    2d86:	81 e0       	ldi	r24, 0x01	; 1
    2d88:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    2d8a:	ec 81       	ldd	r30, Y+4	; 0x04
    2d8c:	fd 81       	ldd	r31, Y+5	; 0x05
    2d8e:	86 89       	ldd	r24, Z+22	; 0x16
    2d90:	8a 83       	std	Y+2, r24	; 0x02

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    2d92:	ec 81       	ldd	r30, Y+4	; 0x04
    2d94:	fd 81       	ldd	r31, Y+5	; 0x05
    2d96:	95 a5       	ldd	r25, Z+45	; 0x2d
    2d98:	ec 81       	ldd	r30, Y+4	; 0x04
    2d9a:	fd 81       	ldd	r31, Y+5	; 0x05
    2d9c:	86 89       	ldd	r24, Z+22	; 0x16
    2d9e:	98 17       	cp	r25, r24
    2da0:	21 f4       	brne	.+8      	; 0x2daa <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    2da2:	ec 81       	ldd	r30, Y+4	; 0x04
    2da4:	fd 81       	ldd	r31, Y+5	; 0x05
    2da6:	88 85       	ldd	r24, Y+8	; 0x08
    2da8:	86 8b       	std	Z+22, r24	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    2daa:	ec 81       	ldd	r30, Y+4	; 0x04
    2dac:	fd 81       	ldd	r31, Y+5	; 0x05
    2dae:	88 85       	ldd	r24, Y+8	; 0x08
    2db0:	85 a7       	std	Z+45, r24	; 0x2d
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2db2:	ec 81       	ldd	r30, Y+4	; 0x04
    2db4:	fd 81       	ldd	r31, Y+5	; 0x05
    2db6:	84 85       	ldd	r24, Z+12	; 0x0c
    2db8:	95 85       	ldd	r25, Z+13	; 0x0d
    2dba:	99 23       	and	r25, r25
    2dbc:	5c f0       	brlt	.+22     	; 0x2dd4 <vTaskPrioritySet+0xf4>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2dbe:	88 85       	ldd	r24, Y+8	; 0x08
    2dc0:	28 2f       	mov	r18, r24
    2dc2:	30 e0       	ldi	r19, 0x00	; 0
    2dc4:	84 e0       	ldi	r24, 0x04	; 4
    2dc6:	90 e0       	ldi	r25, 0x00	; 0
    2dc8:	82 1b       	sub	r24, r18
    2dca:	93 0b       	sbc	r25, r19
    2dcc:	ec 81       	ldd	r30, Y+4	; 0x04
    2dce:	fd 81       	ldd	r31, Y+5	; 0x05
    2dd0:	95 87       	std	Z+13, r25	; 0x0d
    2dd2:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2dd4:	ec 81       	ldd	r30, Y+4	; 0x04
    2dd6:	fd 81       	ldd	r31, Y+5	; 0x05
    2dd8:	42 85       	ldd	r20, Z+10	; 0x0a
    2dda:	53 85       	ldd	r21, Z+11	; 0x0b
    2ddc:	8a 81       	ldd	r24, Y+2	; 0x02
    2dde:	28 2f       	mov	r18, r24
    2de0:	30 e0       	ldi	r19, 0x00	; 0
    2de2:	c9 01       	movw	r24, r18
    2de4:	88 0f       	add	r24, r24
    2de6:	99 1f       	adc	r25, r25
    2de8:	88 0f       	add	r24, r24
    2dea:	99 1f       	adc	r25, r25
    2dec:	88 0f       	add	r24, r24
    2dee:	99 1f       	adc	r25, r25
    2df0:	82 0f       	add	r24, r18
    2df2:	93 1f       	adc	r25, r19
    2df4:	82 5b       	subi	r24, 0xB2	; 178
    2df6:	9a 4f       	sbci	r25, 0xFA	; 250
    2df8:	48 17       	cp	r20, r24
    2dfa:	59 07       	cpc	r21, r25
    2dfc:	59 f5       	brne	.+86     	; 0x2e54 <vTaskPrioritySet+0x174>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2dfe:	8c 81       	ldd	r24, Y+4	; 0x04
    2e00:	9d 81       	ldd	r25, Y+5	; 0x05
    2e02:	02 96       	adiw	r24, 0x02	; 2
    2e04:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    2e08:	ec 81       	ldd	r30, Y+4	; 0x04
    2e0a:	fd 81       	ldd	r31, Y+5	; 0x05
    2e0c:	96 89       	ldd	r25, Z+22	; 0x16
    2e0e:	80 91 47 05 	lds	r24, 0x0547
    2e12:	89 17       	cp	r24, r25
    2e14:	28 f4       	brcc	.+10     	; 0x2e20 <vTaskPrioritySet+0x140>
    2e16:	ec 81       	ldd	r30, Y+4	; 0x04
    2e18:	fd 81       	ldd	r31, Y+5	; 0x05
    2e1a:	86 89       	ldd	r24, Z+22	; 0x16
    2e1c:	80 93 47 05 	sts	0x0547, r24
    2e20:	ec 81       	ldd	r30, Y+4	; 0x04
    2e22:	fd 81       	ldd	r31, Y+5	; 0x05
    2e24:	86 89       	ldd	r24, Z+22	; 0x16
    2e26:	28 2f       	mov	r18, r24
    2e28:	30 e0       	ldi	r19, 0x00	; 0
    2e2a:	c9 01       	movw	r24, r18
    2e2c:	88 0f       	add	r24, r24
    2e2e:	99 1f       	adc	r25, r25
    2e30:	88 0f       	add	r24, r24
    2e32:	99 1f       	adc	r25, r25
    2e34:	88 0f       	add	r24, r24
    2e36:	99 1f       	adc	r25, r25
    2e38:	82 0f       	add	r24, r18
    2e3a:	93 1f       	adc	r25, r19
    2e3c:	ac 01       	movw	r20, r24
    2e3e:	42 5b       	subi	r20, 0xB2	; 178
    2e40:	5a 4f       	sbci	r21, 0xFA	; 250
    2e42:	8c 81       	ldd	r24, Y+4	; 0x04
    2e44:	9d 81       	ldd	r25, Y+5	; 0x05
    2e46:	9c 01       	movw	r18, r24
    2e48:	2e 5f       	subi	r18, 0xFE	; 254
    2e4a:	3f 4f       	sbci	r19, 0xFF	; 255
    2e4c:	ca 01       	movw	r24, r20
    2e4e:	b9 01       	movw	r22, r18
    2e50:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
    2e54:	89 81       	ldd	r24, Y+1	; 0x01
    2e56:	81 30       	cpi	r24, 0x01	; 1
    2e58:	11 f4       	brne	.+4      	; 0x2e5e <vTaskPrioritySet+0x17e>
				{
					taskYIELD_IF_USING_PREEMPTION();
    2e5a:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    2e5e:	0f 90       	pop	r0
    2e60:	0f be       	out	0x3f, r0	; 63
	}
    2e62:	2a 96       	adiw	r28, 0x0a	; 10
    2e64:	0f b6       	in	r0, 0x3f	; 63
    2e66:	f8 94       	cli
    2e68:	de bf       	out	0x3e, r29	; 62
    2e6a:	0f be       	out	0x3f, r0	; 63
    2e6c:	cd bf       	out	0x3d, r28	; 61
    2e6e:	cf 91       	pop	r28
    2e70:	df 91       	pop	r29
    2e72:	08 95       	ret

00002e74 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2e74:	af 92       	push	r10
    2e76:	bf 92       	push	r11
    2e78:	cf 92       	push	r12
    2e7a:	df 92       	push	r13
    2e7c:	ef 92       	push	r14
    2e7e:	ff 92       	push	r15
    2e80:	0f 93       	push	r16
    2e82:	df 93       	push	r29
    2e84:	cf 93       	push	r28
    2e86:	0f 92       	push	r0
    2e88:	cd b7       	in	r28, 0x3d	; 61
    2e8a:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    2e8c:	86 e6       	ldi	r24, 0x66	; 102
    2e8e:	9b e1       	ldi	r25, 0x1B	; 27
    2e90:	28 e7       	ldi	r18, 0x78	; 120
    2e92:	30 e0       	ldi	r19, 0x00	; 0
    2e94:	b9 01       	movw	r22, r18
    2e96:	45 e5       	ldi	r20, 0x55	; 85
    2e98:	50 e0       	ldi	r21, 0x00	; 0
    2e9a:	20 e0       	ldi	r18, 0x00	; 0
    2e9c:	30 e0       	ldi	r19, 0x00	; 0
    2e9e:	00 e0       	ldi	r16, 0x00	; 0
    2ea0:	ee 24       	eor	r14, r14
    2ea2:	ff 24       	eor	r15, r15
    2ea4:	cc 24       	eor	r12, r12
    2ea6:	dd 24       	eor	r13, r13
    2ea8:	aa 24       	eor	r10, r10
    2eaa:	bb 24       	eor	r11, r11
    2eac:	0e 94 4f 14 	call	0x289e	; 0x289e <xTaskGenericCreate>
    2eb0:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    2eb2:	89 81       	ldd	r24, Y+1	; 0x01
    2eb4:	81 30       	cpi	r24, 0x01	; 1
    2eb6:	51 f4       	brne	.+20     	; 0x2ecc <vTaskStartScheduler+0x58>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    2eb8:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    2eba:	81 e0       	ldi	r24, 0x01	; 1
    2ebc:	80 93 48 05 	sts	0x0548, r24
		xTickCount = ( TickType_t ) 0U;
    2ec0:	10 92 46 05 	sts	0x0546, r1
    2ec4:	10 92 45 05 	sts	0x0545, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2ec8:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    2ecc:	0f 90       	pop	r0
    2ece:	cf 91       	pop	r28
    2ed0:	df 91       	pop	r29
    2ed2:	0f 91       	pop	r16
    2ed4:	ff 90       	pop	r15
    2ed6:	ef 90       	pop	r14
    2ed8:	df 90       	pop	r13
    2eda:	cf 90       	pop	r12
    2edc:	bf 90       	pop	r11
    2ede:	af 90       	pop	r10
    2ee0:	08 95       	ret

00002ee2 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2ee2:	df 93       	push	r29
    2ee4:	cf 93       	push	r28
    2ee6:	cd b7       	in	r28, 0x3d	; 61
    2ee8:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2eea:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2eec:	10 92 48 05 	sts	0x0548, r1
	vPortEndScheduler();
    2ef0:	0e 94 87 0b 	call	0x170e	; 0x170e <vPortEndScheduler>
}
    2ef4:	cf 91       	pop	r28
    2ef6:	df 91       	pop	r29
    2ef8:	08 95       	ret

00002efa <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2efa:	df 93       	push	r29
    2efc:	cf 93       	push	r28
    2efe:	cd b7       	in	r28, 0x3d	; 61
    2f00:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    2f02:	80 91 4d 05 	lds	r24, 0x054D
    2f06:	8f 5f       	subi	r24, 0xFF	; 255
    2f08:	80 93 4d 05 	sts	0x054D, r24
}
    2f0c:	cf 91       	pop	r28
    2f0e:	df 91       	pop	r29
    2f10:	08 95       	ret

00002f12 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2f12:	df 93       	push	r29
    2f14:	cf 93       	push	r28
    2f16:	00 d0       	rcall	.+0      	; 0x2f18 <xTaskResumeAll+0x6>
    2f18:	0f 92       	push	r0
    2f1a:	cd b7       	in	r28, 0x3d	; 61
    2f1c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    2f1e:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2f20:	0f b6       	in	r0, 0x3f	; 63
    2f22:	f8 94       	cli
    2f24:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2f26:	80 91 4d 05 	lds	r24, 0x054D
    2f2a:	81 50       	subi	r24, 0x01	; 1
    2f2c:	80 93 4d 05 	sts	0x054D, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2f30:	80 91 4d 05 	lds	r24, 0x054D
    2f34:	88 23       	and	r24, r24
    2f36:	09 f0       	breq	.+2      	; 0x2f3a <xTaskResumeAll+0x28>
    2f38:	6d c0       	rjmp	.+218    	; 0x3014 <xTaskResumeAll+0x102>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2f3a:	80 91 44 05 	lds	r24, 0x0544
    2f3e:	88 23       	and	r24, r24
    2f40:	09 f4       	brne	.+2      	; 0x2f44 <xTaskResumeAll+0x32>
    2f42:	68 c0       	rjmp	.+208    	; 0x3014 <xTaskResumeAll+0x102>
    2f44:	45 c0       	rjmp	.+138    	; 0x2fd0 <xTaskResumeAll+0xbe>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    2f46:	e0 91 8d 05 	lds	r30, 0x058D
    2f4a:	f0 91 8e 05 	lds	r31, 0x058E
    2f4e:	86 81       	ldd	r24, Z+6	; 0x06
    2f50:	97 81       	ldd	r25, Z+7	; 0x07
    2f52:	9b 83       	std	Y+3, r25	; 0x03
    2f54:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2f56:	8a 81       	ldd	r24, Y+2	; 0x02
    2f58:	9b 81       	ldd	r25, Y+3	; 0x03
    2f5a:	0c 96       	adiw	r24, 0x0c	; 12
    2f5c:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2f60:	8a 81       	ldd	r24, Y+2	; 0x02
    2f62:	9b 81       	ldd	r25, Y+3	; 0x03
    2f64:	02 96       	adiw	r24, 0x02	; 2
    2f66:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2f6a:	ea 81       	ldd	r30, Y+2	; 0x02
    2f6c:	fb 81       	ldd	r31, Y+3	; 0x03
    2f6e:	96 89       	ldd	r25, Z+22	; 0x16
    2f70:	80 91 47 05 	lds	r24, 0x0547
    2f74:	89 17       	cp	r24, r25
    2f76:	28 f4       	brcc	.+10     	; 0x2f82 <xTaskResumeAll+0x70>
    2f78:	ea 81       	ldd	r30, Y+2	; 0x02
    2f7a:	fb 81       	ldd	r31, Y+3	; 0x03
    2f7c:	86 89       	ldd	r24, Z+22	; 0x16
    2f7e:	80 93 47 05 	sts	0x0547, r24
    2f82:	ea 81       	ldd	r30, Y+2	; 0x02
    2f84:	fb 81       	ldd	r31, Y+3	; 0x03
    2f86:	86 89       	ldd	r24, Z+22	; 0x16
    2f88:	28 2f       	mov	r18, r24
    2f8a:	30 e0       	ldi	r19, 0x00	; 0
    2f8c:	c9 01       	movw	r24, r18
    2f8e:	88 0f       	add	r24, r24
    2f90:	99 1f       	adc	r25, r25
    2f92:	88 0f       	add	r24, r24
    2f94:	99 1f       	adc	r25, r25
    2f96:	88 0f       	add	r24, r24
    2f98:	99 1f       	adc	r25, r25
    2f9a:	82 0f       	add	r24, r18
    2f9c:	93 1f       	adc	r25, r19
    2f9e:	ac 01       	movw	r20, r24
    2fa0:	42 5b       	subi	r20, 0xB2	; 178
    2fa2:	5a 4f       	sbci	r21, 0xFA	; 250
    2fa4:	8a 81       	ldd	r24, Y+2	; 0x02
    2fa6:	9b 81       	ldd	r25, Y+3	; 0x03
    2fa8:	9c 01       	movw	r18, r24
    2faa:	2e 5f       	subi	r18, 0xFE	; 254
    2fac:	3f 4f       	sbci	r19, 0xFF	; 255
    2fae:	ca 01       	movw	r24, r20
    2fb0:	b9 01       	movw	r22, r18
    2fb2:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2fb6:	ea 81       	ldd	r30, Y+2	; 0x02
    2fb8:	fb 81       	ldd	r31, Y+3	; 0x03
    2fba:	96 89       	ldd	r25, Z+22	; 0x16
    2fbc:	e0 91 41 05 	lds	r30, 0x0541
    2fc0:	f0 91 42 05 	lds	r31, 0x0542
    2fc4:	86 89       	ldd	r24, Z+22	; 0x16
    2fc6:	98 17       	cp	r25, r24
    2fc8:	18 f0       	brcs	.+6      	; 0x2fd0 <xTaskResumeAll+0xbe>
					{
						xYieldPending = pdTRUE;
    2fca:	81 e0       	ldi	r24, 0x01	; 1
    2fcc:	80 93 4a 05 	sts	0x054A, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2fd0:	80 91 88 05 	lds	r24, 0x0588
    2fd4:	88 23       	and	r24, r24
    2fd6:	09 f0       	breq	.+2      	; 0x2fda <xTaskResumeAll+0xc8>
    2fd8:	b6 cf       	rjmp	.-148    	; 0x2f46 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    2fda:	80 91 49 05 	lds	r24, 0x0549
    2fde:	88 23       	and	r24, r24
    2fe0:	89 f0       	breq	.+34     	; 0x3004 <xTaskResumeAll+0xf2>
    2fe2:	0c c0       	rjmp	.+24     	; 0x2ffc <xTaskResumeAll+0xea>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    2fe4:	0e 94 48 18 	call	0x3090	; 0x3090 <xTaskIncrementTick>
    2fe8:	88 23       	and	r24, r24
    2fea:	19 f0       	breq	.+6      	; 0x2ff2 <xTaskResumeAll+0xe0>
						{
							xYieldPending = pdTRUE;
    2fec:	81 e0       	ldi	r24, 0x01	; 1
    2fee:	80 93 4a 05 	sts	0x054A, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    2ff2:	80 91 49 05 	lds	r24, 0x0549
    2ff6:	81 50       	subi	r24, 0x01	; 1
    2ff8:	80 93 49 05 	sts	0x0549, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    2ffc:	80 91 49 05 	lds	r24, 0x0549
    3000:	88 23       	and	r24, r24
    3002:	81 f7       	brne	.-32     	; 0x2fe4 <xTaskResumeAll+0xd2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    3004:	80 91 4a 05 	lds	r24, 0x054A
    3008:	81 30       	cpi	r24, 0x01	; 1
    300a:	21 f4       	brne	.+8      	; 0x3014 <xTaskResumeAll+0x102>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    300c:	81 e0       	ldi	r24, 0x01	; 1
    300e:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3010:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3014:	0f 90       	pop	r0
    3016:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3018:	89 81       	ldd	r24, Y+1	; 0x01
}
    301a:	0f 90       	pop	r0
    301c:	0f 90       	pop	r0
    301e:	0f 90       	pop	r0
    3020:	cf 91       	pop	r28
    3022:	df 91       	pop	r29
    3024:	08 95       	ret

00003026 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3026:	df 93       	push	r29
    3028:	cf 93       	push	r28
    302a:	00 d0       	rcall	.+0      	; 0x302c <xTaskGetTickCount+0x6>
    302c:	cd b7       	in	r28, 0x3d	; 61
    302e:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    3030:	0f b6       	in	r0, 0x3f	; 63
    3032:	f8 94       	cli
    3034:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3036:	80 91 45 05 	lds	r24, 0x0545
    303a:	90 91 46 05 	lds	r25, 0x0546
    303e:	9a 83       	std	Y+2, r25	; 0x02
    3040:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3042:	0f 90       	pop	r0
    3044:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3046:	89 81       	ldd	r24, Y+1	; 0x01
    3048:	9a 81       	ldd	r25, Y+2	; 0x02
}
    304a:	0f 90       	pop	r0
    304c:	0f 90       	pop	r0
    304e:	cf 91       	pop	r28
    3050:	df 91       	pop	r29
    3052:	08 95       	ret

00003054 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3054:	df 93       	push	r29
    3056:	cf 93       	push	r28
    3058:	00 d0       	rcall	.+0      	; 0x305a <xTaskGetTickCountFromISR+0x6>
    305a:	0f 92       	push	r0
    305c:	cd b7       	in	r28, 0x3d	; 61
    305e:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3060:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    3062:	80 91 45 05 	lds	r24, 0x0545
    3066:	90 91 46 05 	lds	r25, 0x0546
    306a:	9b 83       	std	Y+3, r25	; 0x03
    306c:	8a 83       	std	Y+2, r24	; 0x02
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    306e:	8a 81       	ldd	r24, Y+2	; 0x02
    3070:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3072:	0f 90       	pop	r0
    3074:	0f 90       	pop	r0
    3076:	0f 90       	pop	r0
    3078:	cf 91       	pop	r28
    307a:	df 91       	pop	r29
    307c:	08 95       	ret

0000307e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    307e:	df 93       	push	r29
    3080:	cf 93       	push	r28
    3082:	cd b7       	in	r28, 0x3d	; 61
    3084:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    3086:	80 91 44 05 	lds	r24, 0x0544
}
    308a:	cf 91       	pop	r28
    308c:	df 91       	pop	r29
    308e:	08 95       	ret

00003090 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3090:	df 93       	push	r29
    3092:	cf 93       	push	r28
    3094:	cd b7       	in	r28, 0x3d	; 61
    3096:	de b7       	in	r29, 0x3e	; 62
    3098:	29 97       	sbiw	r28, 0x09	; 9
    309a:	0f b6       	in	r0, 0x3f	; 63
    309c:	f8 94       	cli
    309e:	de bf       	out	0x3e, r29	; 62
    30a0:	0f be       	out	0x3f, r0	; 63
    30a2:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    30a4:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    30a6:	80 91 4d 05 	lds	r24, 0x054D
    30aa:	88 23       	and	r24, r24
    30ac:	09 f0       	breq	.+2      	; 0x30b0 <xTaskIncrementTick+0x20>
    30ae:	c2 c0       	rjmp	.+388    	; 0x3234 <xTaskIncrementTick+0x1a4>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    30b0:	80 91 45 05 	lds	r24, 0x0545
    30b4:	90 91 46 05 	lds	r25, 0x0546
    30b8:	01 96       	adiw	r24, 0x01	; 1
    30ba:	90 93 46 05 	sts	0x0546, r25
    30be:	80 93 45 05 	sts	0x0545, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    30c2:	80 91 45 05 	lds	r24, 0x0545
    30c6:	90 91 46 05 	lds	r25, 0x0546
    30ca:	9c 83       	std	Y+4, r25	; 0x04
    30cc:	8b 83       	std	Y+3, r24	; 0x03

			if( xConstTickCount == ( TickType_t ) 0U )
    30ce:	8b 81       	ldd	r24, Y+3	; 0x03
    30d0:	9c 81       	ldd	r25, Y+4	; 0x04
    30d2:	00 97       	sbiw	r24, 0x00	; 0
    30d4:	d9 f4       	brne	.+54     	; 0x310c <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    30d6:	80 91 84 05 	lds	r24, 0x0584
    30da:	90 91 85 05 	lds	r25, 0x0585
    30de:	9a 83       	std	Y+2, r25	; 0x02
    30e0:	89 83       	std	Y+1, r24	; 0x01
    30e2:	80 91 86 05 	lds	r24, 0x0586
    30e6:	90 91 87 05 	lds	r25, 0x0587
    30ea:	90 93 85 05 	sts	0x0585, r25
    30ee:	80 93 84 05 	sts	0x0584, r24
    30f2:	89 81       	ldd	r24, Y+1	; 0x01
    30f4:	9a 81       	ldd	r25, Y+2	; 0x02
    30f6:	90 93 87 05 	sts	0x0587, r25
    30fa:	80 93 86 05 	sts	0x0586, r24
    30fe:	80 91 4b 05 	lds	r24, 0x054B
    3102:	8f 5f       	subi	r24, 0xFF	; 255
    3104:	80 93 4b 05 	sts	0x054B, r24
    3108:	0e 94 0f 1d 	call	0x3a1e	; 0x3a1e <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    310c:	20 91 7d 00 	lds	r18, 0x007D
    3110:	30 91 7e 00 	lds	r19, 0x007E
    3114:	8b 81       	ldd	r24, Y+3	; 0x03
    3116:	9c 81       	ldd	r25, Y+4	; 0x04
    3118:	82 17       	cp	r24, r18
    311a:	93 07       	cpc	r25, r19
    311c:	08 f4       	brcc	.+2      	; 0x3120 <xTaskIncrementTick+0x90>
    311e:	71 c0       	rjmp	.+226    	; 0x3202 <xTaskIncrementTick+0x172>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3120:	e0 91 84 05 	lds	r30, 0x0584
    3124:	f0 91 85 05 	lds	r31, 0x0585
    3128:	80 81       	ld	r24, Z
    312a:	88 23       	and	r24, r24
    312c:	39 f4       	brne	.+14     	; 0x313c <xTaskIncrementTick+0xac>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    312e:	8f ef       	ldi	r24, 0xFF	; 255
    3130:	9f ef       	ldi	r25, 0xFF	; 255
    3132:	90 93 7e 00 	sts	0x007E, r25
    3136:	80 93 7d 00 	sts	0x007D, r24
    313a:	63 c0       	rjmp	.+198    	; 0x3202 <xTaskIncrementTick+0x172>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    313c:	e0 91 84 05 	lds	r30, 0x0584
    3140:	f0 91 85 05 	lds	r31, 0x0585
    3144:	05 80       	ldd	r0, Z+5	; 0x05
    3146:	f6 81       	ldd	r31, Z+6	; 0x06
    3148:	e0 2d       	mov	r30, r0
    314a:	86 81       	ldd	r24, Z+6	; 0x06
    314c:	97 81       	ldd	r25, Z+7	; 0x07
    314e:	99 87       	std	Y+9, r25	; 0x09
    3150:	88 87       	std	Y+8, r24	; 0x08
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3152:	e8 85       	ldd	r30, Y+8	; 0x08
    3154:	f9 85       	ldd	r31, Y+9	; 0x09
    3156:	82 81       	ldd	r24, Z+2	; 0x02
    3158:	93 81       	ldd	r25, Z+3	; 0x03
    315a:	9f 83       	std	Y+7, r25	; 0x07
    315c:	8e 83       	std	Y+6, r24	; 0x06

						if( xConstTickCount < xItemValue )
    315e:	2b 81       	ldd	r18, Y+3	; 0x03
    3160:	3c 81       	ldd	r19, Y+4	; 0x04
    3162:	8e 81       	ldd	r24, Y+6	; 0x06
    3164:	9f 81       	ldd	r25, Y+7	; 0x07
    3166:	28 17       	cp	r18, r24
    3168:	39 07       	cpc	r19, r25
    316a:	38 f4       	brcc	.+14     	; 0x317a <xTaskIncrementTick+0xea>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    316c:	8e 81       	ldd	r24, Y+6	; 0x06
    316e:	9f 81       	ldd	r25, Y+7	; 0x07
    3170:	90 93 7e 00 	sts	0x007E, r25
    3174:	80 93 7d 00 	sts	0x007D, r24
    3178:	44 c0       	rjmp	.+136    	; 0x3202 <xTaskIncrementTick+0x172>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    317a:	88 85       	ldd	r24, Y+8	; 0x08
    317c:	99 85       	ldd	r25, Y+9	; 0x09
    317e:	02 96       	adiw	r24, 0x02	; 2
    3180:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3184:	e8 85       	ldd	r30, Y+8	; 0x08
    3186:	f9 85       	ldd	r31, Y+9	; 0x09
    3188:	84 89       	ldd	r24, Z+20	; 0x14
    318a:	95 89       	ldd	r25, Z+21	; 0x15
    318c:	00 97       	sbiw	r24, 0x00	; 0
    318e:	29 f0       	breq	.+10     	; 0x319a <xTaskIncrementTick+0x10a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3190:	88 85       	ldd	r24, Y+8	; 0x08
    3192:	99 85       	ldd	r25, Y+9	; 0x09
    3194:	0c 96       	adiw	r24, 0x0c	; 12
    3196:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    319a:	e8 85       	ldd	r30, Y+8	; 0x08
    319c:	f9 85       	ldd	r31, Y+9	; 0x09
    319e:	96 89       	ldd	r25, Z+22	; 0x16
    31a0:	80 91 47 05 	lds	r24, 0x0547
    31a4:	89 17       	cp	r24, r25
    31a6:	28 f4       	brcc	.+10     	; 0x31b2 <xTaskIncrementTick+0x122>
    31a8:	e8 85       	ldd	r30, Y+8	; 0x08
    31aa:	f9 85       	ldd	r31, Y+9	; 0x09
    31ac:	86 89       	ldd	r24, Z+22	; 0x16
    31ae:	80 93 47 05 	sts	0x0547, r24
    31b2:	e8 85       	ldd	r30, Y+8	; 0x08
    31b4:	f9 85       	ldd	r31, Y+9	; 0x09
    31b6:	86 89       	ldd	r24, Z+22	; 0x16
    31b8:	28 2f       	mov	r18, r24
    31ba:	30 e0       	ldi	r19, 0x00	; 0
    31bc:	c9 01       	movw	r24, r18
    31be:	88 0f       	add	r24, r24
    31c0:	99 1f       	adc	r25, r25
    31c2:	88 0f       	add	r24, r24
    31c4:	99 1f       	adc	r25, r25
    31c6:	88 0f       	add	r24, r24
    31c8:	99 1f       	adc	r25, r25
    31ca:	82 0f       	add	r24, r18
    31cc:	93 1f       	adc	r25, r19
    31ce:	ac 01       	movw	r20, r24
    31d0:	42 5b       	subi	r20, 0xB2	; 178
    31d2:	5a 4f       	sbci	r21, 0xFA	; 250
    31d4:	88 85       	ldd	r24, Y+8	; 0x08
    31d6:	99 85       	ldd	r25, Y+9	; 0x09
    31d8:	9c 01       	movw	r18, r24
    31da:	2e 5f       	subi	r18, 0xFE	; 254
    31dc:	3f 4f       	sbci	r19, 0xFF	; 255
    31de:	ca 01       	movw	r24, r20
    31e0:	b9 01       	movw	r22, r18
    31e2:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    31e6:	e8 85       	ldd	r30, Y+8	; 0x08
    31e8:	f9 85       	ldd	r31, Y+9	; 0x09
    31ea:	96 89       	ldd	r25, Z+22	; 0x16
    31ec:	e0 91 41 05 	lds	r30, 0x0541
    31f0:	f0 91 42 05 	lds	r31, 0x0542
    31f4:	86 89       	ldd	r24, Z+22	; 0x16
    31f6:	98 17       	cp	r25, r24
    31f8:	08 f4       	brcc	.+2      	; 0x31fc <xTaskIncrementTick+0x16c>
    31fa:	92 cf       	rjmp	.-220    	; 0x3120 <xTaskIncrementTick+0x90>
							{
								xSwitchRequired = pdTRUE;
    31fc:	81 e0       	ldi	r24, 0x01	; 1
    31fe:	8d 83       	std	Y+5, r24	; 0x05
    3200:	8f cf       	rjmp	.-226    	; 0x3120 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3202:	e0 91 41 05 	lds	r30, 0x0541
    3206:	f0 91 42 05 	lds	r31, 0x0542
    320a:	86 89       	ldd	r24, Z+22	; 0x16
    320c:	28 2f       	mov	r18, r24
    320e:	30 e0       	ldi	r19, 0x00	; 0
    3210:	c9 01       	movw	r24, r18
    3212:	88 0f       	add	r24, r24
    3214:	99 1f       	adc	r25, r25
    3216:	88 0f       	add	r24, r24
    3218:	99 1f       	adc	r25, r25
    321a:	88 0f       	add	r24, r24
    321c:	99 1f       	adc	r25, r25
    321e:	82 0f       	add	r24, r18
    3220:	93 1f       	adc	r25, r19
    3222:	fc 01       	movw	r30, r24
    3224:	e2 5b       	subi	r30, 0xB2	; 178
    3226:	fa 4f       	sbci	r31, 0xFA	; 250
    3228:	80 81       	ld	r24, Z
    322a:	82 30       	cpi	r24, 0x02	; 2
    322c:	40 f0       	brcs	.+16     	; 0x323e <xTaskIncrementTick+0x1ae>
			{
				xSwitchRequired = pdTRUE;
    322e:	81 e0       	ldi	r24, 0x01	; 1
    3230:	8d 83       	std	Y+5, r24	; 0x05
    3232:	05 c0       	rjmp	.+10     	; 0x323e <xTaskIncrementTick+0x1ae>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    3234:	80 91 49 05 	lds	r24, 0x0549
    3238:	8f 5f       	subi	r24, 0xFF	; 255
    323a:	80 93 49 05 	sts	0x0549, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    323e:	80 91 4a 05 	lds	r24, 0x054A
    3242:	88 23       	and	r24, r24
    3244:	11 f0       	breq	.+4      	; 0x324a <xTaskIncrementTick+0x1ba>
		{
			xSwitchRequired = pdTRUE;
    3246:	81 e0       	ldi	r24, 0x01	; 1
    3248:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    324a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    324c:	29 96       	adiw	r28, 0x09	; 9
    324e:	0f b6       	in	r0, 0x3f	; 63
    3250:	f8 94       	cli
    3252:	de bf       	out	0x3e, r29	; 62
    3254:	0f be       	out	0x3f, r0	; 63
    3256:	cd bf       	out	0x3d, r28	; 61
    3258:	cf 91       	pop	r28
    325a:	df 91       	pop	r29
    325c:	08 95       	ret

0000325e <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    325e:	df 93       	push	r29
    3260:	cf 93       	push	r28
    3262:	00 d0       	rcall	.+0      	; 0x3264 <vTaskSwitchContext+0x6>
    3264:	cd b7       	in	r28, 0x3d	; 61
    3266:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3268:	80 91 4d 05 	lds	r24, 0x054D
    326c:	88 23       	and	r24, r24
    326e:	21 f0       	breq	.+8      	; 0x3278 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3270:	81 e0       	ldi	r24, 0x01	; 1
    3272:	80 93 4a 05 	sts	0x054A, r24
    3276:	57 c0       	rjmp	.+174    	; 0x3326 <vTaskSwitchContext+0xc8>
	}
	else
	{
		xYieldPending = pdFALSE;
    3278:	10 92 4a 05 	sts	0x054A, r1
    327c:	05 c0       	rjmp	.+10     	; 0x3288 <vTaskSwitchContext+0x2a>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    327e:	80 91 47 05 	lds	r24, 0x0547
    3282:	81 50       	subi	r24, 0x01	; 1
    3284:	80 93 47 05 	sts	0x0547, r24
    3288:	80 91 47 05 	lds	r24, 0x0547
    328c:	28 2f       	mov	r18, r24
    328e:	30 e0       	ldi	r19, 0x00	; 0
    3290:	c9 01       	movw	r24, r18
    3292:	88 0f       	add	r24, r24
    3294:	99 1f       	adc	r25, r25
    3296:	88 0f       	add	r24, r24
    3298:	99 1f       	adc	r25, r25
    329a:	88 0f       	add	r24, r24
    329c:	99 1f       	adc	r25, r25
    329e:	82 0f       	add	r24, r18
    32a0:	93 1f       	adc	r25, r19
    32a2:	fc 01       	movw	r30, r24
    32a4:	e2 5b       	subi	r30, 0xB2	; 178
    32a6:	fa 4f       	sbci	r31, 0xFA	; 250
    32a8:	80 81       	ld	r24, Z
    32aa:	88 23       	and	r24, r24
    32ac:	41 f3       	breq	.-48     	; 0x327e <vTaskSwitchContext+0x20>
    32ae:	80 91 47 05 	lds	r24, 0x0547
    32b2:	28 2f       	mov	r18, r24
    32b4:	30 e0       	ldi	r19, 0x00	; 0
    32b6:	c9 01       	movw	r24, r18
    32b8:	88 0f       	add	r24, r24
    32ba:	99 1f       	adc	r25, r25
    32bc:	88 0f       	add	r24, r24
    32be:	99 1f       	adc	r25, r25
    32c0:	88 0f       	add	r24, r24
    32c2:	99 1f       	adc	r25, r25
    32c4:	82 0f       	add	r24, r18
    32c6:	93 1f       	adc	r25, r19
    32c8:	82 5b       	subi	r24, 0xB2	; 178
    32ca:	9a 4f       	sbci	r25, 0xFA	; 250
    32cc:	9a 83       	std	Y+2, r25	; 0x02
    32ce:	89 83       	std	Y+1, r24	; 0x01
    32d0:	e9 81       	ldd	r30, Y+1	; 0x01
    32d2:	fa 81       	ldd	r31, Y+2	; 0x02
    32d4:	01 80       	ldd	r0, Z+1	; 0x01
    32d6:	f2 81       	ldd	r31, Z+2	; 0x02
    32d8:	e0 2d       	mov	r30, r0
    32da:	82 81       	ldd	r24, Z+2	; 0x02
    32dc:	93 81       	ldd	r25, Z+3	; 0x03
    32de:	e9 81       	ldd	r30, Y+1	; 0x01
    32e0:	fa 81       	ldd	r31, Y+2	; 0x02
    32e2:	92 83       	std	Z+2, r25	; 0x02
    32e4:	81 83       	std	Z+1, r24	; 0x01
    32e6:	e9 81       	ldd	r30, Y+1	; 0x01
    32e8:	fa 81       	ldd	r31, Y+2	; 0x02
    32ea:	21 81       	ldd	r18, Z+1	; 0x01
    32ec:	32 81       	ldd	r19, Z+2	; 0x02
    32ee:	89 81       	ldd	r24, Y+1	; 0x01
    32f0:	9a 81       	ldd	r25, Y+2	; 0x02
    32f2:	03 96       	adiw	r24, 0x03	; 3
    32f4:	28 17       	cp	r18, r24
    32f6:	39 07       	cpc	r19, r25
    32f8:	59 f4       	brne	.+22     	; 0x3310 <vTaskSwitchContext+0xb2>
    32fa:	e9 81       	ldd	r30, Y+1	; 0x01
    32fc:	fa 81       	ldd	r31, Y+2	; 0x02
    32fe:	01 80       	ldd	r0, Z+1	; 0x01
    3300:	f2 81       	ldd	r31, Z+2	; 0x02
    3302:	e0 2d       	mov	r30, r0
    3304:	82 81       	ldd	r24, Z+2	; 0x02
    3306:	93 81       	ldd	r25, Z+3	; 0x03
    3308:	e9 81       	ldd	r30, Y+1	; 0x01
    330a:	fa 81       	ldd	r31, Y+2	; 0x02
    330c:	92 83       	std	Z+2, r25	; 0x02
    330e:	81 83       	std	Z+1, r24	; 0x01
    3310:	e9 81       	ldd	r30, Y+1	; 0x01
    3312:	fa 81       	ldd	r31, Y+2	; 0x02
    3314:	01 80       	ldd	r0, Z+1	; 0x01
    3316:	f2 81       	ldd	r31, Z+2	; 0x02
    3318:	e0 2d       	mov	r30, r0
    331a:	86 81       	ldd	r24, Z+6	; 0x06
    331c:	97 81       	ldd	r25, Z+7	; 0x07
    331e:	90 93 42 05 	sts	0x0542, r25
    3322:	80 93 41 05 	sts	0x0541, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3326:	0f 90       	pop	r0
    3328:	0f 90       	pop	r0
    332a:	cf 91       	pop	r28
    332c:	df 91       	pop	r29
    332e:	08 95       	ret

00003330 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3330:	df 93       	push	r29
    3332:	cf 93       	push	r28
    3334:	00 d0       	rcall	.+0      	; 0x3336 <vTaskPlaceOnEventList+0x6>
    3336:	00 d0       	rcall	.+0      	; 0x3338 <vTaskPlaceOnEventList+0x8>
    3338:	00 d0       	rcall	.+0      	; 0x333a <vTaskPlaceOnEventList+0xa>
    333a:	cd b7       	in	r28, 0x3d	; 61
    333c:	de b7       	in	r29, 0x3e	; 62
    333e:	9c 83       	std	Y+4, r25	; 0x04
    3340:	8b 83       	std	Y+3, r24	; 0x03
    3342:	7e 83       	std	Y+6, r23	; 0x06
    3344:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3346:	80 91 41 05 	lds	r24, 0x0541
    334a:	90 91 42 05 	lds	r25, 0x0542
    334e:	9c 01       	movw	r18, r24
    3350:	24 5f       	subi	r18, 0xF4	; 244
    3352:	3f 4f       	sbci	r19, 0xFF	; 255
    3354:	8b 81       	ldd	r24, Y+3	; 0x03
    3356:	9c 81       	ldd	r25, Y+4	; 0x04
    3358:	b9 01       	movw	r22, r18
    335a:	0e 94 17 09 	call	0x122e	; 0x122e <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    335e:	80 91 41 05 	lds	r24, 0x0541
    3362:	90 91 42 05 	lds	r25, 0x0542
    3366:	02 96       	adiw	r24, 0x02	; 2
    3368:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    336c:	20 91 45 05 	lds	r18, 0x0545
    3370:	30 91 46 05 	lds	r19, 0x0546
    3374:	8d 81       	ldd	r24, Y+5	; 0x05
    3376:	9e 81       	ldd	r25, Y+6	; 0x06
    3378:	82 0f       	add	r24, r18
    337a:	93 1f       	adc	r25, r19
    337c:	9a 83       	std	Y+2, r25	; 0x02
    337e:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3380:	89 81       	ldd	r24, Y+1	; 0x01
    3382:	9a 81       	ldd	r25, Y+2	; 0x02
    3384:	0e 94 6c 1c 	call	0x38d8	; 0x38d8 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3388:	26 96       	adiw	r28, 0x06	; 6
    338a:	0f b6       	in	r0, 0x3f	; 63
    338c:	f8 94       	cli
    338e:	de bf       	out	0x3e, r29	; 62
    3390:	0f be       	out	0x3f, r0	; 63
    3392:	cd bf       	out	0x3d, r28	; 61
    3394:	cf 91       	pop	r28
    3396:	df 91       	pop	r29
    3398:	08 95       	ret

0000339a <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    339a:	df 93       	push	r29
    339c:	cf 93       	push	r28
    339e:	cd b7       	in	r28, 0x3d	; 61
    33a0:	de b7       	in	r29, 0x3e	; 62
    33a2:	28 97       	sbiw	r28, 0x08	; 8
    33a4:	0f b6       	in	r0, 0x3f	; 63
    33a6:	f8 94       	cli
    33a8:	de bf       	out	0x3e, r29	; 62
    33aa:	0f be       	out	0x3f, r0	; 63
    33ac:	cd bf       	out	0x3d, r28	; 61
    33ae:	9c 83       	std	Y+4, r25	; 0x04
    33b0:	8b 83       	std	Y+3, r24	; 0x03
    33b2:	7e 83       	std	Y+6, r23	; 0x06
    33b4:	6d 83       	std	Y+5, r22	; 0x05
    33b6:	58 87       	std	Y+8, r21	; 0x08
    33b8:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    33ba:	e0 91 41 05 	lds	r30, 0x0541
    33be:	f0 91 42 05 	lds	r31, 0x0542
    33c2:	8d 81       	ldd	r24, Y+5	; 0x05
    33c4:	9e 81       	ldd	r25, Y+6	; 0x06
    33c6:	90 68       	ori	r25, 0x80	; 128
    33c8:	95 87       	std	Z+13, r25	; 0x0d
    33ca:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    33cc:	80 91 41 05 	lds	r24, 0x0541
    33d0:	90 91 42 05 	lds	r25, 0x0542
    33d4:	9c 01       	movw	r18, r24
    33d6:	24 5f       	subi	r18, 0xF4	; 244
    33d8:	3f 4f       	sbci	r19, 0xFF	; 255
    33da:	8b 81       	ldd	r24, Y+3	; 0x03
    33dc:	9c 81       	ldd	r25, Y+4	; 0x04
    33de:	b9 01       	movw	r22, r18
    33e0:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    33e4:	80 91 41 05 	lds	r24, 0x0541
    33e8:	90 91 42 05 	lds	r25, 0x0542
    33ec:	02 96       	adiw	r24, 0x02	; 2
    33ee:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    33f2:	20 91 45 05 	lds	r18, 0x0545
    33f6:	30 91 46 05 	lds	r19, 0x0546
    33fa:	8f 81       	ldd	r24, Y+7	; 0x07
    33fc:	98 85       	ldd	r25, Y+8	; 0x08
    33fe:	82 0f       	add	r24, r18
    3400:	93 1f       	adc	r25, r19
    3402:	9a 83       	std	Y+2, r25	; 0x02
    3404:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3406:	89 81       	ldd	r24, Y+1	; 0x01
    3408:	9a 81       	ldd	r25, Y+2	; 0x02
    340a:	0e 94 6c 1c 	call	0x38d8	; 0x38d8 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    340e:	28 96       	adiw	r28, 0x08	; 8
    3410:	0f b6       	in	r0, 0x3f	; 63
    3412:	f8 94       	cli
    3414:	de bf       	out	0x3e, r29	; 62
    3416:	0f be       	out	0x3f, r0	; 63
    3418:	cd bf       	out	0x3d, r28	; 61
    341a:	cf 91       	pop	r28
    341c:	df 91       	pop	r29
    341e:	08 95       	ret

00003420 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3420:	df 93       	push	r29
    3422:	cf 93       	push	r28
    3424:	00 d0       	rcall	.+0      	; 0x3426 <xTaskRemoveFromEventList+0x6>
    3426:	00 d0       	rcall	.+0      	; 0x3428 <xTaskRemoveFromEventList+0x8>
    3428:	0f 92       	push	r0
    342a:	cd b7       	in	r28, 0x3d	; 61
    342c:	de b7       	in	r29, 0x3e	; 62
    342e:	9d 83       	std	Y+5, r25	; 0x05
    3430:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3432:	ec 81       	ldd	r30, Y+4	; 0x04
    3434:	fd 81       	ldd	r31, Y+5	; 0x05
    3436:	05 80       	ldd	r0, Z+5	; 0x05
    3438:	f6 81       	ldd	r31, Z+6	; 0x06
    343a:	e0 2d       	mov	r30, r0
    343c:	86 81       	ldd	r24, Z+6	; 0x06
    343e:	97 81       	ldd	r25, Z+7	; 0x07
    3440:	9b 83       	std	Y+3, r25	; 0x03
    3442:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3444:	8a 81       	ldd	r24, Y+2	; 0x02
    3446:	9b 81       	ldd	r25, Y+3	; 0x03
    3448:	0c 96       	adiw	r24, 0x0c	; 12
    344a:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    344e:	80 91 4d 05 	lds	r24, 0x054D
    3452:	88 23       	and	r24, r24
    3454:	61 f5       	brne	.+88     	; 0x34ae <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3456:	8a 81       	ldd	r24, Y+2	; 0x02
    3458:	9b 81       	ldd	r25, Y+3	; 0x03
    345a:	02 96       	adiw	r24, 0x02	; 2
    345c:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3460:	ea 81       	ldd	r30, Y+2	; 0x02
    3462:	fb 81       	ldd	r31, Y+3	; 0x03
    3464:	96 89       	ldd	r25, Z+22	; 0x16
    3466:	80 91 47 05 	lds	r24, 0x0547
    346a:	89 17       	cp	r24, r25
    346c:	28 f4       	brcc	.+10     	; 0x3478 <xTaskRemoveFromEventList+0x58>
    346e:	ea 81       	ldd	r30, Y+2	; 0x02
    3470:	fb 81       	ldd	r31, Y+3	; 0x03
    3472:	86 89       	ldd	r24, Z+22	; 0x16
    3474:	80 93 47 05 	sts	0x0547, r24
    3478:	ea 81       	ldd	r30, Y+2	; 0x02
    347a:	fb 81       	ldd	r31, Y+3	; 0x03
    347c:	86 89       	ldd	r24, Z+22	; 0x16
    347e:	28 2f       	mov	r18, r24
    3480:	30 e0       	ldi	r19, 0x00	; 0
    3482:	c9 01       	movw	r24, r18
    3484:	88 0f       	add	r24, r24
    3486:	99 1f       	adc	r25, r25
    3488:	88 0f       	add	r24, r24
    348a:	99 1f       	adc	r25, r25
    348c:	88 0f       	add	r24, r24
    348e:	99 1f       	adc	r25, r25
    3490:	82 0f       	add	r24, r18
    3492:	93 1f       	adc	r25, r19
    3494:	ac 01       	movw	r20, r24
    3496:	42 5b       	subi	r20, 0xB2	; 178
    3498:	5a 4f       	sbci	r21, 0xFA	; 250
    349a:	8a 81       	ldd	r24, Y+2	; 0x02
    349c:	9b 81       	ldd	r25, Y+3	; 0x03
    349e:	9c 01       	movw	r18, r24
    34a0:	2e 5f       	subi	r18, 0xFE	; 254
    34a2:	3f 4f       	sbci	r19, 0xFF	; 255
    34a4:	ca 01       	movw	r24, r20
    34a6:	b9 01       	movw	r22, r18
    34a8:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>
    34ac:	0a c0       	rjmp	.+20     	; 0x34c2 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    34ae:	8a 81       	ldd	r24, Y+2	; 0x02
    34b0:	9b 81       	ldd	r25, Y+3	; 0x03
    34b2:	9c 01       	movw	r18, r24
    34b4:	24 5f       	subi	r18, 0xF4	; 244
    34b6:	3f 4f       	sbci	r19, 0xFF	; 255
    34b8:	88 e8       	ldi	r24, 0x88	; 136
    34ba:	95 e0       	ldi	r25, 0x05	; 5
    34bc:	b9 01       	movw	r22, r18
    34be:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    34c2:	ea 81       	ldd	r30, Y+2	; 0x02
    34c4:	fb 81       	ldd	r31, Y+3	; 0x03
    34c6:	96 89       	ldd	r25, Z+22	; 0x16
    34c8:	e0 91 41 05 	lds	r30, 0x0541
    34cc:	f0 91 42 05 	lds	r31, 0x0542
    34d0:	86 89       	ldd	r24, Z+22	; 0x16
    34d2:	89 17       	cp	r24, r25
    34d4:	30 f4       	brcc	.+12     	; 0x34e2 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    34d6:	81 e0       	ldi	r24, 0x01	; 1
    34d8:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    34da:	81 e0       	ldi	r24, 0x01	; 1
    34dc:	80 93 4a 05 	sts	0x054A, r24
    34e0:	01 c0       	rjmp	.+2      	; 0x34e4 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    34e2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    34e4:	89 81       	ldd	r24, Y+1	; 0x01
}
    34e6:	0f 90       	pop	r0
    34e8:	0f 90       	pop	r0
    34ea:	0f 90       	pop	r0
    34ec:	0f 90       	pop	r0
    34ee:	0f 90       	pop	r0
    34f0:	cf 91       	pop	r28
    34f2:	df 91       	pop	r29
    34f4:	08 95       	ret

000034f6 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    34f6:	df 93       	push	r29
    34f8:	cf 93       	push	r28
    34fa:	cd b7       	in	r28, 0x3d	; 61
    34fc:	de b7       	in	r29, 0x3e	; 62
    34fe:	27 97       	sbiw	r28, 0x07	; 7
    3500:	0f b6       	in	r0, 0x3f	; 63
    3502:	f8 94       	cli
    3504:	de bf       	out	0x3e, r29	; 62
    3506:	0f be       	out	0x3f, r0	; 63
    3508:	cd bf       	out	0x3d, r28	; 61
    350a:	9d 83       	std	Y+5, r25	; 0x05
    350c:	8c 83       	std	Y+4, r24	; 0x04
    350e:	7f 83       	std	Y+7, r23	; 0x07
    3510:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3512:	8e 81       	ldd	r24, Y+6	; 0x06
    3514:	9f 81       	ldd	r25, Y+7	; 0x07
    3516:	90 68       	ori	r25, 0x80	; 128
    3518:	ec 81       	ldd	r30, Y+4	; 0x04
    351a:	fd 81       	ldd	r31, Y+5	; 0x05
    351c:	91 83       	std	Z+1, r25	; 0x01
    351e:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    3520:	ec 81       	ldd	r30, Y+4	; 0x04
    3522:	fd 81       	ldd	r31, Y+5	; 0x05
    3524:	86 81       	ldd	r24, Z+6	; 0x06
    3526:	97 81       	ldd	r25, Z+7	; 0x07
    3528:	9b 83       	std	Y+3, r25	; 0x03
    352a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    352c:	8c 81       	ldd	r24, Y+4	; 0x04
    352e:	9d 81       	ldd	r25, Y+5	; 0x05
    3530:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3534:	8a 81       	ldd	r24, Y+2	; 0x02
    3536:	9b 81       	ldd	r25, Y+3	; 0x03
    3538:	02 96       	adiw	r24, 0x02	; 2
    353a:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    353e:	ea 81       	ldd	r30, Y+2	; 0x02
    3540:	fb 81       	ldd	r31, Y+3	; 0x03
    3542:	96 89       	ldd	r25, Z+22	; 0x16
    3544:	80 91 47 05 	lds	r24, 0x0547
    3548:	89 17       	cp	r24, r25
    354a:	28 f4       	brcc	.+10     	; 0x3556 <xTaskRemoveFromUnorderedEventList+0x60>
    354c:	ea 81       	ldd	r30, Y+2	; 0x02
    354e:	fb 81       	ldd	r31, Y+3	; 0x03
    3550:	86 89       	ldd	r24, Z+22	; 0x16
    3552:	80 93 47 05 	sts	0x0547, r24
    3556:	ea 81       	ldd	r30, Y+2	; 0x02
    3558:	fb 81       	ldd	r31, Y+3	; 0x03
    355a:	86 89       	ldd	r24, Z+22	; 0x16
    355c:	28 2f       	mov	r18, r24
    355e:	30 e0       	ldi	r19, 0x00	; 0
    3560:	c9 01       	movw	r24, r18
    3562:	88 0f       	add	r24, r24
    3564:	99 1f       	adc	r25, r25
    3566:	88 0f       	add	r24, r24
    3568:	99 1f       	adc	r25, r25
    356a:	88 0f       	add	r24, r24
    356c:	99 1f       	adc	r25, r25
    356e:	82 0f       	add	r24, r18
    3570:	93 1f       	adc	r25, r19
    3572:	ac 01       	movw	r20, r24
    3574:	42 5b       	subi	r20, 0xB2	; 178
    3576:	5a 4f       	sbci	r21, 0xFA	; 250
    3578:	8a 81       	ldd	r24, Y+2	; 0x02
    357a:	9b 81       	ldd	r25, Y+3	; 0x03
    357c:	9c 01       	movw	r18, r24
    357e:	2e 5f       	subi	r18, 0xFE	; 254
    3580:	3f 4f       	sbci	r19, 0xFF	; 255
    3582:	ca 01       	movw	r24, r20
    3584:	b9 01       	movw	r22, r18
    3586:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    358a:	ea 81       	ldd	r30, Y+2	; 0x02
    358c:	fb 81       	ldd	r31, Y+3	; 0x03
    358e:	96 89       	ldd	r25, Z+22	; 0x16
    3590:	e0 91 41 05 	lds	r30, 0x0541
    3594:	f0 91 42 05 	lds	r31, 0x0542
    3598:	86 89       	ldd	r24, Z+22	; 0x16
    359a:	89 17       	cp	r24, r25
    359c:	30 f4       	brcc	.+12     	; 0x35aa <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    359e:	81 e0       	ldi	r24, 0x01	; 1
    35a0:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    35a2:	81 e0       	ldi	r24, 0x01	; 1
    35a4:	80 93 4a 05 	sts	0x054A, r24
    35a8:	01 c0       	rjmp	.+2      	; 0x35ac <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    35aa:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    35ac:	89 81       	ldd	r24, Y+1	; 0x01
}
    35ae:	27 96       	adiw	r28, 0x07	; 7
    35b0:	0f b6       	in	r0, 0x3f	; 63
    35b2:	f8 94       	cli
    35b4:	de bf       	out	0x3e, r29	; 62
    35b6:	0f be       	out	0x3f, r0	; 63
    35b8:	cd bf       	out	0x3d, r28	; 61
    35ba:	cf 91       	pop	r28
    35bc:	df 91       	pop	r29
    35be:	08 95       	ret

000035c0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    35c0:	df 93       	push	r29
    35c2:	cf 93       	push	r28
    35c4:	00 d0       	rcall	.+0      	; 0x35c6 <vTaskSetTimeOutState+0x6>
    35c6:	cd b7       	in	r28, 0x3d	; 61
    35c8:	de b7       	in	r29, 0x3e	; 62
    35ca:	9a 83       	std	Y+2, r25	; 0x02
    35cc:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    35ce:	80 91 4b 05 	lds	r24, 0x054B
    35d2:	e9 81       	ldd	r30, Y+1	; 0x01
    35d4:	fa 81       	ldd	r31, Y+2	; 0x02
    35d6:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    35d8:	80 91 45 05 	lds	r24, 0x0545
    35dc:	90 91 46 05 	lds	r25, 0x0546
    35e0:	e9 81       	ldd	r30, Y+1	; 0x01
    35e2:	fa 81       	ldd	r31, Y+2	; 0x02
    35e4:	92 83       	std	Z+2, r25	; 0x02
    35e6:	81 83       	std	Z+1, r24	; 0x01
}
    35e8:	0f 90       	pop	r0
    35ea:	0f 90       	pop	r0
    35ec:	cf 91       	pop	r28
    35ee:	df 91       	pop	r29
    35f0:	08 95       	ret

000035f2 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    35f2:	df 93       	push	r29
    35f4:	cf 93       	push	r28
    35f6:	cd b7       	in	r28, 0x3d	; 61
    35f8:	de b7       	in	r29, 0x3e	; 62
    35fa:	27 97       	sbiw	r28, 0x07	; 7
    35fc:	0f b6       	in	r0, 0x3f	; 63
    35fe:	f8 94       	cli
    3600:	de bf       	out	0x3e, r29	; 62
    3602:	0f be       	out	0x3f, r0	; 63
    3604:	cd bf       	out	0x3d, r28	; 61
    3606:	9d 83       	std	Y+5, r25	; 0x05
    3608:	8c 83       	std	Y+4, r24	; 0x04
    360a:	7f 83       	std	Y+7, r23	; 0x07
    360c:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    360e:	0f b6       	in	r0, 0x3f	; 63
    3610:	f8 94       	cli
    3612:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3614:	80 91 45 05 	lds	r24, 0x0545
    3618:	90 91 46 05 	lds	r25, 0x0546
    361c:	9a 83       	std	Y+2, r25	; 0x02
    361e:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3620:	ec 81       	ldd	r30, Y+4	; 0x04
    3622:	fd 81       	ldd	r31, Y+5	; 0x05
    3624:	90 81       	ld	r25, Z
    3626:	80 91 4b 05 	lds	r24, 0x054B
    362a:	98 17       	cp	r25, r24
    362c:	61 f0       	breq	.+24     	; 0x3646 <xTaskCheckForTimeOut+0x54>
    362e:	ec 81       	ldd	r30, Y+4	; 0x04
    3630:	fd 81       	ldd	r31, Y+5	; 0x05
    3632:	21 81       	ldd	r18, Z+1	; 0x01
    3634:	32 81       	ldd	r19, Z+2	; 0x02
    3636:	89 81       	ldd	r24, Y+1	; 0x01
    3638:	9a 81       	ldd	r25, Y+2	; 0x02
    363a:	82 17       	cp	r24, r18
    363c:	93 07       	cpc	r25, r19
    363e:	18 f0       	brcs	.+6      	; 0x3646 <xTaskCheckForTimeOut+0x54>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    3640:	81 e0       	ldi	r24, 0x01	; 1
    3642:	8b 83       	std	Y+3, r24	; 0x03
    3644:	2d c0       	rjmp	.+90     	; 0x36a0 <xTaskCheckForTimeOut+0xae>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    3646:	ec 81       	ldd	r30, Y+4	; 0x04
    3648:	fd 81       	ldd	r31, Y+5	; 0x05
    364a:	21 81       	ldd	r18, Z+1	; 0x01
    364c:	32 81       	ldd	r19, Z+2	; 0x02
    364e:	89 81       	ldd	r24, Y+1	; 0x01
    3650:	9a 81       	ldd	r25, Y+2	; 0x02
    3652:	ac 01       	movw	r20, r24
    3654:	42 1b       	sub	r20, r18
    3656:	53 0b       	sbc	r21, r19
    3658:	9a 01       	movw	r18, r20
    365a:	ee 81       	ldd	r30, Y+6	; 0x06
    365c:	ff 81       	ldd	r31, Y+7	; 0x07
    365e:	80 81       	ld	r24, Z
    3660:	91 81       	ldd	r25, Z+1	; 0x01
    3662:	28 17       	cp	r18, r24
    3664:	39 07       	cpc	r19, r25
    3666:	d0 f4       	brcc	.+52     	; 0x369c <xTaskCheckForTimeOut+0xaa>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    3668:	ee 81       	ldd	r30, Y+6	; 0x06
    366a:	ff 81       	ldd	r31, Y+7	; 0x07
    366c:	40 81       	ld	r20, Z
    366e:	51 81       	ldd	r21, Z+1	; 0x01
    3670:	ec 81       	ldd	r30, Y+4	; 0x04
    3672:	fd 81       	ldd	r31, Y+5	; 0x05
    3674:	21 81       	ldd	r18, Z+1	; 0x01
    3676:	32 81       	ldd	r19, Z+2	; 0x02
    3678:	89 81       	ldd	r24, Y+1	; 0x01
    367a:	9a 81       	ldd	r25, Y+2	; 0x02
    367c:	b9 01       	movw	r22, r18
    367e:	68 1b       	sub	r22, r24
    3680:	79 0b       	sbc	r23, r25
    3682:	cb 01       	movw	r24, r22
    3684:	84 0f       	add	r24, r20
    3686:	95 1f       	adc	r25, r21
    3688:	ee 81       	ldd	r30, Y+6	; 0x06
    368a:	ff 81       	ldd	r31, Y+7	; 0x07
    368c:	91 83       	std	Z+1, r25	; 0x01
    368e:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    3690:	8c 81       	ldd	r24, Y+4	; 0x04
    3692:	9d 81       	ldd	r25, Y+5	; 0x05
    3694:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3698:	1b 82       	std	Y+3, r1	; 0x03
    369a:	02 c0       	rjmp	.+4      	; 0x36a0 <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			xReturn = pdTRUE;
    369c:	81 e0       	ldi	r24, 0x01	; 1
    369e:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    36a0:	0f 90       	pop	r0
    36a2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    36a4:	8b 81       	ldd	r24, Y+3	; 0x03
}
    36a6:	27 96       	adiw	r28, 0x07	; 7
    36a8:	0f b6       	in	r0, 0x3f	; 63
    36aa:	f8 94       	cli
    36ac:	de bf       	out	0x3e, r29	; 62
    36ae:	0f be       	out	0x3f, r0	; 63
    36b0:	cd bf       	out	0x3d, r28	; 61
    36b2:	cf 91       	pop	r28
    36b4:	df 91       	pop	r29
    36b6:	08 95       	ret

000036b8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    36b8:	df 93       	push	r29
    36ba:	cf 93       	push	r28
    36bc:	cd b7       	in	r28, 0x3d	; 61
    36be:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    36c0:	81 e0       	ldi	r24, 0x01	; 1
    36c2:	80 93 4a 05 	sts	0x054A, r24
}
    36c6:	cf 91       	pop	r28
    36c8:	df 91       	pop	r29
    36ca:	08 95       	ret

000036cc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    36cc:	df 93       	push	r29
    36ce:	cf 93       	push	r28
    36d0:	00 d0       	rcall	.+0      	; 0x36d2 <prvIdleTask+0x6>
    36d2:	cd b7       	in	r28, 0x3d	; 61
    36d4:	de b7       	in	r29, 0x3e	; 62
    36d6:	9a 83       	std	Y+2, r25	; 0x02
    36d8:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    36da:	0e 94 2d 1c 	call	0x385a	; 0x385a <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    36de:	80 91 4e 05 	lds	r24, 0x054E
    36e2:	82 30       	cpi	r24, 0x02	; 2
    36e4:	d0 f3       	brcs	.-12     	; 0x36da <prvIdleTask+0xe>
			{
				taskYIELD();
    36e6:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    36ea:	f7 cf       	rjmp	.-18     	; 0x36da <prvIdleTask+0xe>

000036ec <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    36ec:	0f 93       	push	r16
    36ee:	1f 93       	push	r17
    36f0:	df 93       	push	r29
    36f2:	cf 93       	push	r28
    36f4:	cd b7       	in	r28, 0x3d	; 61
    36f6:	de b7       	in	r29, 0x3e	; 62
    36f8:	2a 97       	sbiw	r28, 0x0a	; 10
    36fa:	0f b6       	in	r0, 0x3f	; 63
    36fc:	f8 94       	cli
    36fe:	de bf       	out	0x3e, r29	; 62
    3700:	0f be       	out	0x3f, r0	; 63
    3702:	cd bf       	out	0x3d, r28	; 61
    3704:	9b 83       	std	Y+3, r25	; 0x03
    3706:	8a 83       	std	Y+2, r24	; 0x02
    3708:	7d 83       	std	Y+5, r23	; 0x05
    370a:	6c 83       	std	Y+4, r22	; 0x04
    370c:	4e 83       	std	Y+6, r20	; 0x06
    370e:	38 87       	std	Y+8, r19	; 0x08
    3710:	2f 83       	std	Y+7, r18	; 0x07
    3712:	1a 87       	std	Y+10, r17	; 0x0a
    3714:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3716:	19 82       	std	Y+1, r1	; 0x01
    3718:	21 c0       	rjmp	.+66     	; 0x375c <prvInitialiseTCBVariables+0x70>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    371a:	89 81       	ldd	r24, Y+1	; 0x01
    371c:	48 2f       	mov	r20, r24
    371e:	50 e0       	ldi	r21, 0x00	; 0
    3720:	89 81       	ldd	r24, Y+1	; 0x01
    3722:	28 2f       	mov	r18, r24
    3724:	30 e0       	ldi	r19, 0x00	; 0
    3726:	8c 81       	ldd	r24, Y+4	; 0x04
    3728:	9d 81       	ldd	r25, Y+5	; 0x05
    372a:	fc 01       	movw	r30, r24
    372c:	e2 0f       	add	r30, r18
    372e:	f3 1f       	adc	r31, r19
    3730:	20 81       	ld	r18, Z
    3732:	8a 81       	ldd	r24, Y+2	; 0x02
    3734:	9b 81       	ldd	r25, Y+3	; 0x03
    3736:	84 0f       	add	r24, r20
    3738:	95 1f       	adc	r25, r21
    373a:	fc 01       	movw	r30, r24
    373c:	79 96       	adiw	r30, 0x19	; 25
    373e:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    3740:	89 81       	ldd	r24, Y+1	; 0x01
    3742:	28 2f       	mov	r18, r24
    3744:	30 e0       	ldi	r19, 0x00	; 0
    3746:	8c 81       	ldd	r24, Y+4	; 0x04
    3748:	9d 81       	ldd	r25, Y+5	; 0x05
    374a:	fc 01       	movw	r30, r24
    374c:	e2 0f       	add	r30, r18
    374e:	f3 1f       	adc	r31, r19
    3750:	80 81       	ld	r24, Z
    3752:	88 23       	and	r24, r24
    3754:	31 f0       	breq	.+12     	; 0x3762 <prvInitialiseTCBVariables+0x76>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3756:	89 81       	ldd	r24, Y+1	; 0x01
    3758:	8f 5f       	subi	r24, 0xFF	; 255
    375a:	89 83       	std	Y+1, r24	; 0x01
    375c:	89 81       	ldd	r24, Y+1	; 0x01
    375e:	84 31       	cpi	r24, 0x14	; 20
    3760:	e0 f2       	brcs	.-72     	; 0x371a <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3762:	ea 81       	ldd	r30, Y+2	; 0x02
    3764:	fb 81       	ldd	r31, Y+3	; 0x03
    3766:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3768:	8e 81       	ldd	r24, Y+6	; 0x06
    376a:	84 30       	cpi	r24, 0x04	; 4
    376c:	10 f0       	brcs	.+4      	; 0x3772 <prvInitialiseTCBVariables+0x86>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    376e:	83 e0       	ldi	r24, 0x03	; 3
    3770:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    3772:	ea 81       	ldd	r30, Y+2	; 0x02
    3774:	fb 81       	ldd	r31, Y+3	; 0x03
    3776:	8e 81       	ldd	r24, Y+6	; 0x06
    3778:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    377a:	ea 81       	ldd	r30, Y+2	; 0x02
    377c:	fb 81       	ldd	r31, Y+3	; 0x03
    377e:	8e 81       	ldd	r24, Y+6	; 0x06
    3780:	85 a7       	std	Z+45, r24	; 0x2d
		pxTCB->uxMutexesHeld = 0;
    3782:	ea 81       	ldd	r30, Y+2	; 0x02
    3784:	fb 81       	ldd	r31, Y+3	; 0x03
    3786:	16 a6       	std	Z+46, r1	; 0x2e
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    3788:	8a 81       	ldd	r24, Y+2	; 0x02
    378a:	9b 81       	ldd	r25, Y+3	; 0x03
    378c:	02 96       	adiw	r24, 0x02	; 2
    378e:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    3792:	8a 81       	ldd	r24, Y+2	; 0x02
    3794:	9b 81       	ldd	r25, Y+3	; 0x03
    3796:	0c 96       	adiw	r24, 0x0c	; 12
    3798:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    379c:	ea 81       	ldd	r30, Y+2	; 0x02
    379e:	fb 81       	ldd	r31, Y+3	; 0x03
    37a0:	8a 81       	ldd	r24, Y+2	; 0x02
    37a2:	9b 81       	ldd	r25, Y+3	; 0x03
    37a4:	91 87       	std	Z+9, r25	; 0x09
    37a6:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    37a8:	8e 81       	ldd	r24, Y+6	; 0x06
    37aa:	28 2f       	mov	r18, r24
    37ac:	30 e0       	ldi	r19, 0x00	; 0
    37ae:	84 e0       	ldi	r24, 0x04	; 4
    37b0:	90 e0       	ldi	r25, 0x00	; 0
    37b2:	82 1b       	sub	r24, r18
    37b4:	93 0b       	sbc	r25, r19
    37b6:	ea 81       	ldd	r30, Y+2	; 0x02
    37b8:	fb 81       	ldd	r31, Y+3	; 0x03
    37ba:	95 87       	std	Z+13, r25	; 0x0d
    37bc:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    37be:	ea 81       	ldd	r30, Y+2	; 0x02
    37c0:	fb 81       	ldd	r31, Y+3	; 0x03
    37c2:	8a 81       	ldd	r24, Y+2	; 0x02
    37c4:	9b 81       	ldd	r25, Y+3	; 0x03
    37c6:	93 8b       	std	Z+19, r25	; 0x13
    37c8:	82 8b       	std	Z+18, r24	; 0x12
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    37ca:	2a 96       	adiw	r28, 0x0a	; 10
    37cc:	0f b6       	in	r0, 0x3f	; 63
    37ce:	f8 94       	cli
    37d0:	de bf       	out	0x3e, r29	; 62
    37d2:	0f be       	out	0x3f, r0	; 63
    37d4:	cd bf       	out	0x3d, r28	; 61
    37d6:	cf 91       	pop	r28
    37d8:	df 91       	pop	r29
    37da:	1f 91       	pop	r17
    37dc:	0f 91       	pop	r16
    37de:	08 95       	ret

000037e0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    37e0:	df 93       	push	r29
    37e2:	cf 93       	push	r28
    37e4:	0f 92       	push	r0
    37e6:	cd b7       	in	r28, 0x3d	; 61
    37e8:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    37ea:	19 82       	std	Y+1, r1	; 0x01
    37ec:	13 c0       	rjmp	.+38     	; 0x3814 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    37ee:	89 81       	ldd	r24, Y+1	; 0x01
    37f0:	28 2f       	mov	r18, r24
    37f2:	30 e0       	ldi	r19, 0x00	; 0
    37f4:	c9 01       	movw	r24, r18
    37f6:	88 0f       	add	r24, r24
    37f8:	99 1f       	adc	r25, r25
    37fa:	88 0f       	add	r24, r24
    37fc:	99 1f       	adc	r25, r25
    37fe:	88 0f       	add	r24, r24
    3800:	99 1f       	adc	r25, r25
    3802:	82 0f       	add	r24, r18
    3804:	93 1f       	adc	r25, r19
    3806:	82 5b       	subi	r24, 0xB2	; 178
    3808:	9a 4f       	sbci	r25, 0xFA	; 250
    380a:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    380e:	89 81       	ldd	r24, Y+1	; 0x01
    3810:	8f 5f       	subi	r24, 0xFF	; 255
    3812:	89 83       	std	Y+1, r24	; 0x01
    3814:	89 81       	ldd	r24, Y+1	; 0x01
    3816:	84 30       	cpi	r24, 0x04	; 4
    3818:	50 f3       	brcs	.-44     	; 0x37ee <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    381a:	82 e7       	ldi	r24, 0x72	; 114
    381c:	95 e0       	ldi	r25, 0x05	; 5
    381e:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3822:	8b e7       	ldi	r24, 0x7B	; 123
    3824:	95 e0       	ldi	r25, 0x05	; 5
    3826:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    382a:	88 e8       	ldi	r24, 0x88	; 136
    382c:	95 e0       	ldi	r25, 0x05	; 5
    382e:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    3832:	81 e9       	ldi	r24, 0x91	; 145
    3834:	95 e0       	ldi	r25, 0x05	; 5
    3836:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    383a:	82 e7       	ldi	r24, 0x72	; 114
    383c:	95 e0       	ldi	r25, 0x05	; 5
    383e:	90 93 85 05 	sts	0x0585, r25
    3842:	80 93 84 05 	sts	0x0584, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3846:	8b e7       	ldi	r24, 0x7B	; 123
    3848:	95 e0       	ldi	r25, 0x05	; 5
    384a:	90 93 87 05 	sts	0x0587, r25
    384e:	80 93 86 05 	sts	0x0586, r24
}
    3852:	0f 90       	pop	r0
    3854:	cf 91       	pop	r28
    3856:	df 91       	pop	r29
    3858:	08 95       	ret

0000385a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    385a:	df 93       	push	r29
    385c:	cf 93       	push	r28
    385e:	00 d0       	rcall	.+0      	; 0x3860 <prvCheckTasksWaitingTermination+0x6>
    3860:	0f 92       	push	r0
    3862:	cd b7       	in	r28, 0x3d	; 61
    3864:	de b7       	in	r29, 0x3e	; 62
    3866:	2e c0       	rjmp	.+92     	; 0x38c4 <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    3868:	0e 94 7d 17 	call	0x2efa	; 0x2efa <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    386c:	80 91 91 05 	lds	r24, 0x0591
    3870:	1b 82       	std	Y+3, r1	; 0x03
    3872:	88 23       	and	r24, r24
    3874:	11 f4       	brne	.+4      	; 0x387a <prvCheckTasksWaitingTermination+0x20>
    3876:	81 e0       	ldi	r24, 0x01	; 1
    3878:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    387a:	0e 94 89 17 	call	0x2f12	; 0x2f12 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    387e:	8b 81       	ldd	r24, Y+3	; 0x03
    3880:	88 23       	and	r24, r24
    3882:	01 f5       	brne	.+64     	; 0x38c4 <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    3884:	0f b6       	in	r0, 0x3f	; 63
    3886:	f8 94       	cli
    3888:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    388a:	e0 91 96 05 	lds	r30, 0x0596
    388e:	f0 91 97 05 	lds	r31, 0x0597
    3892:	86 81       	ldd	r24, Z+6	; 0x06
    3894:	97 81       	ldd	r25, Z+7	; 0x07
    3896:	9a 83       	std	Y+2, r25	; 0x02
    3898:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    389a:	89 81       	ldd	r24, Y+1	; 0x01
    389c:	9a 81       	ldd	r25, Y+2	; 0x02
    389e:	02 96       	adiw	r24, 0x02	; 2
    38a0:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
					--uxCurrentNumberOfTasks;
    38a4:	80 91 44 05 	lds	r24, 0x0544
    38a8:	81 50       	subi	r24, 0x01	; 1
    38aa:	80 93 44 05 	sts	0x0544, r24
					--uxTasksDeleted;
    38ae:	80 91 43 05 	lds	r24, 0x0543
    38b2:	81 50       	subi	r24, 0x01	; 1
    38b4:	80 93 43 05 	sts	0x0543, r24
				}
				taskEXIT_CRITICAL();
    38b8:	0f 90       	pop	r0
    38ba:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    38bc:	89 81       	ldd	r24, Y+1	; 0x01
    38be:	9a 81       	ldd	r25, Y+2	; 0x02
    38c0:	0e 94 f9 1c 	call	0x39f2	; 0x39f2 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    38c4:	80 91 43 05 	lds	r24, 0x0543
    38c8:	88 23       	and	r24, r24
    38ca:	71 f6       	brne	.-100    	; 0x3868 <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    38cc:	0f 90       	pop	r0
    38ce:	0f 90       	pop	r0
    38d0:	0f 90       	pop	r0
    38d2:	cf 91       	pop	r28
    38d4:	df 91       	pop	r29
    38d6:	08 95       	ret

000038d8 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    38d8:	df 93       	push	r29
    38da:	cf 93       	push	r28
    38dc:	00 d0       	rcall	.+0      	; 0x38de <prvAddCurrentTaskToDelayedList+0x6>
    38de:	cd b7       	in	r28, 0x3d	; 61
    38e0:	de b7       	in	r29, 0x3e	; 62
    38e2:	9a 83       	std	Y+2, r25	; 0x02
    38e4:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    38e6:	e0 91 41 05 	lds	r30, 0x0541
    38ea:	f0 91 42 05 	lds	r31, 0x0542
    38ee:	89 81       	ldd	r24, Y+1	; 0x01
    38f0:	9a 81       	ldd	r25, Y+2	; 0x02
    38f2:	93 83       	std	Z+3, r25	; 0x03
    38f4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    38f6:	20 91 45 05 	lds	r18, 0x0545
    38fa:	30 91 46 05 	lds	r19, 0x0546
    38fe:	89 81       	ldd	r24, Y+1	; 0x01
    3900:	9a 81       	ldd	r25, Y+2	; 0x02
    3902:	82 17       	cp	r24, r18
    3904:	93 07       	cpc	r25, r19
    3906:	70 f4       	brcc	.+28     	; 0x3924 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3908:	80 91 86 05 	lds	r24, 0x0586
    390c:	90 91 87 05 	lds	r25, 0x0587
    3910:	20 91 41 05 	lds	r18, 0x0541
    3914:	30 91 42 05 	lds	r19, 0x0542
    3918:	2e 5f       	subi	r18, 0xFE	; 254
    391a:	3f 4f       	sbci	r19, 0xFF	; 255
    391c:	b9 01       	movw	r22, r18
    391e:	0e 94 17 09 	call	0x122e	; 0x122e <vListInsert>
    3922:	1e c0       	rjmp	.+60     	; 0x3960 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3924:	40 91 84 05 	lds	r20, 0x0584
    3928:	50 91 85 05 	lds	r21, 0x0585
    392c:	80 91 41 05 	lds	r24, 0x0541
    3930:	90 91 42 05 	lds	r25, 0x0542
    3934:	9c 01       	movw	r18, r24
    3936:	2e 5f       	subi	r18, 0xFE	; 254
    3938:	3f 4f       	sbci	r19, 0xFF	; 255
    393a:	ca 01       	movw	r24, r20
    393c:	b9 01       	movw	r22, r18
    393e:	0e 94 17 09 	call	0x122e	; 0x122e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    3942:	20 91 7d 00 	lds	r18, 0x007D
    3946:	30 91 7e 00 	lds	r19, 0x007E
    394a:	89 81       	ldd	r24, Y+1	; 0x01
    394c:	9a 81       	ldd	r25, Y+2	; 0x02
    394e:	82 17       	cp	r24, r18
    3950:	93 07       	cpc	r25, r19
    3952:	30 f4       	brcc	.+12     	; 0x3960 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3954:	89 81       	ldd	r24, Y+1	; 0x01
    3956:	9a 81       	ldd	r25, Y+2	; 0x02
    3958:	90 93 7e 00 	sts	0x007E, r25
    395c:	80 93 7d 00 	sts	0x007D, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    3960:	0f 90       	pop	r0
    3962:	0f 90       	pop	r0
    3964:	cf 91       	pop	r28
    3966:	df 91       	pop	r29
    3968:	08 95       	ret

0000396a <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    396a:	df 93       	push	r29
    396c:	cf 93       	push	r28
    396e:	cd b7       	in	r28, 0x3d	; 61
    3970:	de b7       	in	r29, 0x3e	; 62
    3972:	28 97       	sbiw	r28, 0x08	; 8
    3974:	0f b6       	in	r0, 0x3f	; 63
    3976:	f8 94       	cli
    3978:	de bf       	out	0x3e, r29	; 62
    397a:	0f be       	out	0x3f, r0	; 63
    397c:	cd bf       	out	0x3d, r28	; 61
    397e:	9c 83       	std	Y+4, r25	; 0x04
    3980:	8b 83       	std	Y+3, r24	; 0x03
    3982:	7e 83       	std	Y+6, r23	; 0x06
    3984:	6d 83       	std	Y+5, r22	; 0x05
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    3986:	8f e2       	ldi	r24, 0x2F	; 47
    3988:	90 e0       	ldi	r25, 0x00	; 0
    398a:	0e 94 4b 07 	call	0xe96	; 0xe96 <pvPortMalloc>
    398e:	9a 83       	std	Y+2, r25	; 0x02
    3990:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    3992:	89 81       	ldd	r24, Y+1	; 0x01
    3994:	9a 81       	ldd	r25, Y+2	; 0x02
    3996:	00 97       	sbiw	r24, 0x00	; 0
    3998:	09 f1       	breq	.+66     	; 0x39dc <prvAllocateTCBAndStack+0x72>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    399a:	8d 81       	ldd	r24, Y+5	; 0x05
    399c:	9e 81       	ldd	r25, Y+6	; 0x06
    399e:	00 97       	sbiw	r24, 0x00	; 0
    39a0:	39 f4       	brne	.+14     	; 0x39b0 <prvAllocateTCBAndStack+0x46>
    39a2:	8b 81       	ldd	r24, Y+3	; 0x03
    39a4:	9c 81       	ldd	r25, Y+4	; 0x04
    39a6:	0e 94 4b 07 	call	0xe96	; 0xe96 <pvPortMalloc>
    39aa:	98 87       	std	Y+8, r25	; 0x08
    39ac:	8f 83       	std	Y+7, r24	; 0x07
    39ae:	04 c0       	rjmp	.+8      	; 0x39b8 <prvAllocateTCBAndStack+0x4e>
    39b0:	8d 81       	ldd	r24, Y+5	; 0x05
    39b2:	9e 81       	ldd	r25, Y+6	; 0x06
    39b4:	98 87       	std	Y+8, r25	; 0x08
    39b6:	8f 83       	std	Y+7, r24	; 0x07
    39b8:	e9 81       	ldd	r30, Y+1	; 0x01
    39ba:	fa 81       	ldd	r31, Y+2	; 0x02
    39bc:	8f 81       	ldd	r24, Y+7	; 0x07
    39be:	98 85       	ldd	r25, Y+8	; 0x08
    39c0:	90 8f       	std	Z+24, r25	; 0x18
    39c2:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    39c4:	e9 81       	ldd	r30, Y+1	; 0x01
    39c6:	fa 81       	ldd	r31, Y+2	; 0x02
    39c8:	87 89       	ldd	r24, Z+23	; 0x17
    39ca:	90 8d       	ldd	r25, Z+24	; 0x18
    39cc:	00 97       	sbiw	r24, 0x00	; 0
    39ce:	31 f4       	brne	.+12     	; 0x39dc <prvAllocateTCBAndStack+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    39d0:	89 81       	ldd	r24, Y+1	; 0x01
    39d2:	9a 81       	ldd	r25, Y+2	; 0x02
    39d4:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
			pxNewTCB = NULL;
    39d8:	1a 82       	std	Y+2, r1	; 0x02
    39da:	19 82       	std	Y+1, r1	; 0x01
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
    39dc:	89 81       	ldd	r24, Y+1	; 0x01
    39de:	9a 81       	ldd	r25, Y+2	; 0x02
}
    39e0:	28 96       	adiw	r28, 0x08	; 8
    39e2:	0f b6       	in	r0, 0x3f	; 63
    39e4:	f8 94       	cli
    39e6:	de bf       	out	0x3e, r29	; 62
    39e8:	0f be       	out	0x3f, r0	; 63
    39ea:	cd bf       	out	0x3d, r28	; 61
    39ec:	cf 91       	pop	r28
    39ee:	df 91       	pop	r29
    39f0:	08 95       	ret

000039f2 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    39f2:	df 93       	push	r29
    39f4:	cf 93       	push	r28
    39f6:	00 d0       	rcall	.+0      	; 0x39f8 <prvDeleteTCB+0x6>
    39f8:	cd b7       	in	r28, 0x3d	; 61
    39fa:	de b7       	in	r29, 0x3e	; 62
    39fc:	9a 83       	std	Y+2, r25	; 0x02
    39fe:	89 83       	std	Y+1, r24	; 0x01
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    3a00:	e9 81       	ldd	r30, Y+1	; 0x01
    3a02:	fa 81       	ldd	r31, Y+2	; 0x02
    3a04:	87 89       	ldd	r24, Z+23	; 0x17
    3a06:	90 8d       	ldd	r25, Z+24	; 0x18
    3a08:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
		vPortFree( pxTCB );
    3a0c:	89 81       	ldd	r24, Y+1	; 0x01
    3a0e:	9a 81       	ldd	r25, Y+2	; 0x02
    3a10:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
	}
    3a14:	0f 90       	pop	r0
    3a16:	0f 90       	pop	r0
    3a18:	cf 91       	pop	r28
    3a1a:	df 91       	pop	r29
    3a1c:	08 95       	ret

00003a1e <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    3a1e:	df 93       	push	r29
    3a20:	cf 93       	push	r28
    3a22:	00 d0       	rcall	.+0      	; 0x3a24 <prvResetNextTaskUnblockTime+0x6>
    3a24:	cd b7       	in	r28, 0x3d	; 61
    3a26:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3a28:	e0 91 84 05 	lds	r30, 0x0584
    3a2c:	f0 91 85 05 	lds	r31, 0x0585
    3a30:	80 81       	ld	r24, Z
    3a32:	88 23       	and	r24, r24
    3a34:	39 f4       	brne	.+14     	; 0x3a44 <prvResetNextTaskUnblockTime+0x26>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3a36:	8f ef       	ldi	r24, 0xFF	; 255
    3a38:	9f ef       	ldi	r25, 0xFF	; 255
    3a3a:	90 93 7e 00 	sts	0x007E, r25
    3a3e:	80 93 7d 00 	sts	0x007D, r24
    3a42:	13 c0       	rjmp	.+38     	; 0x3a6a <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3a44:	e0 91 84 05 	lds	r30, 0x0584
    3a48:	f0 91 85 05 	lds	r31, 0x0585
    3a4c:	05 80       	ldd	r0, Z+5	; 0x05
    3a4e:	f6 81       	ldd	r31, Z+6	; 0x06
    3a50:	e0 2d       	mov	r30, r0
    3a52:	86 81       	ldd	r24, Z+6	; 0x06
    3a54:	97 81       	ldd	r25, Z+7	; 0x07
    3a56:	9a 83       	std	Y+2, r25	; 0x02
    3a58:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    3a5a:	e9 81       	ldd	r30, Y+1	; 0x01
    3a5c:	fa 81       	ldd	r31, Y+2	; 0x02
    3a5e:	82 81       	ldd	r24, Z+2	; 0x02
    3a60:	93 81       	ldd	r25, Z+3	; 0x03
    3a62:	90 93 7e 00 	sts	0x007E, r25
    3a66:	80 93 7d 00 	sts	0x007D, r24
	}
}
    3a6a:	0f 90       	pop	r0
    3a6c:	0f 90       	pop	r0
    3a6e:	cf 91       	pop	r28
    3a70:	df 91       	pop	r29
    3a72:	08 95       	ret

00003a74 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    3a74:	df 93       	push	r29
    3a76:	cf 93       	push	r28
    3a78:	00 d0       	rcall	.+0      	; 0x3a7a <xTaskGetCurrentTaskHandle+0x6>
    3a7a:	cd b7       	in	r28, 0x3d	; 61
    3a7c:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    3a7e:	80 91 41 05 	lds	r24, 0x0541
    3a82:	90 91 42 05 	lds	r25, 0x0542
    3a86:	9a 83       	std	Y+2, r25	; 0x02
    3a88:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    3a8a:	89 81       	ldd	r24, Y+1	; 0x01
    3a8c:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    3a8e:	0f 90       	pop	r0
    3a90:	0f 90       	pop	r0
    3a92:	cf 91       	pop	r28
    3a94:	df 91       	pop	r29
    3a96:	08 95       	ret

00003a98 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    3a98:	df 93       	push	r29
    3a9a:	cf 93       	push	r28
    3a9c:	00 d0       	rcall	.+0      	; 0x3a9e <vTaskPriorityInherit+0x6>
    3a9e:	00 d0       	rcall	.+0      	; 0x3aa0 <vTaskPriorityInherit+0x8>
    3aa0:	cd b7       	in	r28, 0x3d	; 61
    3aa2:	de b7       	in	r29, 0x3e	; 62
    3aa4:	9c 83       	std	Y+4, r25	; 0x04
    3aa6:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    3aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    3aaa:	9c 81       	ldd	r25, Y+4	; 0x04
    3aac:	9a 83       	std	Y+2, r25	; 0x02
    3aae:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    3ab0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ab2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ab4:	00 97       	sbiw	r24, 0x00	; 0
    3ab6:	09 f4       	brne	.+2      	; 0x3aba <vTaskPriorityInherit+0x22>
    3ab8:	73 c0       	rjmp	.+230    	; 0x3ba0 <vTaskPriorityInherit+0x108>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    3aba:	e9 81       	ldd	r30, Y+1	; 0x01
    3abc:	fa 81       	ldd	r31, Y+2	; 0x02
    3abe:	96 89       	ldd	r25, Z+22	; 0x16
    3ac0:	e0 91 41 05 	lds	r30, 0x0541
    3ac4:	f0 91 42 05 	lds	r31, 0x0542
    3ac8:	86 89       	ldd	r24, Z+22	; 0x16
    3aca:	98 17       	cp	r25, r24
    3acc:	08 f0       	brcs	.+2      	; 0x3ad0 <vTaskPriorityInherit+0x38>
    3ace:	68 c0       	rjmp	.+208    	; 0x3ba0 <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    3ad0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ad2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ad4:	84 85       	ldd	r24, Z+12	; 0x0c
    3ad6:	95 85       	ldd	r25, Z+13	; 0x0d
    3ad8:	99 23       	and	r25, r25
    3ada:	7c f0       	brlt	.+30     	; 0x3afa <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3adc:	e0 91 41 05 	lds	r30, 0x0541
    3ae0:	f0 91 42 05 	lds	r31, 0x0542
    3ae4:	86 89       	ldd	r24, Z+22	; 0x16
    3ae6:	28 2f       	mov	r18, r24
    3ae8:	30 e0       	ldi	r19, 0x00	; 0
    3aea:	84 e0       	ldi	r24, 0x04	; 4
    3aec:	90 e0       	ldi	r25, 0x00	; 0
    3aee:	82 1b       	sub	r24, r18
    3af0:	93 0b       	sbc	r25, r19
    3af2:	e9 81       	ldd	r30, Y+1	; 0x01
    3af4:	fa 81       	ldd	r31, Y+2	; 0x02
    3af6:	95 87       	std	Z+13, r25	; 0x0d
    3af8:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3afa:	e9 81       	ldd	r30, Y+1	; 0x01
    3afc:	fa 81       	ldd	r31, Y+2	; 0x02
    3afe:	42 85       	ldd	r20, Z+10	; 0x0a
    3b00:	53 85       	ldd	r21, Z+11	; 0x0b
    3b02:	e9 81       	ldd	r30, Y+1	; 0x01
    3b04:	fa 81       	ldd	r31, Y+2	; 0x02
    3b06:	86 89       	ldd	r24, Z+22	; 0x16
    3b08:	28 2f       	mov	r18, r24
    3b0a:	30 e0       	ldi	r19, 0x00	; 0
    3b0c:	c9 01       	movw	r24, r18
    3b0e:	88 0f       	add	r24, r24
    3b10:	99 1f       	adc	r25, r25
    3b12:	88 0f       	add	r24, r24
    3b14:	99 1f       	adc	r25, r25
    3b16:	88 0f       	add	r24, r24
    3b18:	99 1f       	adc	r25, r25
    3b1a:	82 0f       	add	r24, r18
    3b1c:	93 1f       	adc	r25, r19
    3b1e:	82 5b       	subi	r24, 0xB2	; 178
    3b20:	9a 4f       	sbci	r25, 0xFA	; 250
    3b22:	48 17       	cp	r20, r24
    3b24:	59 07       	cpc	r21, r25
    3b26:	a1 f5       	brne	.+104    	; 0x3b90 <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3b28:	89 81       	ldd	r24, Y+1	; 0x01
    3b2a:	9a 81       	ldd	r25, Y+2	; 0x02
    3b2c:	02 96       	adiw	r24, 0x02	; 2
    3b2e:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3b32:	e0 91 41 05 	lds	r30, 0x0541
    3b36:	f0 91 42 05 	lds	r31, 0x0542
    3b3a:	86 89       	ldd	r24, Z+22	; 0x16
    3b3c:	e9 81       	ldd	r30, Y+1	; 0x01
    3b3e:	fa 81       	ldd	r31, Y+2	; 0x02
    3b40:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    3b42:	e9 81       	ldd	r30, Y+1	; 0x01
    3b44:	fa 81       	ldd	r31, Y+2	; 0x02
    3b46:	96 89       	ldd	r25, Z+22	; 0x16
    3b48:	80 91 47 05 	lds	r24, 0x0547
    3b4c:	89 17       	cp	r24, r25
    3b4e:	28 f4       	brcc	.+10     	; 0x3b5a <vTaskPriorityInherit+0xc2>
    3b50:	e9 81       	ldd	r30, Y+1	; 0x01
    3b52:	fa 81       	ldd	r31, Y+2	; 0x02
    3b54:	86 89       	ldd	r24, Z+22	; 0x16
    3b56:	80 93 47 05 	sts	0x0547, r24
    3b5a:	e9 81       	ldd	r30, Y+1	; 0x01
    3b5c:	fa 81       	ldd	r31, Y+2	; 0x02
    3b5e:	86 89       	ldd	r24, Z+22	; 0x16
    3b60:	28 2f       	mov	r18, r24
    3b62:	30 e0       	ldi	r19, 0x00	; 0
    3b64:	c9 01       	movw	r24, r18
    3b66:	88 0f       	add	r24, r24
    3b68:	99 1f       	adc	r25, r25
    3b6a:	88 0f       	add	r24, r24
    3b6c:	99 1f       	adc	r25, r25
    3b6e:	88 0f       	add	r24, r24
    3b70:	99 1f       	adc	r25, r25
    3b72:	82 0f       	add	r24, r18
    3b74:	93 1f       	adc	r25, r19
    3b76:	ac 01       	movw	r20, r24
    3b78:	42 5b       	subi	r20, 0xB2	; 178
    3b7a:	5a 4f       	sbci	r21, 0xFA	; 250
    3b7c:	89 81       	ldd	r24, Y+1	; 0x01
    3b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    3b80:	9c 01       	movw	r18, r24
    3b82:	2e 5f       	subi	r18, 0xFE	; 254
    3b84:	3f 4f       	sbci	r19, 0xFF	; 255
    3b86:	ca 01       	movw	r24, r20
    3b88:	b9 01       	movw	r22, r18
    3b8a:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>
    3b8e:	08 c0       	rjmp	.+16     	; 0x3ba0 <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3b90:	e0 91 41 05 	lds	r30, 0x0541
    3b94:	f0 91 42 05 	lds	r31, 0x0542
    3b98:	86 89       	ldd	r24, Z+22	; 0x16
    3b9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3b9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3b9e:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3ba0:	0f 90       	pop	r0
    3ba2:	0f 90       	pop	r0
    3ba4:	0f 90       	pop	r0
    3ba6:	0f 90       	pop	r0
    3ba8:	cf 91       	pop	r28
    3baa:	df 91       	pop	r29
    3bac:	08 95       	ret

00003bae <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    3bae:	df 93       	push	r29
    3bb0:	cf 93       	push	r28
    3bb2:	00 d0       	rcall	.+0      	; 0x3bb4 <xTaskPriorityDisinherit+0x6>
    3bb4:	00 d0       	rcall	.+0      	; 0x3bb6 <xTaskPriorityDisinherit+0x8>
    3bb6:	0f 92       	push	r0
    3bb8:	cd b7       	in	r28, 0x3d	; 61
    3bba:	de b7       	in	r29, 0x3e	; 62
    3bbc:	9d 83       	std	Y+5, r25	; 0x05
    3bbe:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    3bc0:	8c 81       	ldd	r24, Y+4	; 0x04
    3bc2:	9d 81       	ldd	r25, Y+5	; 0x05
    3bc4:	9b 83       	std	Y+3, r25	; 0x03
    3bc6:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    3bc8:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    3bca:	8c 81       	ldd	r24, Y+4	; 0x04
    3bcc:	9d 81       	ldd	r25, Y+5	; 0x05
    3bce:	00 97       	sbiw	r24, 0x00	; 0
    3bd0:	09 f4       	brne	.+2      	; 0x3bd4 <xTaskPriorityDisinherit+0x26>
    3bd2:	56 c0       	rjmp	.+172    	; 0x3c80 <xTaskPriorityDisinherit+0xd2>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    3bd4:	ea 81       	ldd	r30, Y+2	; 0x02
    3bd6:	fb 81       	ldd	r31, Y+3	; 0x03
    3bd8:	86 a5       	ldd	r24, Z+46	; 0x2e
    3bda:	81 50       	subi	r24, 0x01	; 1
    3bdc:	ea 81       	ldd	r30, Y+2	; 0x02
    3bde:	fb 81       	ldd	r31, Y+3	; 0x03
    3be0:	86 a7       	std	Z+46, r24	; 0x2e

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3be2:	ea 81       	ldd	r30, Y+2	; 0x02
    3be4:	fb 81       	ldd	r31, Y+3	; 0x03
    3be6:	96 89       	ldd	r25, Z+22	; 0x16
    3be8:	ea 81       	ldd	r30, Y+2	; 0x02
    3bea:	fb 81       	ldd	r31, Y+3	; 0x03
    3bec:	85 a5       	ldd	r24, Z+45	; 0x2d
    3bee:	98 17       	cp	r25, r24
    3bf0:	09 f4       	brne	.+2      	; 0x3bf4 <xTaskPriorityDisinherit+0x46>
    3bf2:	46 c0       	rjmp	.+140    	; 0x3c80 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    3bf4:	ea 81       	ldd	r30, Y+2	; 0x02
    3bf6:	fb 81       	ldd	r31, Y+3	; 0x03
    3bf8:	86 a5       	ldd	r24, Z+46	; 0x2e
    3bfa:	88 23       	and	r24, r24
    3bfc:	09 f0       	breq	.+2      	; 0x3c00 <xTaskPriorityDisinherit+0x52>
    3bfe:	40 c0       	rjmp	.+128    	; 0x3c80 <xTaskPriorityDisinherit+0xd2>
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3c00:	8a 81       	ldd	r24, Y+2	; 0x02
    3c02:	9b 81       	ldd	r25, Y+3	; 0x03
    3c04:	02 96       	adiw	r24, 0x02	; 2
    3c06:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    3c0a:	ea 81       	ldd	r30, Y+2	; 0x02
    3c0c:	fb 81       	ldd	r31, Y+3	; 0x03
    3c0e:	85 a5       	ldd	r24, Z+45	; 0x2d
    3c10:	ea 81       	ldd	r30, Y+2	; 0x02
    3c12:	fb 81       	ldd	r31, Y+3	; 0x03
    3c14:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3c16:	ea 81       	ldd	r30, Y+2	; 0x02
    3c18:	fb 81       	ldd	r31, Y+3	; 0x03
    3c1a:	86 89       	ldd	r24, Z+22	; 0x16
    3c1c:	28 2f       	mov	r18, r24
    3c1e:	30 e0       	ldi	r19, 0x00	; 0
    3c20:	84 e0       	ldi	r24, 0x04	; 4
    3c22:	90 e0       	ldi	r25, 0x00	; 0
    3c24:	82 1b       	sub	r24, r18
    3c26:	93 0b       	sbc	r25, r19
    3c28:	ea 81       	ldd	r30, Y+2	; 0x02
    3c2a:	fb 81       	ldd	r31, Y+3	; 0x03
    3c2c:	95 87       	std	Z+13, r25	; 0x0d
    3c2e:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    3c30:	ea 81       	ldd	r30, Y+2	; 0x02
    3c32:	fb 81       	ldd	r31, Y+3	; 0x03
    3c34:	96 89       	ldd	r25, Z+22	; 0x16
    3c36:	80 91 47 05 	lds	r24, 0x0547
    3c3a:	89 17       	cp	r24, r25
    3c3c:	28 f4       	brcc	.+10     	; 0x3c48 <xTaskPriorityDisinherit+0x9a>
    3c3e:	ea 81       	ldd	r30, Y+2	; 0x02
    3c40:	fb 81       	ldd	r31, Y+3	; 0x03
    3c42:	86 89       	ldd	r24, Z+22	; 0x16
    3c44:	80 93 47 05 	sts	0x0547, r24
    3c48:	ea 81       	ldd	r30, Y+2	; 0x02
    3c4a:	fb 81       	ldd	r31, Y+3	; 0x03
    3c4c:	86 89       	ldd	r24, Z+22	; 0x16
    3c4e:	28 2f       	mov	r18, r24
    3c50:	30 e0       	ldi	r19, 0x00	; 0
    3c52:	c9 01       	movw	r24, r18
    3c54:	88 0f       	add	r24, r24
    3c56:	99 1f       	adc	r25, r25
    3c58:	88 0f       	add	r24, r24
    3c5a:	99 1f       	adc	r25, r25
    3c5c:	88 0f       	add	r24, r24
    3c5e:	99 1f       	adc	r25, r25
    3c60:	82 0f       	add	r24, r18
    3c62:	93 1f       	adc	r25, r19
    3c64:	ac 01       	movw	r20, r24
    3c66:	42 5b       	subi	r20, 0xB2	; 178
    3c68:	5a 4f       	sbci	r21, 0xFA	; 250
    3c6a:	8a 81       	ldd	r24, Y+2	; 0x02
    3c6c:	9b 81       	ldd	r25, Y+3	; 0x03
    3c6e:	9c 01       	movw	r18, r24
    3c70:	2e 5f       	subi	r18, 0xFE	; 254
    3c72:	3f 4f       	sbci	r19, 0xFF	; 255
    3c74:	ca 01       	movw	r24, r20
    3c76:	b9 01       	movw	r22, r18
    3c78:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    3c7c:	81 e0       	ldi	r24, 0x01	; 1
    3c7e:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3c80:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3c82:	0f 90       	pop	r0
    3c84:	0f 90       	pop	r0
    3c86:	0f 90       	pop	r0
    3c88:	0f 90       	pop	r0
    3c8a:	0f 90       	pop	r0
    3c8c:	cf 91       	pop	r28
    3c8e:	df 91       	pop	r29
    3c90:	08 95       	ret

00003c92 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    3c92:	df 93       	push	r29
    3c94:	cf 93       	push	r28
    3c96:	00 d0       	rcall	.+0      	; 0x3c98 <uxTaskResetEventItemValue+0x6>
    3c98:	cd b7       	in	r28, 0x3d	; 61
    3c9a:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    3c9c:	e0 91 41 05 	lds	r30, 0x0541
    3ca0:	f0 91 42 05 	lds	r31, 0x0542
    3ca4:	84 85       	ldd	r24, Z+12	; 0x0c
    3ca6:	95 85       	ldd	r25, Z+13	; 0x0d
    3ca8:	9a 83       	std	Y+2, r25	; 0x02
    3caa:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3cac:	a0 91 41 05 	lds	r26, 0x0541
    3cb0:	b0 91 42 05 	lds	r27, 0x0542
    3cb4:	e0 91 41 05 	lds	r30, 0x0541
    3cb8:	f0 91 42 05 	lds	r31, 0x0542
    3cbc:	86 89       	ldd	r24, Z+22	; 0x16
    3cbe:	28 2f       	mov	r18, r24
    3cc0:	30 e0       	ldi	r19, 0x00	; 0
    3cc2:	84 e0       	ldi	r24, 0x04	; 4
    3cc4:	90 e0       	ldi	r25, 0x00	; 0
    3cc6:	82 1b       	sub	r24, r18
    3cc8:	93 0b       	sbc	r25, r19
    3cca:	1d 96       	adiw	r26, 0x0d	; 13
    3ccc:	9c 93       	st	X, r25
    3cce:	8e 93       	st	-X, r24
    3cd0:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    3cd2:	89 81       	ldd	r24, Y+1	; 0x01
    3cd4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3cd6:	0f 90       	pop	r0
    3cd8:	0f 90       	pop	r0
    3cda:	cf 91       	pop	r28
    3cdc:	df 91       	pop	r29
    3cde:	08 95       	ret

00003ce0 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    3ce0:	df 93       	push	r29
    3ce2:	cf 93       	push	r28
    3ce4:	cd b7       	in	r28, 0x3d	; 61
    3ce6:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    3ce8:	80 91 41 05 	lds	r24, 0x0541
    3cec:	90 91 42 05 	lds	r25, 0x0542
    3cf0:	00 97       	sbiw	r24, 0x00	; 0
    3cf2:	39 f0       	breq	.+14     	; 0x3d02 <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    3cf4:	e0 91 41 05 	lds	r30, 0x0541
    3cf8:	f0 91 42 05 	lds	r31, 0x0542
    3cfc:	86 a5       	ldd	r24, Z+46	; 0x2e
    3cfe:	8f 5f       	subi	r24, 0xFF	; 255
    3d00:	86 a7       	std	Z+46, r24	; 0x2e
		}

		return pxCurrentTCB;
    3d02:	80 91 41 05 	lds	r24, 0x0541
    3d06:	90 91 42 05 	lds	r25, 0x0542
	}
    3d0a:	cf 91       	pop	r28
    3d0c:	df 91       	pop	r29
    3d0e:	08 95       	ret

00003d10 <M_DIO_void_DIOInit>:
 *  Description : This Function Initialize the DIO Pins [ I/P (Pull-up or floating ) - O/P (High or Low) ]
 * ----------------------------------------------------------------------------------------------
 */

void M_DIO_void_DIOInit(void)
{
    3d10:	df 93       	push	r29
    3d12:	cf 93       	push	r28
    3d14:	cd b7       	in	r28, 0x3d	; 61
    3d16:	de b7       	in	r29, 0x3e	; 62
	/* Macros for initial Direction of PORTA */
  DIO_u8_DDRA_REG = CONC(DIO_u8_PA7_INTIAL_DIRECTION,DIO_u8_PA6_INTIAL_DIRECTION,
    3d18:	ea e3       	ldi	r30, 0x3A	; 58
    3d1a:	f0 e0       	ldi	r31, 0x00	; 0
    3d1c:	8f ef       	ldi	r24, 0xFF	; 255
    3d1e:	80 83       	st	Z, r24
		  	  	  	  	 DIO_u8_PA5_INTIAL_DIRECTION,DIO_u8_PA4_INTIAL_DIRECTION,
						 DIO_u8_PA3_INTIAL_DIRECTION,DIO_u8_PA2_INTIAL_DIRECTION,
						 DIO_u8_PA1_INTIAL_DIRECTION,DIO_u8_PA0_INTIAL_DIRECTION);
  /* Macros for initial Direction of PORTB */
  DIO_u8_DDRB_REG = CONC(DIO_u8_PB7_INTIAL_DIRECTION,DIO_u8_PB6_INTIAL_DIRECTION,
    3d20:	e7 e3       	ldi	r30, 0x37	; 55
    3d22:	f0 e0       	ldi	r31, 0x00	; 0
    3d24:	8f ef       	ldi	r24, 0xFF	; 255
    3d26:	80 83       	st	Z, r24
		  	  	  	  	 DIO_u8_PB5_INTIAL_DIRECTION,DIO_u8_PB4_INTIAL_DIRECTION,
						 DIO_u8_PB3_INTIAL_DIRECTION,DIO_u8_PB2_INTIAL_DIRECTION,
						 DIO_u8_PB1_INTIAL_DIRECTION,DIO_u8_PB0_INTIAL_DIRECTION);
  /* Macros for initial Direction of PORTC */
  DIO_u8_DDRC_REG = CONC(DIO_u8_PC7_INTIAL_DIRECTION,DIO_u8_PC6_INTIAL_DIRECTION,
    3d28:	e4 e3       	ldi	r30, 0x34	; 52
    3d2a:	f0 e0       	ldi	r31, 0x00	; 0
    3d2c:	87 ef       	ldi	r24, 0xF7	; 247
    3d2e:	80 83       	st	Z, r24
		  	  	  	  	 DIO_u8_PC5_INTIAL_DIRECTION,DIO_u8_PC4_INTIAL_DIRECTION,
						 DIO_u8_PC3_INTIAL_DIRECTION,DIO_u8_PC2_INTIAL_DIRECTION,
						 DIO_u8_PC1_INTIAL_DIRECTION,DIO_u8_PC0_INTIAL_DIRECTION);
  /* Macros for initial Direction of PORTD */
  DIO_u8_DDRD_REG = CONC(DIO_u8_PD7_INTIAL_DIRECTION,DIO_u8_PD6_INTIAL_DIRECTION,
    3d30:	e1 e3       	ldi	r30, 0x31	; 49
    3d32:	f0 e0       	ldi	r31, 0x00	; 0
    3d34:	8f ef       	ldi	r24, 0xFF	; 255
    3d36:	80 83       	st	Z, r24
		  	  	  	  	 DIO_u8_PD5_INTIAL_DIRECTION,DIO_u8_PD4_INTIAL_DIRECTION,
						 DIO_u8_PD3_INTIAL_DIRECTION,DIO_u8_PD2_INTIAL_DIRECTION,
						 DIO_u8_PD1_INTIAL_DIRECTION,DIO_u8_PD0_INTIAL_DIRECTION);

  /* Macros for initial values of PORTA */
  DIO_u8_PORTA_REG = CONC(DIO_u8_PA7_INTIAL_VALUE,DIO_u8_PA6_INTIAL_VALUE,
    3d38:	eb e3       	ldi	r30, 0x3B	; 59
    3d3a:	f0 e0       	ldi	r31, 0x00	; 0
    3d3c:	10 82       	st	Z, r1
		  	  	  	  	  DIO_u8_PA5_INTIAL_VALUE,DIO_u8_PA4_INTIAL_VALUE,
						  DIO_u8_PA3_INTIAL_VALUE,DIO_u8_PA2_INTIAL_VALUE,
						  DIO_u8_PA1_INTIAL_VALUE,DIO_u8_PA0_INTIAL_VALUE);
  /* Macros for initial values of PORTB */
  DIO_u8_PORTB_REG = CONC(DIO_u8_PB7_INTIAL_VALUE,DIO_u8_PB6_INTIAL_VALUE,
    3d3e:	e8 e3       	ldi	r30, 0x38	; 56
    3d40:	f0 e0       	ldi	r31, 0x00	; 0
    3d42:	10 82       	st	Z, r1
  		  	  	  	  	  DIO_u8_PB5_INTIAL_VALUE,DIO_u8_PB4_INTIAL_VALUE,
  						  DIO_u8_PB3_INTIAL_VALUE,DIO_u8_PB2_INTIAL_VALUE,
  						  DIO_u8_PB1_INTIAL_VALUE,DIO_u8_PB0_INTIAL_VALUE);
    /* Macros for initial values of PORTC */
   DIO_u8_PORTC_REG = CONC(DIO_u8_PC7_INTIAL_VALUE,DIO_u8_PC6_INTIAL_VALUE,
    3d44:	e5 e3       	ldi	r30, 0x35	; 53
    3d46:	f0 e0       	ldi	r31, 0x00	; 0
    3d48:	88 e0       	ldi	r24, 0x08	; 8
    3d4a:	80 83       	st	Z, r24
    		  	  	  	   DIO_u8_PC5_INTIAL_VALUE,DIO_u8_PC4_INTIAL_VALUE,
    					   DIO_u8_PC3_INTIAL_VALUE,DIO_u8_PC2_INTIAL_VALUE,
    					   DIO_u8_PC1_INTIAL_VALUE,DIO_u8_PC0_INTIAL_VALUE);
      /* Macros for initial values of PORTD */
    DIO_u8_PORTD_REG = CONC(DIO_u8_PD7_INTIAL_VALUE,DIO_u8_PD6_INTIAL_VALUE,
    3d4c:	e2 e3       	ldi	r30, 0x32	; 50
    3d4e:	f0 e0       	ldi	r31, 0x00	; 0
    3d50:	10 82       	st	Z, r1
      		  	  	  	  	DIO_u8_PD5_INTIAL_VALUE,DIO_u8_PD4_INTIAL_VALUE,
      						DIO_u8_PD3_INTIAL_VALUE,DIO_u8_PD2_INTIAL_VALUE,
      						DIO_u8_PD1_INTIAL_VALUE,DIO_u8_PD0_INTIAL_VALUE);

}
    3d52:	cf 91       	pop	r28
    3d54:	df 91       	pop	r29
    3d56:	08 95       	ret

00003d58 <M_DIO_u8_SetPinDirection>:
 /* Return type :(u8 variable)        Error State  (ERROR, NO_ERROR)
 *  Description : This Function Sets the Direction of a specific pin (I/P - O/P)
 * ----------------------------------------------------------------------------------------------
 */
u8 M_DIO_u8_SetPinDirection(u8 Copy_u8PortNumber , u8 Copy_u8PinNumber, u8 Copy_u8Direction )
{
    3d58:	df 93       	push	r29
    3d5a:	cf 93       	push	r28
    3d5c:	cd b7       	in	r28, 0x3d	; 61
    3d5e:	de b7       	in	r29, 0x3e	; 62
    3d60:	28 97       	sbiw	r28, 0x08	; 8
    3d62:	0f b6       	in	r0, 0x3f	; 63
    3d64:	f8 94       	cli
    3d66:	de bf       	out	0x3e, r29	; 62
    3d68:	0f be       	out	0x3f, r0	; 63
    3d6a:	cd bf       	out	0x3d, r28	; 61
    3d6c:	8a 83       	std	Y+2, r24	; 0x02
    3d6e:	6b 83       	std	Y+3, r22	; 0x03
    3d70:	4c 83       	std	Y+4, r20	; 0x04
	/* Error State variable  */
	u8 Local_u8ErrorState = ERROR ;
    3d72:	81 e0       	ldi	r24, 0x01	; 1
    3d74:	89 83       	std	Y+1, r24	; 0x01

	/* Input validation ( check if the port Number and Pin Number are in the valid range )*/
	if ((Copy_u8PortNumber <= DIO_u8_PORTD) && (Copy_u8PinNumber <= DIO_u8_PIN7))
    3d76:	8a 81       	ldd	r24, Y+2	; 0x02
    3d78:	84 30       	cpi	r24, 0x04	; 4
    3d7a:	08 f0       	brcs	.+2      	; 0x3d7e <M_DIO_u8_SetPinDirection+0x26>
    3d7c:	f2 c0       	rjmp	.+484    	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
    3d7e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d80:	88 30       	cpi	r24, 0x08	; 8
    3d82:	08 f0       	brcs	.+2      	; 0x3d86 <M_DIO_u8_SetPinDirection+0x2e>
    3d84:	ee c0       	rjmp	.+476    	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
	{
		Local_u8ErrorState = NO_ERROR;
    3d86:	19 82       	std	Y+1, r1	; 0x01

		if (Copy_u8Direction == DIO_u8_PIN_OUTPUT_DIRECTION) /* check the direction */
    3d88:	8c 81       	ldd	r24, Y+4	; 0x04
    3d8a:	88 23       	and	r24, r24
    3d8c:	09 f0       	breq	.+2      	; 0x3d90 <M_DIO_u8_SetPinDirection+0x38>
    3d8e:	6f c0       	rjmp	.+222    	; 0x3e6e <M_DIO_u8_SetPinDirection+0x116>
		{
			switch (Copy_u8PortNumber) /* check the port Number */
    3d90:	8a 81       	ldd	r24, Y+2	; 0x02
    3d92:	28 2f       	mov	r18, r24
    3d94:	30 e0       	ldi	r19, 0x00	; 0
    3d96:	38 87       	std	Y+8, r19	; 0x08
    3d98:	2f 83       	std	Y+7, r18	; 0x07
    3d9a:	8f 81       	ldd	r24, Y+7	; 0x07
    3d9c:	98 85       	ldd	r25, Y+8	; 0x08
    3d9e:	81 30       	cpi	r24, 0x01	; 1
    3da0:	91 05       	cpc	r25, r1
    3da2:	49 f1       	breq	.+82     	; 0x3df6 <M_DIO_u8_SetPinDirection+0x9e>
    3da4:	2f 81       	ldd	r18, Y+7	; 0x07
    3da6:	38 85       	ldd	r19, Y+8	; 0x08
    3da8:	22 30       	cpi	r18, 0x02	; 2
    3daa:	31 05       	cpc	r19, r1
    3dac:	2c f4       	brge	.+10     	; 0x3db8 <M_DIO_u8_SetPinDirection+0x60>
    3dae:	8f 81       	ldd	r24, Y+7	; 0x07
    3db0:	98 85       	ldd	r25, Y+8	; 0x08
    3db2:	00 97       	sbiw	r24, 0x00	; 0
    3db4:	61 f0       	breq	.+24     	; 0x3dce <M_DIO_u8_SetPinDirection+0x76>
    3db6:	d5 c0       	rjmp	.+426    	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
    3db8:	2f 81       	ldd	r18, Y+7	; 0x07
    3dba:	38 85       	ldd	r19, Y+8	; 0x08
    3dbc:	22 30       	cpi	r18, 0x02	; 2
    3dbe:	31 05       	cpc	r19, r1
    3dc0:	71 f1       	breq	.+92     	; 0x3e1e <M_DIO_u8_SetPinDirection+0xc6>
    3dc2:	8f 81       	ldd	r24, Y+7	; 0x07
    3dc4:	98 85       	ldd	r25, Y+8	; 0x08
    3dc6:	83 30       	cpi	r24, 0x03	; 3
    3dc8:	91 05       	cpc	r25, r1
    3dca:	e9 f1       	breq	.+122    	; 0x3e46 <M_DIO_u8_SetPinDirection+0xee>
    3dcc:	ca c0       	rjmp	.+404    	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
			{
			case DIO_u8_PORTA : SET_BIT(DIO_u8_DDRA_REG,Copy_u8PinNumber) ; break;
    3dce:	aa e3       	ldi	r26, 0x3A	; 58
    3dd0:	b0 e0       	ldi	r27, 0x00	; 0
    3dd2:	ea e3       	ldi	r30, 0x3A	; 58
    3dd4:	f0 e0       	ldi	r31, 0x00	; 0
    3dd6:	80 81       	ld	r24, Z
    3dd8:	48 2f       	mov	r20, r24
    3dda:	8b 81       	ldd	r24, Y+3	; 0x03
    3ddc:	28 2f       	mov	r18, r24
    3dde:	30 e0       	ldi	r19, 0x00	; 0
    3de0:	81 e0       	ldi	r24, 0x01	; 1
    3de2:	90 e0       	ldi	r25, 0x00	; 0
    3de4:	02 2e       	mov	r0, r18
    3de6:	02 c0       	rjmp	.+4      	; 0x3dec <M_DIO_u8_SetPinDirection+0x94>
    3de8:	88 0f       	add	r24, r24
    3dea:	99 1f       	adc	r25, r25
    3dec:	0a 94       	dec	r0
    3dee:	e2 f7       	brpl	.-8      	; 0x3de8 <M_DIO_u8_SetPinDirection+0x90>
    3df0:	84 2b       	or	r24, r20
    3df2:	8c 93       	st	X, r24
    3df4:	b6 c0       	rjmp	.+364    	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
			case DIO_u8_PORTB : SET_BIT(DIO_u8_DDRB_REG,Copy_u8PinNumber) ; break;
    3df6:	a7 e3       	ldi	r26, 0x37	; 55
    3df8:	b0 e0       	ldi	r27, 0x00	; 0
    3dfa:	e7 e3       	ldi	r30, 0x37	; 55
    3dfc:	f0 e0       	ldi	r31, 0x00	; 0
    3dfe:	80 81       	ld	r24, Z
    3e00:	48 2f       	mov	r20, r24
    3e02:	8b 81       	ldd	r24, Y+3	; 0x03
    3e04:	28 2f       	mov	r18, r24
    3e06:	30 e0       	ldi	r19, 0x00	; 0
    3e08:	81 e0       	ldi	r24, 0x01	; 1
    3e0a:	90 e0       	ldi	r25, 0x00	; 0
    3e0c:	02 2e       	mov	r0, r18
    3e0e:	02 c0       	rjmp	.+4      	; 0x3e14 <M_DIO_u8_SetPinDirection+0xbc>
    3e10:	88 0f       	add	r24, r24
    3e12:	99 1f       	adc	r25, r25
    3e14:	0a 94       	dec	r0
    3e16:	e2 f7       	brpl	.-8      	; 0x3e10 <M_DIO_u8_SetPinDirection+0xb8>
    3e18:	84 2b       	or	r24, r20
    3e1a:	8c 93       	st	X, r24
    3e1c:	a2 c0       	rjmp	.+324    	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
			case DIO_u8_PORTC : SET_BIT(DIO_u8_DDRC_REG,Copy_u8PinNumber) ; break;
    3e1e:	a4 e3       	ldi	r26, 0x34	; 52
    3e20:	b0 e0       	ldi	r27, 0x00	; 0
    3e22:	e4 e3       	ldi	r30, 0x34	; 52
    3e24:	f0 e0       	ldi	r31, 0x00	; 0
    3e26:	80 81       	ld	r24, Z
    3e28:	48 2f       	mov	r20, r24
    3e2a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e2c:	28 2f       	mov	r18, r24
    3e2e:	30 e0       	ldi	r19, 0x00	; 0
    3e30:	81 e0       	ldi	r24, 0x01	; 1
    3e32:	90 e0       	ldi	r25, 0x00	; 0
    3e34:	02 2e       	mov	r0, r18
    3e36:	02 c0       	rjmp	.+4      	; 0x3e3c <M_DIO_u8_SetPinDirection+0xe4>
    3e38:	88 0f       	add	r24, r24
    3e3a:	99 1f       	adc	r25, r25
    3e3c:	0a 94       	dec	r0
    3e3e:	e2 f7       	brpl	.-8      	; 0x3e38 <M_DIO_u8_SetPinDirection+0xe0>
    3e40:	84 2b       	or	r24, r20
    3e42:	8c 93       	st	X, r24
    3e44:	8e c0       	rjmp	.+284    	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
			case DIO_u8_PORTD : SET_BIT(DIO_u8_DDRD_REG,Copy_u8PinNumber) ; break;
    3e46:	a1 e3       	ldi	r26, 0x31	; 49
    3e48:	b0 e0       	ldi	r27, 0x00	; 0
    3e4a:	e1 e3       	ldi	r30, 0x31	; 49
    3e4c:	f0 e0       	ldi	r31, 0x00	; 0
    3e4e:	80 81       	ld	r24, Z
    3e50:	48 2f       	mov	r20, r24
    3e52:	8b 81       	ldd	r24, Y+3	; 0x03
    3e54:	28 2f       	mov	r18, r24
    3e56:	30 e0       	ldi	r19, 0x00	; 0
    3e58:	81 e0       	ldi	r24, 0x01	; 1
    3e5a:	90 e0       	ldi	r25, 0x00	; 0
    3e5c:	02 2e       	mov	r0, r18
    3e5e:	02 c0       	rjmp	.+4      	; 0x3e64 <M_DIO_u8_SetPinDirection+0x10c>
    3e60:	88 0f       	add	r24, r24
    3e62:	99 1f       	adc	r25, r25
    3e64:	0a 94       	dec	r0
    3e66:	e2 f7       	brpl	.-8      	; 0x3e60 <M_DIO_u8_SetPinDirection+0x108>
    3e68:	84 2b       	or	r24, r20
    3e6a:	8c 93       	st	X, r24
    3e6c:	7a c0       	rjmp	.+244    	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
			}
		}

		else if (Copy_u8Direction == DIO_u8_PIN_INPUT_DIRECTION) /* check the direction */
    3e6e:	8c 81       	ldd	r24, Y+4	; 0x04
    3e70:	81 30       	cpi	r24, 0x01	; 1
    3e72:	09 f0       	breq	.+2      	; 0x3e76 <M_DIO_u8_SetPinDirection+0x11e>
    3e74:	74 c0       	rjmp	.+232    	; 0x3f5e <M_DIO_u8_SetPinDirection+0x206>
		{
			switch (Copy_u8PortNumber) /* check the port Number */
    3e76:	8a 81       	ldd	r24, Y+2	; 0x02
    3e78:	28 2f       	mov	r18, r24
    3e7a:	30 e0       	ldi	r19, 0x00	; 0
    3e7c:	3e 83       	std	Y+6, r19	; 0x06
    3e7e:	2d 83       	std	Y+5, r18	; 0x05
    3e80:	8d 81       	ldd	r24, Y+5	; 0x05
    3e82:	9e 81       	ldd	r25, Y+6	; 0x06
    3e84:	81 30       	cpi	r24, 0x01	; 1
    3e86:	91 05       	cpc	r25, r1
    3e88:	59 f1       	breq	.+86     	; 0x3ee0 <M_DIO_u8_SetPinDirection+0x188>
    3e8a:	2d 81       	ldd	r18, Y+5	; 0x05
    3e8c:	3e 81       	ldd	r19, Y+6	; 0x06
    3e8e:	22 30       	cpi	r18, 0x02	; 2
    3e90:	31 05       	cpc	r19, r1
    3e92:	2c f4       	brge	.+10     	; 0x3e9e <M_DIO_u8_SetPinDirection+0x146>
    3e94:	8d 81       	ldd	r24, Y+5	; 0x05
    3e96:	9e 81       	ldd	r25, Y+6	; 0x06
    3e98:	00 97       	sbiw	r24, 0x00	; 0
    3e9a:	69 f0       	breq	.+26     	; 0x3eb6 <M_DIO_u8_SetPinDirection+0x15e>
    3e9c:	62 c0       	rjmp	.+196    	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
    3e9e:	2d 81       	ldd	r18, Y+5	; 0x05
    3ea0:	3e 81       	ldd	r19, Y+6	; 0x06
    3ea2:	22 30       	cpi	r18, 0x02	; 2
    3ea4:	31 05       	cpc	r19, r1
    3ea6:	89 f1       	breq	.+98     	; 0x3f0a <M_DIO_u8_SetPinDirection+0x1b2>
    3ea8:	8d 81       	ldd	r24, Y+5	; 0x05
    3eaa:	9e 81       	ldd	r25, Y+6	; 0x06
    3eac:	83 30       	cpi	r24, 0x03	; 3
    3eae:	91 05       	cpc	r25, r1
    3eb0:	09 f4       	brne	.+2      	; 0x3eb4 <M_DIO_u8_SetPinDirection+0x15c>
    3eb2:	40 c0       	rjmp	.+128    	; 0x3f34 <M_DIO_u8_SetPinDirection+0x1dc>
    3eb4:	56 c0       	rjmp	.+172    	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
			{
			case DIO_u8_PORTA : CLR_BIT(DIO_u8_DDRA_REG,Copy_u8PinNumber) ; break;
    3eb6:	aa e3       	ldi	r26, 0x3A	; 58
    3eb8:	b0 e0       	ldi	r27, 0x00	; 0
    3eba:	ea e3       	ldi	r30, 0x3A	; 58
    3ebc:	f0 e0       	ldi	r31, 0x00	; 0
    3ebe:	80 81       	ld	r24, Z
    3ec0:	48 2f       	mov	r20, r24
    3ec2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ec4:	28 2f       	mov	r18, r24
    3ec6:	30 e0       	ldi	r19, 0x00	; 0
    3ec8:	81 e0       	ldi	r24, 0x01	; 1
    3eca:	90 e0       	ldi	r25, 0x00	; 0
    3ecc:	02 2e       	mov	r0, r18
    3ece:	02 c0       	rjmp	.+4      	; 0x3ed4 <M_DIO_u8_SetPinDirection+0x17c>
    3ed0:	88 0f       	add	r24, r24
    3ed2:	99 1f       	adc	r25, r25
    3ed4:	0a 94       	dec	r0
    3ed6:	e2 f7       	brpl	.-8      	; 0x3ed0 <M_DIO_u8_SetPinDirection+0x178>
    3ed8:	80 95       	com	r24
    3eda:	84 23       	and	r24, r20
    3edc:	8c 93       	st	X, r24
    3ede:	41 c0       	rjmp	.+130    	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
			case DIO_u8_PORTB : CLR_BIT(DIO_u8_DDRB_REG,Copy_u8PinNumber) ; break;
    3ee0:	a7 e3       	ldi	r26, 0x37	; 55
    3ee2:	b0 e0       	ldi	r27, 0x00	; 0
    3ee4:	e7 e3       	ldi	r30, 0x37	; 55
    3ee6:	f0 e0       	ldi	r31, 0x00	; 0
    3ee8:	80 81       	ld	r24, Z
    3eea:	48 2f       	mov	r20, r24
    3eec:	8b 81       	ldd	r24, Y+3	; 0x03
    3eee:	28 2f       	mov	r18, r24
    3ef0:	30 e0       	ldi	r19, 0x00	; 0
    3ef2:	81 e0       	ldi	r24, 0x01	; 1
    3ef4:	90 e0       	ldi	r25, 0x00	; 0
    3ef6:	02 2e       	mov	r0, r18
    3ef8:	02 c0       	rjmp	.+4      	; 0x3efe <M_DIO_u8_SetPinDirection+0x1a6>
    3efa:	88 0f       	add	r24, r24
    3efc:	99 1f       	adc	r25, r25
    3efe:	0a 94       	dec	r0
    3f00:	e2 f7       	brpl	.-8      	; 0x3efa <M_DIO_u8_SetPinDirection+0x1a2>
    3f02:	80 95       	com	r24
    3f04:	84 23       	and	r24, r20
    3f06:	8c 93       	st	X, r24
    3f08:	2c c0       	rjmp	.+88     	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
			case DIO_u8_PORTC : CLR_BIT(DIO_u8_DDRC_REG,Copy_u8PinNumber) ; break;
    3f0a:	a4 e3       	ldi	r26, 0x34	; 52
    3f0c:	b0 e0       	ldi	r27, 0x00	; 0
    3f0e:	e4 e3       	ldi	r30, 0x34	; 52
    3f10:	f0 e0       	ldi	r31, 0x00	; 0
    3f12:	80 81       	ld	r24, Z
    3f14:	48 2f       	mov	r20, r24
    3f16:	8b 81       	ldd	r24, Y+3	; 0x03
    3f18:	28 2f       	mov	r18, r24
    3f1a:	30 e0       	ldi	r19, 0x00	; 0
    3f1c:	81 e0       	ldi	r24, 0x01	; 1
    3f1e:	90 e0       	ldi	r25, 0x00	; 0
    3f20:	02 2e       	mov	r0, r18
    3f22:	02 c0       	rjmp	.+4      	; 0x3f28 <M_DIO_u8_SetPinDirection+0x1d0>
    3f24:	88 0f       	add	r24, r24
    3f26:	99 1f       	adc	r25, r25
    3f28:	0a 94       	dec	r0
    3f2a:	e2 f7       	brpl	.-8      	; 0x3f24 <M_DIO_u8_SetPinDirection+0x1cc>
    3f2c:	80 95       	com	r24
    3f2e:	84 23       	and	r24, r20
    3f30:	8c 93       	st	X, r24
    3f32:	17 c0       	rjmp	.+46     	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
			case DIO_u8_PORTD : CLR_BIT(DIO_u8_DDRD_REG,Copy_u8PinNumber) ; break;
    3f34:	a1 e3       	ldi	r26, 0x31	; 49
    3f36:	b0 e0       	ldi	r27, 0x00	; 0
    3f38:	e1 e3       	ldi	r30, 0x31	; 49
    3f3a:	f0 e0       	ldi	r31, 0x00	; 0
    3f3c:	80 81       	ld	r24, Z
    3f3e:	48 2f       	mov	r20, r24
    3f40:	8b 81       	ldd	r24, Y+3	; 0x03
    3f42:	28 2f       	mov	r18, r24
    3f44:	30 e0       	ldi	r19, 0x00	; 0
    3f46:	81 e0       	ldi	r24, 0x01	; 1
    3f48:	90 e0       	ldi	r25, 0x00	; 0
    3f4a:	02 2e       	mov	r0, r18
    3f4c:	02 c0       	rjmp	.+4      	; 0x3f52 <M_DIO_u8_SetPinDirection+0x1fa>
    3f4e:	88 0f       	add	r24, r24
    3f50:	99 1f       	adc	r25, r25
    3f52:	0a 94       	dec	r0
    3f54:	e2 f7       	brpl	.-8      	; 0x3f4e <M_DIO_u8_SetPinDirection+0x1f6>
    3f56:	80 95       	com	r24
    3f58:	84 23       	and	r24, r20
    3f5a:	8c 93       	st	X, r24
    3f5c:	02 c0       	rjmp	.+4      	; 0x3f62 <M_DIO_u8_SetPinDirection+0x20a>
			}
		}
		else /* Invalid Direction option */
		{
			 Local_u8ErrorState = ERROR ;
    3f5e:	81 e0       	ldi	r24, 0x01	; 1
    3f60:	89 83       	std	Y+1, r24	; 0x01
		}

	}


	return Local_u8ErrorState;
    3f62:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f64:	28 96       	adiw	r28, 0x08	; 8
    3f66:	0f b6       	in	r0, 0x3f	; 63
    3f68:	f8 94       	cli
    3f6a:	de bf       	out	0x3e, r29	; 62
    3f6c:	0f be       	out	0x3f, r0	; 63
    3f6e:	cd bf       	out	0x3d, r28	; 61
    3f70:	cf 91       	pop	r28
    3f72:	df 91       	pop	r29
    3f74:	08 95       	ret

00003f76 <M_DIO_u8_SetPinValue>:
 *  Description : This Function Sets the value of a specific pin (HIGH - LOW)
 * ----------------------------------------------------------------------------------------------
 */

u8 M_DIO_u8_SetPinValue (u8 Copy_u8PortNumber , u8 Copy_u8PinNumber, u8 Copy_u8Value)
{
    3f76:	df 93       	push	r29
    3f78:	cf 93       	push	r28
    3f7a:	cd b7       	in	r28, 0x3d	; 61
    3f7c:	de b7       	in	r29, 0x3e	; 62
    3f7e:	28 97       	sbiw	r28, 0x08	; 8
    3f80:	0f b6       	in	r0, 0x3f	; 63
    3f82:	f8 94       	cli
    3f84:	de bf       	out	0x3e, r29	; 62
    3f86:	0f be       	out	0x3f, r0	; 63
    3f88:	cd bf       	out	0x3d, r28	; 61
    3f8a:	8a 83       	std	Y+2, r24	; 0x02
    3f8c:	6b 83       	std	Y+3, r22	; 0x03
    3f8e:	4c 83       	std	Y+4, r20	; 0x04
	/* Error State variable  */
	u8 Local_u8ErrorState = ERROR ;
    3f90:	81 e0       	ldi	r24, 0x01	; 1
    3f92:	89 83       	std	Y+1, r24	; 0x01

	/* Input validation ( check if the port Number and Pin Number are in the valid range )*/
	if ((Copy_u8PortNumber <= DIO_u8_PORTD) && (Copy_u8PinNumber <= DIO_u8_PIN7))
    3f94:	8a 81       	ldd	r24, Y+2	; 0x02
    3f96:	84 30       	cpi	r24, 0x04	; 4
    3f98:	08 f0       	brcs	.+2      	; 0x3f9c <M_DIO_u8_SetPinValue+0x26>
    3f9a:	f2 c0       	rjmp	.+484    	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
    3f9c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f9e:	88 30       	cpi	r24, 0x08	; 8
    3fa0:	08 f0       	brcs	.+2      	; 0x3fa4 <M_DIO_u8_SetPinValue+0x2e>
    3fa2:	ee c0       	rjmp	.+476    	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
	{

		Local_u8ErrorState = NO_ERROR;
    3fa4:	19 82       	std	Y+1, r1	; 0x01

		if (Copy_u8Value == DIO_u8_PIN_VALUE_HIGH) /* check the direction */
    3fa6:	8c 81       	ldd	r24, Y+4	; 0x04
    3fa8:	81 30       	cpi	r24, 0x01	; 1
    3faa:	09 f0       	breq	.+2      	; 0x3fae <M_DIO_u8_SetPinValue+0x38>
    3fac:	6f c0       	rjmp	.+222    	; 0x408c <M_DIO_u8_SetPinValue+0x116>
		{
			switch (Copy_u8PortNumber) /* check the port Number */
    3fae:	8a 81       	ldd	r24, Y+2	; 0x02
    3fb0:	28 2f       	mov	r18, r24
    3fb2:	30 e0       	ldi	r19, 0x00	; 0
    3fb4:	38 87       	std	Y+8, r19	; 0x08
    3fb6:	2f 83       	std	Y+7, r18	; 0x07
    3fb8:	8f 81       	ldd	r24, Y+7	; 0x07
    3fba:	98 85       	ldd	r25, Y+8	; 0x08
    3fbc:	81 30       	cpi	r24, 0x01	; 1
    3fbe:	91 05       	cpc	r25, r1
    3fc0:	49 f1       	breq	.+82     	; 0x4014 <M_DIO_u8_SetPinValue+0x9e>
    3fc2:	2f 81       	ldd	r18, Y+7	; 0x07
    3fc4:	38 85       	ldd	r19, Y+8	; 0x08
    3fc6:	22 30       	cpi	r18, 0x02	; 2
    3fc8:	31 05       	cpc	r19, r1
    3fca:	2c f4       	brge	.+10     	; 0x3fd6 <M_DIO_u8_SetPinValue+0x60>
    3fcc:	8f 81       	ldd	r24, Y+7	; 0x07
    3fce:	98 85       	ldd	r25, Y+8	; 0x08
    3fd0:	00 97       	sbiw	r24, 0x00	; 0
    3fd2:	61 f0       	breq	.+24     	; 0x3fec <M_DIO_u8_SetPinValue+0x76>
    3fd4:	d5 c0       	rjmp	.+426    	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
    3fd6:	2f 81       	ldd	r18, Y+7	; 0x07
    3fd8:	38 85       	ldd	r19, Y+8	; 0x08
    3fda:	22 30       	cpi	r18, 0x02	; 2
    3fdc:	31 05       	cpc	r19, r1
    3fde:	71 f1       	breq	.+92     	; 0x403c <M_DIO_u8_SetPinValue+0xc6>
    3fe0:	8f 81       	ldd	r24, Y+7	; 0x07
    3fe2:	98 85       	ldd	r25, Y+8	; 0x08
    3fe4:	83 30       	cpi	r24, 0x03	; 3
    3fe6:	91 05       	cpc	r25, r1
    3fe8:	e9 f1       	breq	.+122    	; 0x4064 <M_DIO_u8_SetPinValue+0xee>
    3fea:	ca c0       	rjmp	.+404    	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
			{
			case DIO_u8_PORTA : SET_BIT(DIO_u8_PORTA_REG,Copy_u8PinNumber) ; break;
    3fec:	ab e3       	ldi	r26, 0x3B	; 59
    3fee:	b0 e0       	ldi	r27, 0x00	; 0
    3ff0:	eb e3       	ldi	r30, 0x3B	; 59
    3ff2:	f0 e0       	ldi	r31, 0x00	; 0
    3ff4:	80 81       	ld	r24, Z
    3ff6:	48 2f       	mov	r20, r24
    3ff8:	8b 81       	ldd	r24, Y+3	; 0x03
    3ffa:	28 2f       	mov	r18, r24
    3ffc:	30 e0       	ldi	r19, 0x00	; 0
    3ffe:	81 e0       	ldi	r24, 0x01	; 1
    4000:	90 e0       	ldi	r25, 0x00	; 0
    4002:	02 2e       	mov	r0, r18
    4004:	02 c0       	rjmp	.+4      	; 0x400a <M_DIO_u8_SetPinValue+0x94>
    4006:	88 0f       	add	r24, r24
    4008:	99 1f       	adc	r25, r25
    400a:	0a 94       	dec	r0
    400c:	e2 f7       	brpl	.-8      	; 0x4006 <M_DIO_u8_SetPinValue+0x90>
    400e:	84 2b       	or	r24, r20
    4010:	8c 93       	st	X, r24
    4012:	b6 c0       	rjmp	.+364    	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
			case DIO_u8_PORTB : SET_BIT(DIO_u8_PORTB_REG,Copy_u8PinNumber) ; break;
    4014:	a8 e3       	ldi	r26, 0x38	; 56
    4016:	b0 e0       	ldi	r27, 0x00	; 0
    4018:	e8 e3       	ldi	r30, 0x38	; 56
    401a:	f0 e0       	ldi	r31, 0x00	; 0
    401c:	80 81       	ld	r24, Z
    401e:	48 2f       	mov	r20, r24
    4020:	8b 81       	ldd	r24, Y+3	; 0x03
    4022:	28 2f       	mov	r18, r24
    4024:	30 e0       	ldi	r19, 0x00	; 0
    4026:	81 e0       	ldi	r24, 0x01	; 1
    4028:	90 e0       	ldi	r25, 0x00	; 0
    402a:	02 2e       	mov	r0, r18
    402c:	02 c0       	rjmp	.+4      	; 0x4032 <M_DIO_u8_SetPinValue+0xbc>
    402e:	88 0f       	add	r24, r24
    4030:	99 1f       	adc	r25, r25
    4032:	0a 94       	dec	r0
    4034:	e2 f7       	brpl	.-8      	; 0x402e <M_DIO_u8_SetPinValue+0xb8>
    4036:	84 2b       	or	r24, r20
    4038:	8c 93       	st	X, r24
    403a:	a2 c0       	rjmp	.+324    	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
			case DIO_u8_PORTC : SET_BIT(DIO_u8_PORTC_REG,Copy_u8PinNumber) ; break;
    403c:	a5 e3       	ldi	r26, 0x35	; 53
    403e:	b0 e0       	ldi	r27, 0x00	; 0
    4040:	e5 e3       	ldi	r30, 0x35	; 53
    4042:	f0 e0       	ldi	r31, 0x00	; 0
    4044:	80 81       	ld	r24, Z
    4046:	48 2f       	mov	r20, r24
    4048:	8b 81       	ldd	r24, Y+3	; 0x03
    404a:	28 2f       	mov	r18, r24
    404c:	30 e0       	ldi	r19, 0x00	; 0
    404e:	81 e0       	ldi	r24, 0x01	; 1
    4050:	90 e0       	ldi	r25, 0x00	; 0
    4052:	02 2e       	mov	r0, r18
    4054:	02 c0       	rjmp	.+4      	; 0x405a <M_DIO_u8_SetPinValue+0xe4>
    4056:	88 0f       	add	r24, r24
    4058:	99 1f       	adc	r25, r25
    405a:	0a 94       	dec	r0
    405c:	e2 f7       	brpl	.-8      	; 0x4056 <M_DIO_u8_SetPinValue+0xe0>
    405e:	84 2b       	or	r24, r20
    4060:	8c 93       	st	X, r24
    4062:	8e c0       	rjmp	.+284    	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
			case DIO_u8_PORTD : SET_BIT(DIO_u8_PORTD_REG,Copy_u8PinNumber) ; break;
    4064:	a2 e3       	ldi	r26, 0x32	; 50
    4066:	b0 e0       	ldi	r27, 0x00	; 0
    4068:	e2 e3       	ldi	r30, 0x32	; 50
    406a:	f0 e0       	ldi	r31, 0x00	; 0
    406c:	80 81       	ld	r24, Z
    406e:	48 2f       	mov	r20, r24
    4070:	8b 81       	ldd	r24, Y+3	; 0x03
    4072:	28 2f       	mov	r18, r24
    4074:	30 e0       	ldi	r19, 0x00	; 0
    4076:	81 e0       	ldi	r24, 0x01	; 1
    4078:	90 e0       	ldi	r25, 0x00	; 0
    407a:	02 2e       	mov	r0, r18
    407c:	02 c0       	rjmp	.+4      	; 0x4082 <M_DIO_u8_SetPinValue+0x10c>
    407e:	88 0f       	add	r24, r24
    4080:	99 1f       	adc	r25, r25
    4082:	0a 94       	dec	r0
    4084:	e2 f7       	brpl	.-8      	; 0x407e <M_DIO_u8_SetPinValue+0x108>
    4086:	84 2b       	or	r24, r20
    4088:	8c 93       	st	X, r24
    408a:	7a c0       	rjmp	.+244    	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
			}
		}

		else if (Copy_u8Value == DIO_u8_PIN_VALUE_LOW) /* check the direction */
    408c:	8c 81       	ldd	r24, Y+4	; 0x04
    408e:	88 23       	and	r24, r24
    4090:	09 f0       	breq	.+2      	; 0x4094 <M_DIO_u8_SetPinValue+0x11e>
    4092:	74 c0       	rjmp	.+232    	; 0x417c <M_DIO_u8_SetPinValue+0x206>
		{
			switch (Copy_u8PortNumber) /* check the port Number */
    4094:	8a 81       	ldd	r24, Y+2	; 0x02
    4096:	28 2f       	mov	r18, r24
    4098:	30 e0       	ldi	r19, 0x00	; 0
    409a:	3e 83       	std	Y+6, r19	; 0x06
    409c:	2d 83       	std	Y+5, r18	; 0x05
    409e:	8d 81       	ldd	r24, Y+5	; 0x05
    40a0:	9e 81       	ldd	r25, Y+6	; 0x06
    40a2:	81 30       	cpi	r24, 0x01	; 1
    40a4:	91 05       	cpc	r25, r1
    40a6:	59 f1       	breq	.+86     	; 0x40fe <M_DIO_u8_SetPinValue+0x188>
    40a8:	2d 81       	ldd	r18, Y+5	; 0x05
    40aa:	3e 81       	ldd	r19, Y+6	; 0x06
    40ac:	22 30       	cpi	r18, 0x02	; 2
    40ae:	31 05       	cpc	r19, r1
    40b0:	2c f4       	brge	.+10     	; 0x40bc <M_DIO_u8_SetPinValue+0x146>
    40b2:	8d 81       	ldd	r24, Y+5	; 0x05
    40b4:	9e 81       	ldd	r25, Y+6	; 0x06
    40b6:	00 97       	sbiw	r24, 0x00	; 0
    40b8:	69 f0       	breq	.+26     	; 0x40d4 <M_DIO_u8_SetPinValue+0x15e>
    40ba:	62 c0       	rjmp	.+196    	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
    40bc:	2d 81       	ldd	r18, Y+5	; 0x05
    40be:	3e 81       	ldd	r19, Y+6	; 0x06
    40c0:	22 30       	cpi	r18, 0x02	; 2
    40c2:	31 05       	cpc	r19, r1
    40c4:	89 f1       	breq	.+98     	; 0x4128 <M_DIO_u8_SetPinValue+0x1b2>
    40c6:	8d 81       	ldd	r24, Y+5	; 0x05
    40c8:	9e 81       	ldd	r25, Y+6	; 0x06
    40ca:	83 30       	cpi	r24, 0x03	; 3
    40cc:	91 05       	cpc	r25, r1
    40ce:	09 f4       	brne	.+2      	; 0x40d2 <M_DIO_u8_SetPinValue+0x15c>
    40d0:	40 c0       	rjmp	.+128    	; 0x4152 <M_DIO_u8_SetPinValue+0x1dc>
    40d2:	56 c0       	rjmp	.+172    	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
			{
			case DIO_u8_PORTA : CLR_BIT(DIO_u8_PORTA_REG,Copy_u8PinNumber) ; break;
    40d4:	ab e3       	ldi	r26, 0x3B	; 59
    40d6:	b0 e0       	ldi	r27, 0x00	; 0
    40d8:	eb e3       	ldi	r30, 0x3B	; 59
    40da:	f0 e0       	ldi	r31, 0x00	; 0
    40dc:	80 81       	ld	r24, Z
    40de:	48 2f       	mov	r20, r24
    40e0:	8b 81       	ldd	r24, Y+3	; 0x03
    40e2:	28 2f       	mov	r18, r24
    40e4:	30 e0       	ldi	r19, 0x00	; 0
    40e6:	81 e0       	ldi	r24, 0x01	; 1
    40e8:	90 e0       	ldi	r25, 0x00	; 0
    40ea:	02 2e       	mov	r0, r18
    40ec:	02 c0       	rjmp	.+4      	; 0x40f2 <M_DIO_u8_SetPinValue+0x17c>
    40ee:	88 0f       	add	r24, r24
    40f0:	99 1f       	adc	r25, r25
    40f2:	0a 94       	dec	r0
    40f4:	e2 f7       	brpl	.-8      	; 0x40ee <M_DIO_u8_SetPinValue+0x178>
    40f6:	80 95       	com	r24
    40f8:	84 23       	and	r24, r20
    40fa:	8c 93       	st	X, r24
    40fc:	41 c0       	rjmp	.+130    	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
			case DIO_u8_PORTB : CLR_BIT(DIO_u8_PORTB_REG,Copy_u8PinNumber) ; break;
    40fe:	a8 e3       	ldi	r26, 0x38	; 56
    4100:	b0 e0       	ldi	r27, 0x00	; 0
    4102:	e8 e3       	ldi	r30, 0x38	; 56
    4104:	f0 e0       	ldi	r31, 0x00	; 0
    4106:	80 81       	ld	r24, Z
    4108:	48 2f       	mov	r20, r24
    410a:	8b 81       	ldd	r24, Y+3	; 0x03
    410c:	28 2f       	mov	r18, r24
    410e:	30 e0       	ldi	r19, 0x00	; 0
    4110:	81 e0       	ldi	r24, 0x01	; 1
    4112:	90 e0       	ldi	r25, 0x00	; 0
    4114:	02 2e       	mov	r0, r18
    4116:	02 c0       	rjmp	.+4      	; 0x411c <M_DIO_u8_SetPinValue+0x1a6>
    4118:	88 0f       	add	r24, r24
    411a:	99 1f       	adc	r25, r25
    411c:	0a 94       	dec	r0
    411e:	e2 f7       	brpl	.-8      	; 0x4118 <M_DIO_u8_SetPinValue+0x1a2>
    4120:	80 95       	com	r24
    4122:	84 23       	and	r24, r20
    4124:	8c 93       	st	X, r24
    4126:	2c c0       	rjmp	.+88     	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
			case DIO_u8_PORTC : CLR_BIT(DIO_u8_PORTC_REG,Copy_u8PinNumber) ; break;
    4128:	a5 e3       	ldi	r26, 0x35	; 53
    412a:	b0 e0       	ldi	r27, 0x00	; 0
    412c:	e5 e3       	ldi	r30, 0x35	; 53
    412e:	f0 e0       	ldi	r31, 0x00	; 0
    4130:	80 81       	ld	r24, Z
    4132:	48 2f       	mov	r20, r24
    4134:	8b 81       	ldd	r24, Y+3	; 0x03
    4136:	28 2f       	mov	r18, r24
    4138:	30 e0       	ldi	r19, 0x00	; 0
    413a:	81 e0       	ldi	r24, 0x01	; 1
    413c:	90 e0       	ldi	r25, 0x00	; 0
    413e:	02 2e       	mov	r0, r18
    4140:	02 c0       	rjmp	.+4      	; 0x4146 <M_DIO_u8_SetPinValue+0x1d0>
    4142:	88 0f       	add	r24, r24
    4144:	99 1f       	adc	r25, r25
    4146:	0a 94       	dec	r0
    4148:	e2 f7       	brpl	.-8      	; 0x4142 <M_DIO_u8_SetPinValue+0x1cc>
    414a:	80 95       	com	r24
    414c:	84 23       	and	r24, r20
    414e:	8c 93       	st	X, r24
    4150:	17 c0       	rjmp	.+46     	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
			case DIO_u8_PORTD : CLR_BIT(DIO_u8_PORTD_REG,Copy_u8PinNumber) ; break;
    4152:	a2 e3       	ldi	r26, 0x32	; 50
    4154:	b0 e0       	ldi	r27, 0x00	; 0
    4156:	e2 e3       	ldi	r30, 0x32	; 50
    4158:	f0 e0       	ldi	r31, 0x00	; 0
    415a:	80 81       	ld	r24, Z
    415c:	48 2f       	mov	r20, r24
    415e:	8b 81       	ldd	r24, Y+3	; 0x03
    4160:	28 2f       	mov	r18, r24
    4162:	30 e0       	ldi	r19, 0x00	; 0
    4164:	81 e0       	ldi	r24, 0x01	; 1
    4166:	90 e0       	ldi	r25, 0x00	; 0
    4168:	02 2e       	mov	r0, r18
    416a:	02 c0       	rjmp	.+4      	; 0x4170 <M_DIO_u8_SetPinValue+0x1fa>
    416c:	88 0f       	add	r24, r24
    416e:	99 1f       	adc	r25, r25
    4170:	0a 94       	dec	r0
    4172:	e2 f7       	brpl	.-8      	; 0x416c <M_DIO_u8_SetPinValue+0x1f6>
    4174:	80 95       	com	r24
    4176:	84 23       	and	r24, r20
    4178:	8c 93       	st	X, r24
    417a:	02 c0       	rjmp	.+4      	; 0x4180 <M_DIO_u8_SetPinValue+0x20a>
			}
		}
		else /* Invalid Direction option */
		{
			Local_u8ErrorState = ERROR ;
    417c:	81 e0       	ldi	r24, 0x01	; 1
    417e:	89 83       	std	Y+1, r24	; 0x01
		}

	}

	return Local_u8ErrorState;
    4180:	89 81       	ldd	r24, Y+1	; 0x01
}
    4182:	28 96       	adiw	r28, 0x08	; 8
    4184:	0f b6       	in	r0, 0x3f	; 63
    4186:	f8 94       	cli
    4188:	de bf       	out	0x3e, r29	; 62
    418a:	0f be       	out	0x3f, r0	; 63
    418c:	cd bf       	out	0x3d, r28	; 61
    418e:	cf 91       	pop	r28
    4190:	df 91       	pop	r29
    4192:	08 95       	ret

00004194 <M_DIO_u8_GetPinValue>:
 *  Description : This Function Gets the value of a specific pin (HIGH - LOW)
 * ----------------------------------------------------------------------------------------------
 */

u8 M_DIO_u8_GetPinValue (u8 Copy_u8PortNumber,u8 Copy_u8PinNumber, u8 * Copy_Pu8PinValue)
{
    4194:	df 93       	push	r29
    4196:	cf 93       	push	r28
    4198:	cd b7       	in	r28, 0x3d	; 61
    419a:	de b7       	in	r29, 0x3e	; 62
    419c:	27 97       	sbiw	r28, 0x07	; 7
    419e:	0f b6       	in	r0, 0x3f	; 63
    41a0:	f8 94       	cli
    41a2:	de bf       	out	0x3e, r29	; 62
    41a4:	0f be       	out	0x3f, r0	; 63
    41a6:	cd bf       	out	0x3d, r28	; 61
    41a8:	8a 83       	std	Y+2, r24	; 0x02
    41aa:	6b 83       	std	Y+3, r22	; 0x03
    41ac:	5d 83       	std	Y+5, r21	; 0x05
    41ae:	4c 83       	std	Y+4, r20	; 0x04
	/* Error State variable  */
	u8 Local_u8ErrorState = ERROR ;
    41b0:	81 e0       	ldi	r24, 0x01	; 1
    41b2:	89 83       	std	Y+1, r24	; 0x01

	/* Input validation ( check if the port Number and Pin Number are in the valid range && if the user pass a Pointer)*/
	if ((Copy_u8PortNumber <= DIO_u8_PORTD) && (Copy_u8PinNumber <= DIO_u8_PIN7) && (Copy_Pu8PinValue != NULL))
    41b4:	8a 81       	ldd	r24, Y+2	; 0x02
    41b6:	84 30       	cpi	r24, 0x04	; 4
    41b8:	08 f0       	brcs	.+2      	; 0x41bc <M_DIO_u8_GetPinValue+0x28>
    41ba:	7a c0       	rjmp	.+244    	; 0x42b0 <M_DIO_u8_GetPinValue+0x11c>
    41bc:	8b 81       	ldd	r24, Y+3	; 0x03
    41be:	88 30       	cpi	r24, 0x08	; 8
    41c0:	08 f0       	brcs	.+2      	; 0x41c4 <M_DIO_u8_GetPinValue+0x30>
    41c2:	76 c0       	rjmp	.+236    	; 0x42b0 <M_DIO_u8_GetPinValue+0x11c>
    41c4:	8c 81       	ldd	r24, Y+4	; 0x04
    41c6:	9d 81       	ldd	r25, Y+5	; 0x05
    41c8:	00 97       	sbiw	r24, 0x00	; 0
    41ca:	09 f4       	brne	.+2      	; 0x41ce <M_DIO_u8_GetPinValue+0x3a>
    41cc:	71 c0       	rjmp	.+226    	; 0x42b0 <M_DIO_u8_GetPinValue+0x11c>
	{
		Local_u8ErrorState = NO_ERROR;
    41ce:	19 82       	std	Y+1, r1	; 0x01

		switch (Copy_u8PortNumber)/* check the port Number */
    41d0:	8a 81       	ldd	r24, Y+2	; 0x02
    41d2:	28 2f       	mov	r18, r24
    41d4:	30 e0       	ldi	r19, 0x00	; 0
    41d6:	3f 83       	std	Y+7, r19	; 0x07
    41d8:	2e 83       	std	Y+6, r18	; 0x06
    41da:	4e 81       	ldd	r20, Y+6	; 0x06
    41dc:	5f 81       	ldd	r21, Y+7	; 0x07
    41de:	41 30       	cpi	r20, 0x01	; 1
    41e0:	51 05       	cpc	r21, r1
    41e2:	59 f1       	breq	.+86     	; 0x423a <M_DIO_u8_GetPinValue+0xa6>
    41e4:	8e 81       	ldd	r24, Y+6	; 0x06
    41e6:	9f 81       	ldd	r25, Y+7	; 0x07
    41e8:	82 30       	cpi	r24, 0x02	; 2
    41ea:	91 05       	cpc	r25, r1
    41ec:	34 f4       	brge	.+12     	; 0x41fa <M_DIO_u8_GetPinValue+0x66>
    41ee:	2e 81       	ldd	r18, Y+6	; 0x06
    41f0:	3f 81       	ldd	r19, Y+7	; 0x07
    41f2:	21 15       	cp	r18, r1
    41f4:	31 05       	cpc	r19, r1
    41f6:	69 f0       	breq	.+26     	; 0x4212 <M_DIO_u8_GetPinValue+0x7e>
    41f8:	5b c0       	rjmp	.+182    	; 0x42b0 <M_DIO_u8_GetPinValue+0x11c>
    41fa:	4e 81       	ldd	r20, Y+6	; 0x06
    41fc:	5f 81       	ldd	r21, Y+7	; 0x07
    41fe:	42 30       	cpi	r20, 0x02	; 2
    4200:	51 05       	cpc	r21, r1
    4202:	79 f1       	breq	.+94     	; 0x4262 <M_DIO_u8_GetPinValue+0xce>
    4204:	8e 81       	ldd	r24, Y+6	; 0x06
    4206:	9f 81       	ldd	r25, Y+7	; 0x07
    4208:	83 30       	cpi	r24, 0x03	; 3
    420a:	91 05       	cpc	r25, r1
    420c:	09 f4       	brne	.+2      	; 0x4210 <M_DIO_u8_GetPinValue+0x7c>
    420e:	3d c0       	rjmp	.+122    	; 0x428a <M_DIO_u8_GetPinValue+0xf6>
    4210:	4f c0       	rjmp	.+158    	; 0x42b0 <M_DIO_u8_GetPinValue+0x11c>
		{
			case DIO_u8_PORTA : *Copy_Pu8PinValue =GET_BIT(DIO_u8_PINA_REG,Copy_u8PinNumber);break; /* update the variable with Pin value*/
    4212:	e9 e3       	ldi	r30, 0x39	; 57
    4214:	f0 e0       	ldi	r31, 0x00	; 0
    4216:	80 81       	ld	r24, Z
    4218:	28 2f       	mov	r18, r24
    421a:	30 e0       	ldi	r19, 0x00	; 0
    421c:	8b 81       	ldd	r24, Y+3	; 0x03
    421e:	88 2f       	mov	r24, r24
    4220:	90 e0       	ldi	r25, 0x00	; 0
    4222:	a9 01       	movw	r20, r18
    4224:	02 c0       	rjmp	.+4      	; 0x422a <M_DIO_u8_GetPinValue+0x96>
    4226:	55 95       	asr	r21
    4228:	47 95       	ror	r20
    422a:	8a 95       	dec	r24
    422c:	e2 f7       	brpl	.-8      	; 0x4226 <M_DIO_u8_GetPinValue+0x92>
    422e:	ca 01       	movw	r24, r20
    4230:	81 70       	andi	r24, 0x01	; 1
    4232:	ec 81       	ldd	r30, Y+4	; 0x04
    4234:	fd 81       	ldd	r31, Y+5	; 0x05
    4236:	80 83       	st	Z, r24
    4238:	3b c0       	rjmp	.+118    	; 0x42b0 <M_DIO_u8_GetPinValue+0x11c>
			case DIO_u8_PORTB : *Copy_Pu8PinValue =GET_BIT(DIO_u8_PINB_REG,Copy_u8PinNumber);break;  /* update the variable with Pin value*/
    423a:	e6 e3       	ldi	r30, 0x36	; 54
    423c:	f0 e0       	ldi	r31, 0x00	; 0
    423e:	80 81       	ld	r24, Z
    4240:	28 2f       	mov	r18, r24
    4242:	30 e0       	ldi	r19, 0x00	; 0
    4244:	8b 81       	ldd	r24, Y+3	; 0x03
    4246:	88 2f       	mov	r24, r24
    4248:	90 e0       	ldi	r25, 0x00	; 0
    424a:	a9 01       	movw	r20, r18
    424c:	02 c0       	rjmp	.+4      	; 0x4252 <M_DIO_u8_GetPinValue+0xbe>
    424e:	55 95       	asr	r21
    4250:	47 95       	ror	r20
    4252:	8a 95       	dec	r24
    4254:	e2 f7       	brpl	.-8      	; 0x424e <M_DIO_u8_GetPinValue+0xba>
    4256:	ca 01       	movw	r24, r20
    4258:	81 70       	andi	r24, 0x01	; 1
    425a:	ec 81       	ldd	r30, Y+4	; 0x04
    425c:	fd 81       	ldd	r31, Y+5	; 0x05
    425e:	80 83       	st	Z, r24
    4260:	27 c0       	rjmp	.+78     	; 0x42b0 <M_DIO_u8_GetPinValue+0x11c>
			case DIO_u8_PORTC : *Copy_Pu8PinValue =GET_BIT(DIO_u8_PINC_REG,Copy_u8PinNumber);break; /* update the variable with Pin value*/
    4262:	e3 e3       	ldi	r30, 0x33	; 51
    4264:	f0 e0       	ldi	r31, 0x00	; 0
    4266:	80 81       	ld	r24, Z
    4268:	28 2f       	mov	r18, r24
    426a:	30 e0       	ldi	r19, 0x00	; 0
    426c:	8b 81       	ldd	r24, Y+3	; 0x03
    426e:	88 2f       	mov	r24, r24
    4270:	90 e0       	ldi	r25, 0x00	; 0
    4272:	a9 01       	movw	r20, r18
    4274:	02 c0       	rjmp	.+4      	; 0x427a <M_DIO_u8_GetPinValue+0xe6>
    4276:	55 95       	asr	r21
    4278:	47 95       	ror	r20
    427a:	8a 95       	dec	r24
    427c:	e2 f7       	brpl	.-8      	; 0x4276 <M_DIO_u8_GetPinValue+0xe2>
    427e:	ca 01       	movw	r24, r20
    4280:	81 70       	andi	r24, 0x01	; 1
    4282:	ec 81       	ldd	r30, Y+4	; 0x04
    4284:	fd 81       	ldd	r31, Y+5	; 0x05
    4286:	80 83       	st	Z, r24
    4288:	13 c0       	rjmp	.+38     	; 0x42b0 <M_DIO_u8_GetPinValue+0x11c>
			case DIO_u8_PORTD : *Copy_Pu8PinValue =GET_BIT(DIO_u8_PIND_REG,Copy_u8PinNumber);break; /* update the variable with Pin value*/
    428a:	e0 e3       	ldi	r30, 0x30	; 48
    428c:	f0 e0       	ldi	r31, 0x00	; 0
    428e:	80 81       	ld	r24, Z
    4290:	28 2f       	mov	r18, r24
    4292:	30 e0       	ldi	r19, 0x00	; 0
    4294:	8b 81       	ldd	r24, Y+3	; 0x03
    4296:	88 2f       	mov	r24, r24
    4298:	90 e0       	ldi	r25, 0x00	; 0
    429a:	a9 01       	movw	r20, r18
    429c:	02 c0       	rjmp	.+4      	; 0x42a2 <M_DIO_u8_GetPinValue+0x10e>
    429e:	55 95       	asr	r21
    42a0:	47 95       	ror	r20
    42a2:	8a 95       	dec	r24
    42a4:	e2 f7       	brpl	.-8      	; 0x429e <M_DIO_u8_GetPinValue+0x10a>
    42a6:	ca 01       	movw	r24, r20
    42a8:	81 70       	andi	r24, 0x01	; 1
    42aa:	ec 81       	ldd	r30, Y+4	; 0x04
    42ac:	fd 81       	ldd	r31, Y+5	; 0x05
    42ae:	80 83       	st	Z, r24
		}

	}

	return Local_u8ErrorState ;
    42b0:	89 81       	ldd	r24, Y+1	; 0x01

}
    42b2:	27 96       	adiw	r28, 0x07	; 7
    42b4:	0f b6       	in	r0, 0x3f	; 63
    42b6:	f8 94       	cli
    42b8:	de bf       	out	0x3e, r29	; 62
    42ba:	0f be       	out	0x3f, r0	; 63
    42bc:	cd bf       	out	0x3d, r28	; 61
    42be:	cf 91       	pop	r28
    42c0:	df 91       	pop	r29
    42c2:	08 95       	ret

000042c4 <M_DIO_u8_TogglePinValue>:
 *  Description : This Function Toggles the value of a specific Pin
 * ----------------------------------------------------------------------------------------------
 */

u8 M_DIO_u8_TogglePinValue (u8 Copy_u8PortNumber,u8 Copy_u8PinNumber)
{
    42c4:	df 93       	push	r29
    42c6:	cf 93       	push	r28
    42c8:	00 d0       	rcall	.+0      	; 0x42ca <M_DIO_u8_TogglePinValue+0x6>
    42ca:	00 d0       	rcall	.+0      	; 0x42cc <M_DIO_u8_TogglePinValue+0x8>
    42cc:	0f 92       	push	r0
    42ce:	cd b7       	in	r28, 0x3d	; 61
    42d0:	de b7       	in	r29, 0x3e	; 62
    42d2:	8a 83       	std	Y+2, r24	; 0x02
    42d4:	6b 83       	std	Y+3, r22	; 0x03
	/* Error State variable  */
	u8 Local_u8ErrorState = ERROR ;
    42d6:	81 e0       	ldi	r24, 0x01	; 1
    42d8:	89 83       	std	Y+1, r24	; 0x01

	/* Input validation ( check if the port Number and Pin Number are in the valid range) */
	if (Copy_u8PortNumber <= DIO_u8_PORTD && Copy_u8PinNumber <= DIO_u8_PIN7)
    42da:	8a 81       	ldd	r24, Y+2	; 0x02
    42dc:	84 30       	cpi	r24, 0x04	; 4
    42de:	08 f0       	brcs	.+2      	; 0x42e2 <M_DIO_u8_TogglePinValue+0x1e>
    42e0:	73 c0       	rjmp	.+230    	; 0x43c8 <M_DIO_u8_TogglePinValue+0x104>
    42e2:	8b 81       	ldd	r24, Y+3	; 0x03
    42e4:	88 30       	cpi	r24, 0x08	; 8
    42e6:	08 f0       	brcs	.+2      	; 0x42ea <M_DIO_u8_TogglePinValue+0x26>
    42e8:	6f c0       	rjmp	.+222    	; 0x43c8 <M_DIO_u8_TogglePinValue+0x104>
	{
		Local_u8ErrorState = NO_ERROR ;
    42ea:	19 82       	std	Y+1, r1	; 0x01

		switch (Copy_u8PortNumber ) /* check the port Number */
    42ec:	8a 81       	ldd	r24, Y+2	; 0x02
    42ee:	28 2f       	mov	r18, r24
    42f0:	30 e0       	ldi	r19, 0x00	; 0
    42f2:	3d 83       	std	Y+5, r19	; 0x05
    42f4:	2c 83       	std	Y+4, r18	; 0x04
    42f6:	8c 81       	ldd	r24, Y+4	; 0x04
    42f8:	9d 81       	ldd	r25, Y+5	; 0x05
    42fa:	81 30       	cpi	r24, 0x01	; 1
    42fc:	91 05       	cpc	r25, r1
    42fe:	49 f1       	breq	.+82     	; 0x4352 <M_DIO_u8_TogglePinValue+0x8e>
    4300:	2c 81       	ldd	r18, Y+4	; 0x04
    4302:	3d 81       	ldd	r19, Y+5	; 0x05
    4304:	22 30       	cpi	r18, 0x02	; 2
    4306:	31 05       	cpc	r19, r1
    4308:	2c f4       	brge	.+10     	; 0x4314 <M_DIO_u8_TogglePinValue+0x50>
    430a:	8c 81       	ldd	r24, Y+4	; 0x04
    430c:	9d 81       	ldd	r25, Y+5	; 0x05
    430e:	00 97       	sbiw	r24, 0x00	; 0
    4310:	61 f0       	breq	.+24     	; 0x432a <M_DIO_u8_TogglePinValue+0x66>
    4312:	5a c0       	rjmp	.+180    	; 0x43c8 <M_DIO_u8_TogglePinValue+0x104>
    4314:	2c 81       	ldd	r18, Y+4	; 0x04
    4316:	3d 81       	ldd	r19, Y+5	; 0x05
    4318:	22 30       	cpi	r18, 0x02	; 2
    431a:	31 05       	cpc	r19, r1
    431c:	71 f1       	breq	.+92     	; 0x437a <M_DIO_u8_TogglePinValue+0xb6>
    431e:	8c 81       	ldd	r24, Y+4	; 0x04
    4320:	9d 81       	ldd	r25, Y+5	; 0x05
    4322:	83 30       	cpi	r24, 0x03	; 3
    4324:	91 05       	cpc	r25, r1
    4326:	e9 f1       	breq	.+122    	; 0x43a2 <M_DIO_u8_TogglePinValue+0xde>
    4328:	4f c0       	rjmp	.+158    	; 0x43c8 <M_DIO_u8_TogglePinValue+0x104>
		{
		case DIO_u8_PORTA : TOG_BIT(DIO_u8_PORTA_REG,Copy_u8PinNumber); break;
    432a:	ab e3       	ldi	r26, 0x3B	; 59
    432c:	b0 e0       	ldi	r27, 0x00	; 0
    432e:	eb e3       	ldi	r30, 0x3B	; 59
    4330:	f0 e0       	ldi	r31, 0x00	; 0
    4332:	80 81       	ld	r24, Z
    4334:	48 2f       	mov	r20, r24
    4336:	8b 81       	ldd	r24, Y+3	; 0x03
    4338:	28 2f       	mov	r18, r24
    433a:	30 e0       	ldi	r19, 0x00	; 0
    433c:	81 e0       	ldi	r24, 0x01	; 1
    433e:	90 e0       	ldi	r25, 0x00	; 0
    4340:	02 2e       	mov	r0, r18
    4342:	02 c0       	rjmp	.+4      	; 0x4348 <M_DIO_u8_TogglePinValue+0x84>
    4344:	88 0f       	add	r24, r24
    4346:	99 1f       	adc	r25, r25
    4348:	0a 94       	dec	r0
    434a:	e2 f7       	brpl	.-8      	; 0x4344 <M_DIO_u8_TogglePinValue+0x80>
    434c:	84 27       	eor	r24, r20
    434e:	8c 93       	st	X, r24
    4350:	3b c0       	rjmp	.+118    	; 0x43c8 <M_DIO_u8_TogglePinValue+0x104>
		case DIO_u8_PORTB : TOG_BIT(DIO_u8_PORTB_REG,Copy_u8PinNumber); break;
    4352:	a8 e3       	ldi	r26, 0x38	; 56
    4354:	b0 e0       	ldi	r27, 0x00	; 0
    4356:	e8 e3       	ldi	r30, 0x38	; 56
    4358:	f0 e0       	ldi	r31, 0x00	; 0
    435a:	80 81       	ld	r24, Z
    435c:	48 2f       	mov	r20, r24
    435e:	8b 81       	ldd	r24, Y+3	; 0x03
    4360:	28 2f       	mov	r18, r24
    4362:	30 e0       	ldi	r19, 0x00	; 0
    4364:	81 e0       	ldi	r24, 0x01	; 1
    4366:	90 e0       	ldi	r25, 0x00	; 0
    4368:	02 2e       	mov	r0, r18
    436a:	02 c0       	rjmp	.+4      	; 0x4370 <M_DIO_u8_TogglePinValue+0xac>
    436c:	88 0f       	add	r24, r24
    436e:	99 1f       	adc	r25, r25
    4370:	0a 94       	dec	r0
    4372:	e2 f7       	brpl	.-8      	; 0x436c <M_DIO_u8_TogglePinValue+0xa8>
    4374:	84 27       	eor	r24, r20
    4376:	8c 93       	st	X, r24
    4378:	27 c0       	rjmp	.+78     	; 0x43c8 <M_DIO_u8_TogglePinValue+0x104>
		case DIO_u8_PORTC : TOG_BIT(DIO_u8_PORTC_REG,Copy_u8PinNumber); break;
    437a:	a5 e3       	ldi	r26, 0x35	; 53
    437c:	b0 e0       	ldi	r27, 0x00	; 0
    437e:	e5 e3       	ldi	r30, 0x35	; 53
    4380:	f0 e0       	ldi	r31, 0x00	; 0
    4382:	80 81       	ld	r24, Z
    4384:	48 2f       	mov	r20, r24
    4386:	8b 81       	ldd	r24, Y+3	; 0x03
    4388:	28 2f       	mov	r18, r24
    438a:	30 e0       	ldi	r19, 0x00	; 0
    438c:	81 e0       	ldi	r24, 0x01	; 1
    438e:	90 e0       	ldi	r25, 0x00	; 0
    4390:	02 2e       	mov	r0, r18
    4392:	02 c0       	rjmp	.+4      	; 0x4398 <M_DIO_u8_TogglePinValue+0xd4>
    4394:	88 0f       	add	r24, r24
    4396:	99 1f       	adc	r25, r25
    4398:	0a 94       	dec	r0
    439a:	e2 f7       	brpl	.-8      	; 0x4394 <M_DIO_u8_TogglePinValue+0xd0>
    439c:	84 27       	eor	r24, r20
    439e:	8c 93       	st	X, r24
    43a0:	13 c0       	rjmp	.+38     	; 0x43c8 <M_DIO_u8_TogglePinValue+0x104>
		case DIO_u8_PORTD : TOG_BIT(DIO_u8_PORTD_REG,Copy_u8PinNumber); break;
    43a2:	a2 e3       	ldi	r26, 0x32	; 50
    43a4:	b0 e0       	ldi	r27, 0x00	; 0
    43a6:	e2 e3       	ldi	r30, 0x32	; 50
    43a8:	f0 e0       	ldi	r31, 0x00	; 0
    43aa:	80 81       	ld	r24, Z
    43ac:	48 2f       	mov	r20, r24
    43ae:	8b 81       	ldd	r24, Y+3	; 0x03
    43b0:	28 2f       	mov	r18, r24
    43b2:	30 e0       	ldi	r19, 0x00	; 0
    43b4:	81 e0       	ldi	r24, 0x01	; 1
    43b6:	90 e0       	ldi	r25, 0x00	; 0
    43b8:	02 2e       	mov	r0, r18
    43ba:	02 c0       	rjmp	.+4      	; 0x43c0 <M_DIO_u8_TogglePinValue+0xfc>
    43bc:	88 0f       	add	r24, r24
    43be:	99 1f       	adc	r25, r25
    43c0:	0a 94       	dec	r0
    43c2:	e2 f7       	brpl	.-8      	; 0x43bc <M_DIO_u8_TogglePinValue+0xf8>
    43c4:	84 27       	eor	r24, r20
    43c6:	8c 93       	st	X, r24
		}


	}
	return Local_u8ErrorState;
    43c8:	89 81       	ldd	r24, Y+1	; 0x01

}
    43ca:	0f 90       	pop	r0
    43cc:	0f 90       	pop	r0
    43ce:	0f 90       	pop	r0
    43d0:	0f 90       	pop	r0
    43d2:	0f 90       	pop	r0
    43d4:	cf 91       	pop	r28
    43d6:	df 91       	pop	r29
    43d8:	08 95       	ret

000043da <M_DIO_u8_SetPortDirection>:
 *  Description : This Function Sets the Direction of a specific PORT (O/P - I/P)
 * ----------------------------------------------------------------------------------------------
 */

u8 M_DIO_u8_SetPortDirection (u8 Copy_u8PortNumber , u8 Copy_u8PortDirection )
{
    43da:	df 93       	push	r29
    43dc:	cf 93       	push	r28
    43de:	00 d0       	rcall	.+0      	; 0x43e0 <M_DIO_u8_SetPortDirection+0x6>
    43e0:	00 d0       	rcall	.+0      	; 0x43e2 <M_DIO_u8_SetPortDirection+0x8>
    43e2:	0f 92       	push	r0
    43e4:	cd b7       	in	r28, 0x3d	; 61
    43e6:	de b7       	in	r29, 0x3e	; 62
    43e8:	8a 83       	std	Y+2, r24	; 0x02
    43ea:	6b 83       	std	Y+3, r22	; 0x03
	/* Error State variable  */
	u8 Local_u8ErrorState = ERROR;
    43ec:	81 e0       	ldi	r24, 0x01	; 1
    43ee:	89 83       	std	Y+1, r24	; 0x01
	/* Input validation ( check if the port Number is in the valid range */
	if (Copy_u8PortNumber <= DIO_u8_PORTD )
    43f0:	8a 81       	ldd	r24, Y+2	; 0x02
    43f2:	84 30       	cpi	r24, 0x04	; 4
    43f4:	98 f5       	brcc	.+102    	; 0x445c <M_DIO_u8_SetPortDirection+0x82>
	{
		Local_u8ErrorState = NO_ERROR;
    43f6:	19 82       	std	Y+1, r1	; 0x01

		switch (Copy_u8PortNumber) /* check the port Number */
    43f8:	8a 81       	ldd	r24, Y+2	; 0x02
    43fa:	28 2f       	mov	r18, r24
    43fc:	30 e0       	ldi	r19, 0x00	; 0
    43fe:	3d 83       	std	Y+5, r19	; 0x05
    4400:	2c 83       	std	Y+4, r18	; 0x04
    4402:	8c 81       	ldd	r24, Y+4	; 0x04
    4404:	9d 81       	ldd	r25, Y+5	; 0x05
    4406:	81 30       	cpi	r24, 0x01	; 1
    4408:	91 05       	cpc	r25, r1
    440a:	d1 f0       	breq	.+52     	; 0x4440 <M_DIO_u8_SetPortDirection+0x66>
    440c:	2c 81       	ldd	r18, Y+4	; 0x04
    440e:	3d 81       	ldd	r19, Y+5	; 0x05
    4410:	22 30       	cpi	r18, 0x02	; 2
    4412:	31 05       	cpc	r19, r1
    4414:	2c f4       	brge	.+10     	; 0x4420 <M_DIO_u8_SetPortDirection+0x46>
    4416:	8c 81       	ldd	r24, Y+4	; 0x04
    4418:	9d 81       	ldd	r25, Y+5	; 0x05
    441a:	00 97       	sbiw	r24, 0x00	; 0
    441c:	61 f0       	breq	.+24     	; 0x4436 <M_DIO_u8_SetPortDirection+0x5c>
    441e:	1e c0       	rjmp	.+60     	; 0x445c <M_DIO_u8_SetPortDirection+0x82>
    4420:	2c 81       	ldd	r18, Y+4	; 0x04
    4422:	3d 81       	ldd	r19, Y+5	; 0x05
    4424:	22 30       	cpi	r18, 0x02	; 2
    4426:	31 05       	cpc	r19, r1
    4428:	81 f0       	breq	.+32     	; 0x444a <M_DIO_u8_SetPortDirection+0x70>
    442a:	8c 81       	ldd	r24, Y+4	; 0x04
    442c:	9d 81       	ldd	r25, Y+5	; 0x05
    442e:	83 30       	cpi	r24, 0x03	; 3
    4430:	91 05       	cpc	r25, r1
    4432:	81 f0       	breq	.+32     	; 0x4454 <M_DIO_u8_SetPortDirection+0x7a>
    4434:	13 c0       	rjmp	.+38     	; 0x445c <M_DIO_u8_SetPortDirection+0x82>
		{
			case DIO_u8_PORTA : DIO_u8_DDRA_REG = Copy_u8PortDirection ; break;
    4436:	ea e3       	ldi	r30, 0x3A	; 58
    4438:	f0 e0       	ldi	r31, 0x00	; 0
    443a:	8b 81       	ldd	r24, Y+3	; 0x03
    443c:	80 83       	st	Z, r24
    443e:	0e c0       	rjmp	.+28     	; 0x445c <M_DIO_u8_SetPortDirection+0x82>
			case DIO_u8_PORTB : DIO_u8_DDRB_REG = Copy_u8PortDirection ; break;
    4440:	e7 e3       	ldi	r30, 0x37	; 55
    4442:	f0 e0       	ldi	r31, 0x00	; 0
    4444:	8b 81       	ldd	r24, Y+3	; 0x03
    4446:	80 83       	st	Z, r24
    4448:	09 c0       	rjmp	.+18     	; 0x445c <M_DIO_u8_SetPortDirection+0x82>
			case DIO_u8_PORTC : DIO_u8_DDRC_REG = Copy_u8PortDirection ; break;
    444a:	e4 e3       	ldi	r30, 0x34	; 52
    444c:	f0 e0       	ldi	r31, 0x00	; 0
    444e:	8b 81       	ldd	r24, Y+3	; 0x03
    4450:	80 83       	st	Z, r24
    4452:	04 c0       	rjmp	.+8      	; 0x445c <M_DIO_u8_SetPortDirection+0x82>
			case DIO_u8_PORTD : DIO_u8_DDRD_REG = Copy_u8PortDirection ; break;
    4454:	e1 e3       	ldi	r30, 0x31	; 49
    4456:	f0 e0       	ldi	r31, 0x00	; 0
    4458:	8b 81       	ldd	r24, Y+3	; 0x03
    445a:	80 83       	st	Z, r24
		}

	}
	return Local_u8ErrorState;
    445c:	89 81       	ldd	r24, Y+1	; 0x01

}
    445e:	0f 90       	pop	r0
    4460:	0f 90       	pop	r0
    4462:	0f 90       	pop	r0
    4464:	0f 90       	pop	r0
    4466:	0f 90       	pop	r0
    4468:	cf 91       	pop	r28
    446a:	df 91       	pop	r29
    446c:	08 95       	ret

0000446e <M_DIO_u8_SetPortValue>:
 *  Description : This Function Sets the Value of a specific PORT (HIGH - LOW)
 * ----------------------------------------------------------------------------------------------
 */

u8 M_DIO_u8_SetPortValue (u8 Copy_u8PortNumber , u8 Copy_u8PortValue )
{
    446e:	df 93       	push	r29
    4470:	cf 93       	push	r28
    4472:	00 d0       	rcall	.+0      	; 0x4474 <M_DIO_u8_SetPortValue+0x6>
    4474:	00 d0       	rcall	.+0      	; 0x4476 <M_DIO_u8_SetPortValue+0x8>
    4476:	0f 92       	push	r0
    4478:	cd b7       	in	r28, 0x3d	; 61
    447a:	de b7       	in	r29, 0x3e	; 62
    447c:	8a 83       	std	Y+2, r24	; 0x02
    447e:	6b 83       	std	Y+3, r22	; 0x03
	/* Error State variable  */
	u8 Local_u8ErrorState = ERROR;
    4480:	81 e0       	ldi	r24, 0x01	; 1
    4482:	89 83       	std	Y+1, r24	; 0x01

	/* Input validation ( check if the port Number is in the valid range */
	if (Copy_u8PortNumber <= DIO_u8_PORTD )
    4484:	8a 81       	ldd	r24, Y+2	; 0x02
    4486:	84 30       	cpi	r24, 0x04	; 4
    4488:	98 f5       	brcc	.+102    	; 0x44f0 <M_DIO_u8_SetPortValue+0x82>
	{
		Local_u8ErrorState = NO_ERROR;
    448a:	19 82       	std	Y+1, r1	; 0x01

			switch (Copy_u8PortNumber)  /* check the port Number */
    448c:	8a 81       	ldd	r24, Y+2	; 0x02
    448e:	28 2f       	mov	r18, r24
    4490:	30 e0       	ldi	r19, 0x00	; 0
    4492:	3d 83       	std	Y+5, r19	; 0x05
    4494:	2c 83       	std	Y+4, r18	; 0x04
    4496:	8c 81       	ldd	r24, Y+4	; 0x04
    4498:	9d 81       	ldd	r25, Y+5	; 0x05
    449a:	81 30       	cpi	r24, 0x01	; 1
    449c:	91 05       	cpc	r25, r1
    449e:	d1 f0       	breq	.+52     	; 0x44d4 <M_DIO_u8_SetPortValue+0x66>
    44a0:	2c 81       	ldd	r18, Y+4	; 0x04
    44a2:	3d 81       	ldd	r19, Y+5	; 0x05
    44a4:	22 30       	cpi	r18, 0x02	; 2
    44a6:	31 05       	cpc	r19, r1
    44a8:	2c f4       	brge	.+10     	; 0x44b4 <M_DIO_u8_SetPortValue+0x46>
    44aa:	8c 81       	ldd	r24, Y+4	; 0x04
    44ac:	9d 81       	ldd	r25, Y+5	; 0x05
    44ae:	00 97       	sbiw	r24, 0x00	; 0
    44b0:	61 f0       	breq	.+24     	; 0x44ca <M_DIO_u8_SetPortValue+0x5c>
    44b2:	1e c0       	rjmp	.+60     	; 0x44f0 <M_DIO_u8_SetPortValue+0x82>
    44b4:	2c 81       	ldd	r18, Y+4	; 0x04
    44b6:	3d 81       	ldd	r19, Y+5	; 0x05
    44b8:	22 30       	cpi	r18, 0x02	; 2
    44ba:	31 05       	cpc	r19, r1
    44bc:	81 f0       	breq	.+32     	; 0x44de <M_DIO_u8_SetPortValue+0x70>
    44be:	8c 81       	ldd	r24, Y+4	; 0x04
    44c0:	9d 81       	ldd	r25, Y+5	; 0x05
    44c2:	83 30       	cpi	r24, 0x03	; 3
    44c4:	91 05       	cpc	r25, r1
    44c6:	81 f0       	breq	.+32     	; 0x44e8 <M_DIO_u8_SetPortValue+0x7a>
    44c8:	13 c0       	rjmp	.+38     	; 0x44f0 <M_DIO_u8_SetPortValue+0x82>
			{
				case DIO_u8_PORTA : DIO_u8_PORTA_REG = Copy_u8PortValue ; break;
    44ca:	eb e3       	ldi	r30, 0x3B	; 59
    44cc:	f0 e0       	ldi	r31, 0x00	; 0
    44ce:	8b 81       	ldd	r24, Y+3	; 0x03
    44d0:	80 83       	st	Z, r24
    44d2:	0e c0       	rjmp	.+28     	; 0x44f0 <M_DIO_u8_SetPortValue+0x82>
				case DIO_u8_PORTB : DIO_u8_PORTB_REG = Copy_u8PortValue ; break;
    44d4:	e8 e3       	ldi	r30, 0x38	; 56
    44d6:	f0 e0       	ldi	r31, 0x00	; 0
    44d8:	8b 81       	ldd	r24, Y+3	; 0x03
    44da:	80 83       	st	Z, r24
    44dc:	09 c0       	rjmp	.+18     	; 0x44f0 <M_DIO_u8_SetPortValue+0x82>
				case DIO_u8_PORTC : DIO_u8_PORTC_REG = Copy_u8PortValue ; break;
    44de:	e5 e3       	ldi	r30, 0x35	; 53
    44e0:	f0 e0       	ldi	r31, 0x00	; 0
    44e2:	8b 81       	ldd	r24, Y+3	; 0x03
    44e4:	80 83       	st	Z, r24
    44e6:	04 c0       	rjmp	.+8      	; 0x44f0 <M_DIO_u8_SetPortValue+0x82>
				case DIO_u8_PORTD : DIO_u8_PORTD_REG = Copy_u8PortValue ; break;
    44e8:	e2 e3       	ldi	r30, 0x32	; 50
    44ea:	f0 e0       	ldi	r31, 0x00	; 0
    44ec:	8b 81       	ldd	r24, Y+3	; 0x03
    44ee:	80 83       	st	Z, r24
			}

	}
	return Local_u8ErrorState;
    44f0:	89 81       	ldd	r24, Y+1	; 0x01


}
    44f2:	0f 90       	pop	r0
    44f4:	0f 90       	pop	r0
    44f6:	0f 90       	pop	r0
    44f8:	0f 90       	pop	r0
    44fa:	0f 90       	pop	r0
    44fc:	cf 91       	pop	r28
    44fe:	df 91       	pop	r29
    4500:	08 95       	ret

00004502 <M_DIO_u8_ActivePullupResistor>:
 *  Description : This Function Enables and Disables  the internal Pull-up Resistor on a specific pin
 * ----------------------------------------------------------------------------------------------
 */

u8 M_DIO_u8_ActivePullupResistor (u8 Copy_u8PortNumber ,u8 Copy_u8PinNumber , u8 Copy_u8State)
{
    4502:	df 93       	push	r29
    4504:	cf 93       	push	r28
    4506:	cd b7       	in	r28, 0x3d	; 61
    4508:	de b7       	in	r29, 0x3e	; 62
    450a:	28 97       	sbiw	r28, 0x08	; 8
    450c:	0f b6       	in	r0, 0x3f	; 63
    450e:	f8 94       	cli
    4510:	de bf       	out	0x3e, r29	; 62
    4512:	0f be       	out	0x3f, r0	; 63
    4514:	cd bf       	out	0x3d, r28	; 61
    4516:	8a 83       	std	Y+2, r24	; 0x02
    4518:	6b 83       	std	Y+3, r22	; 0x03
    451a:	4c 83       	std	Y+4, r20	; 0x04
	/* Error State variable  */
	u8 Local_u8ErrorState = ERROR ;
    451c:	81 e0       	ldi	r24, 0x01	; 1
    451e:	89 83       	std	Y+1, r24	; 0x01
	/* Input validation ( check if the port Number and Pin Number are in the valid range) */
	if (Copy_u8PortNumber <  DIO_u8_PORTD && Copy_u8PinNumber < DIO_u8_PIN7 )
    4520:	8a 81       	ldd	r24, Y+2	; 0x02
    4522:	83 30       	cpi	r24, 0x03	; 3
    4524:	08 f0       	brcs	.+2      	; 0x4528 <M_DIO_u8_ActivePullupResistor+0x26>
    4526:	41 c1       	rjmp	.+642    	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
    4528:	8b 81       	ldd	r24, Y+3	; 0x03
    452a:	87 30       	cpi	r24, 0x07	; 7
    452c:	08 f0       	brcs	.+2      	; 0x4530 <M_DIO_u8_ActivePullupResistor+0x2e>
    452e:	3d c1       	rjmp	.+634    	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
	{
		Local_u8ErrorState = NO_ERROR ;
    4530:	19 82       	std	Y+1, r1	; 0x01
		/* check the state of the Pull-up*/
		if (Copy_u8State == DIO_u8_PULLUP_RES_EN )
    4532:	8c 81       	ldd	r24, Y+4	; 0x04
    4534:	81 30       	cpi	r24, 0x01	; 1
    4536:	09 f0       	breq	.+2      	; 0x453a <M_DIO_u8_ActivePullupResistor+0x38>
    4538:	be c0       	rjmp	.+380    	; 0x46b6 <M_DIO_u8_ActivePullupResistor+0x1b4>
		{
			switch (Copy_u8PortNumber) /* check the port Number*/
    453a:	8a 81       	ldd	r24, Y+2	; 0x02
    453c:	28 2f       	mov	r18, r24
    453e:	30 e0       	ldi	r19, 0x00	; 0
    4540:	38 87       	std	Y+8, r19	; 0x08
    4542:	2f 83       	std	Y+7, r18	; 0x07
    4544:	8f 81       	ldd	r24, Y+7	; 0x07
    4546:	98 85       	ldd	r25, Y+8	; 0x08
    4548:	81 30       	cpi	r24, 0x01	; 1
    454a:	91 05       	cpc	r25, r1
    454c:	09 f4       	brne	.+2      	; 0x4550 <M_DIO_u8_ActivePullupResistor+0x4e>
    454e:	3e c0       	rjmp	.+124    	; 0x45cc <M_DIO_u8_ActivePullupResistor+0xca>
    4550:	2f 81       	ldd	r18, Y+7	; 0x07
    4552:	38 85       	ldd	r19, Y+8	; 0x08
    4554:	22 30       	cpi	r18, 0x02	; 2
    4556:	31 05       	cpc	r19, r1
    4558:	2c f4       	brge	.+10     	; 0x4564 <M_DIO_u8_ActivePullupResistor+0x62>
    455a:	8f 81       	ldd	r24, Y+7	; 0x07
    455c:	98 85       	ldd	r25, Y+8	; 0x08
    455e:	00 97       	sbiw	r24, 0x00	; 0
    4560:	71 f0       	breq	.+28     	; 0x457e <M_DIO_u8_ActivePullupResistor+0x7c>
    4562:	23 c1       	rjmp	.+582    	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
    4564:	2f 81       	ldd	r18, Y+7	; 0x07
    4566:	38 85       	ldd	r19, Y+8	; 0x08
    4568:	22 30       	cpi	r18, 0x02	; 2
    456a:	31 05       	cpc	r19, r1
    456c:	09 f4       	brne	.+2      	; 0x4570 <M_DIO_u8_ActivePullupResistor+0x6e>
    456e:	55 c0       	rjmp	.+170    	; 0x461a <M_DIO_u8_ActivePullupResistor+0x118>
    4570:	8f 81       	ldd	r24, Y+7	; 0x07
    4572:	98 85       	ldd	r25, Y+8	; 0x08
    4574:	83 30       	cpi	r24, 0x03	; 3
    4576:	91 05       	cpc	r25, r1
    4578:	09 f4       	brne	.+2      	; 0x457c <M_DIO_u8_ActivePullupResistor+0x7a>
    457a:	76 c0       	rjmp	.+236    	; 0x4668 <M_DIO_u8_ActivePullupResistor+0x166>
    457c:	16 c1       	rjmp	.+556    	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
			{
			case DIO_u8_PORTA :
				CLR_BIT(DIO_u8_DDRA_REG,Copy_u8PinNumber);  /*  set the direction of the pin to input */
    457e:	aa e3       	ldi	r26, 0x3A	; 58
    4580:	b0 e0       	ldi	r27, 0x00	; 0
    4582:	ea e3       	ldi	r30, 0x3A	; 58
    4584:	f0 e0       	ldi	r31, 0x00	; 0
    4586:	80 81       	ld	r24, Z
    4588:	48 2f       	mov	r20, r24
    458a:	8b 81       	ldd	r24, Y+3	; 0x03
    458c:	28 2f       	mov	r18, r24
    458e:	30 e0       	ldi	r19, 0x00	; 0
    4590:	81 e0       	ldi	r24, 0x01	; 1
    4592:	90 e0       	ldi	r25, 0x00	; 0
    4594:	02 c0       	rjmp	.+4      	; 0x459a <M_DIO_u8_ActivePullupResistor+0x98>
    4596:	88 0f       	add	r24, r24
    4598:	99 1f       	adc	r25, r25
    459a:	2a 95       	dec	r18
    459c:	e2 f7       	brpl	.-8      	; 0x4596 <M_DIO_u8_ActivePullupResistor+0x94>
    459e:	80 95       	com	r24
    45a0:	84 23       	and	r24, r20
    45a2:	8c 93       	st	X, r24
				SET_BIT(DIO_u8_PORTA_REG,Copy_u8PinNumber); /*  Active the pull-up resistor       */
    45a4:	ab e3       	ldi	r26, 0x3B	; 59
    45a6:	b0 e0       	ldi	r27, 0x00	; 0
    45a8:	eb e3       	ldi	r30, 0x3B	; 59
    45aa:	f0 e0       	ldi	r31, 0x00	; 0
    45ac:	80 81       	ld	r24, Z
    45ae:	48 2f       	mov	r20, r24
    45b0:	8b 81       	ldd	r24, Y+3	; 0x03
    45b2:	28 2f       	mov	r18, r24
    45b4:	30 e0       	ldi	r19, 0x00	; 0
    45b6:	81 e0       	ldi	r24, 0x01	; 1
    45b8:	90 e0       	ldi	r25, 0x00	; 0
    45ba:	02 2e       	mov	r0, r18
    45bc:	02 c0       	rjmp	.+4      	; 0x45c2 <M_DIO_u8_ActivePullupResistor+0xc0>
    45be:	88 0f       	add	r24, r24
    45c0:	99 1f       	adc	r25, r25
    45c2:	0a 94       	dec	r0
    45c4:	e2 f7       	brpl	.-8      	; 0x45be <M_DIO_u8_ActivePullupResistor+0xbc>
    45c6:	84 2b       	or	r24, r20
    45c8:	8c 93       	st	X, r24
    45ca:	ef c0       	rjmp	.+478    	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
				break;
			case DIO_u8_PORTB :
				CLR_BIT(DIO_u8_DDRB_REG,Copy_u8PinNumber);    /*  set the direction of the pin to input */
    45cc:	a7 e3       	ldi	r26, 0x37	; 55
    45ce:	b0 e0       	ldi	r27, 0x00	; 0
    45d0:	e7 e3       	ldi	r30, 0x37	; 55
    45d2:	f0 e0       	ldi	r31, 0x00	; 0
    45d4:	80 81       	ld	r24, Z
    45d6:	48 2f       	mov	r20, r24
    45d8:	8b 81       	ldd	r24, Y+3	; 0x03
    45da:	28 2f       	mov	r18, r24
    45dc:	30 e0       	ldi	r19, 0x00	; 0
    45de:	81 e0       	ldi	r24, 0x01	; 1
    45e0:	90 e0       	ldi	r25, 0x00	; 0
    45e2:	02 c0       	rjmp	.+4      	; 0x45e8 <M_DIO_u8_ActivePullupResistor+0xe6>
    45e4:	88 0f       	add	r24, r24
    45e6:	99 1f       	adc	r25, r25
    45e8:	2a 95       	dec	r18
    45ea:	e2 f7       	brpl	.-8      	; 0x45e4 <M_DIO_u8_ActivePullupResistor+0xe2>
    45ec:	80 95       	com	r24
    45ee:	84 23       	and	r24, r20
    45f0:	8c 93       	st	X, r24
				SET_BIT(DIO_u8_PORTB_REG,Copy_u8PinNumber);   /*  Active the pull-up resistor       */
    45f2:	a8 e3       	ldi	r26, 0x38	; 56
    45f4:	b0 e0       	ldi	r27, 0x00	; 0
    45f6:	e8 e3       	ldi	r30, 0x38	; 56
    45f8:	f0 e0       	ldi	r31, 0x00	; 0
    45fa:	80 81       	ld	r24, Z
    45fc:	48 2f       	mov	r20, r24
    45fe:	8b 81       	ldd	r24, Y+3	; 0x03
    4600:	28 2f       	mov	r18, r24
    4602:	30 e0       	ldi	r19, 0x00	; 0
    4604:	81 e0       	ldi	r24, 0x01	; 1
    4606:	90 e0       	ldi	r25, 0x00	; 0
    4608:	02 2e       	mov	r0, r18
    460a:	02 c0       	rjmp	.+4      	; 0x4610 <M_DIO_u8_ActivePullupResistor+0x10e>
    460c:	88 0f       	add	r24, r24
    460e:	99 1f       	adc	r25, r25
    4610:	0a 94       	dec	r0
    4612:	e2 f7       	brpl	.-8      	; 0x460c <M_DIO_u8_ActivePullupResistor+0x10a>
    4614:	84 2b       	or	r24, r20
    4616:	8c 93       	st	X, r24
    4618:	c8 c0       	rjmp	.+400    	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
				break;

			case DIO_u8_PORTC :
				CLR_BIT(DIO_u8_DDRC_REG,Copy_u8PinNumber);    /*  set the direction of the pin to input */
    461a:	a4 e3       	ldi	r26, 0x34	; 52
    461c:	b0 e0       	ldi	r27, 0x00	; 0
    461e:	e4 e3       	ldi	r30, 0x34	; 52
    4620:	f0 e0       	ldi	r31, 0x00	; 0
    4622:	80 81       	ld	r24, Z
    4624:	48 2f       	mov	r20, r24
    4626:	8b 81       	ldd	r24, Y+3	; 0x03
    4628:	28 2f       	mov	r18, r24
    462a:	30 e0       	ldi	r19, 0x00	; 0
    462c:	81 e0       	ldi	r24, 0x01	; 1
    462e:	90 e0       	ldi	r25, 0x00	; 0
    4630:	02 c0       	rjmp	.+4      	; 0x4636 <M_DIO_u8_ActivePullupResistor+0x134>
    4632:	88 0f       	add	r24, r24
    4634:	99 1f       	adc	r25, r25
    4636:	2a 95       	dec	r18
    4638:	e2 f7       	brpl	.-8      	; 0x4632 <M_DIO_u8_ActivePullupResistor+0x130>
    463a:	80 95       	com	r24
    463c:	84 23       	and	r24, r20
    463e:	8c 93       	st	X, r24
				SET_BIT(DIO_u8_PORTC_REG,Copy_u8PinNumber);   /*  Active the pull-up resistor       */
    4640:	a5 e3       	ldi	r26, 0x35	; 53
    4642:	b0 e0       	ldi	r27, 0x00	; 0
    4644:	e5 e3       	ldi	r30, 0x35	; 53
    4646:	f0 e0       	ldi	r31, 0x00	; 0
    4648:	80 81       	ld	r24, Z
    464a:	48 2f       	mov	r20, r24
    464c:	8b 81       	ldd	r24, Y+3	; 0x03
    464e:	28 2f       	mov	r18, r24
    4650:	30 e0       	ldi	r19, 0x00	; 0
    4652:	81 e0       	ldi	r24, 0x01	; 1
    4654:	90 e0       	ldi	r25, 0x00	; 0
    4656:	02 2e       	mov	r0, r18
    4658:	02 c0       	rjmp	.+4      	; 0x465e <M_DIO_u8_ActivePullupResistor+0x15c>
    465a:	88 0f       	add	r24, r24
    465c:	99 1f       	adc	r25, r25
    465e:	0a 94       	dec	r0
    4660:	e2 f7       	brpl	.-8      	; 0x465a <M_DIO_u8_ActivePullupResistor+0x158>
    4662:	84 2b       	or	r24, r20
    4664:	8c 93       	st	X, r24
    4666:	a1 c0       	rjmp	.+322    	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
				break;

			case DIO_u8_PORTD :
				CLR_BIT(DIO_u8_DDRD_REG,Copy_u8PinNumber);   /*  set the direction of the pin  to input */
    4668:	a1 e3       	ldi	r26, 0x31	; 49
    466a:	b0 e0       	ldi	r27, 0x00	; 0
    466c:	e1 e3       	ldi	r30, 0x31	; 49
    466e:	f0 e0       	ldi	r31, 0x00	; 0
    4670:	80 81       	ld	r24, Z
    4672:	48 2f       	mov	r20, r24
    4674:	8b 81       	ldd	r24, Y+3	; 0x03
    4676:	28 2f       	mov	r18, r24
    4678:	30 e0       	ldi	r19, 0x00	; 0
    467a:	81 e0       	ldi	r24, 0x01	; 1
    467c:	90 e0       	ldi	r25, 0x00	; 0
    467e:	02 c0       	rjmp	.+4      	; 0x4684 <M_DIO_u8_ActivePullupResistor+0x182>
    4680:	88 0f       	add	r24, r24
    4682:	99 1f       	adc	r25, r25
    4684:	2a 95       	dec	r18
    4686:	e2 f7       	brpl	.-8      	; 0x4680 <M_DIO_u8_ActivePullupResistor+0x17e>
    4688:	80 95       	com	r24
    468a:	84 23       	and	r24, r20
    468c:	8c 93       	st	X, r24
				SET_BIT(DIO_u8_PORTD_REG,Copy_u8PinNumber);  /*  Active the pull-up resistor       */
    468e:	a2 e3       	ldi	r26, 0x32	; 50
    4690:	b0 e0       	ldi	r27, 0x00	; 0
    4692:	e2 e3       	ldi	r30, 0x32	; 50
    4694:	f0 e0       	ldi	r31, 0x00	; 0
    4696:	80 81       	ld	r24, Z
    4698:	48 2f       	mov	r20, r24
    469a:	8b 81       	ldd	r24, Y+3	; 0x03
    469c:	28 2f       	mov	r18, r24
    469e:	30 e0       	ldi	r19, 0x00	; 0
    46a0:	81 e0       	ldi	r24, 0x01	; 1
    46a2:	90 e0       	ldi	r25, 0x00	; 0
    46a4:	02 2e       	mov	r0, r18
    46a6:	02 c0       	rjmp	.+4      	; 0x46ac <M_DIO_u8_ActivePullupResistor+0x1aa>
    46a8:	88 0f       	add	r24, r24
    46aa:	99 1f       	adc	r25, r25
    46ac:	0a 94       	dec	r0
    46ae:	e2 f7       	brpl	.-8      	; 0x46a8 <M_DIO_u8_ActivePullupResistor+0x1a6>
    46b0:	84 2b       	or	r24, r20
    46b2:	8c 93       	st	X, r24
    46b4:	7a c0       	rjmp	.+244    	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
				break;
			}
		}
		else if (Copy_u8State == DIO_u8_PULLUP_RES_DIS ) /* check the state of the Pull-up Resistor */
    46b6:	8c 81       	ldd	r24, Y+4	; 0x04
    46b8:	88 23       	and	r24, r24
    46ba:	09 f0       	breq	.+2      	; 0x46be <M_DIO_u8_ActivePullupResistor+0x1bc>
    46bc:	74 c0       	rjmp	.+232    	; 0x47a6 <M_DIO_u8_ActivePullupResistor+0x2a4>
		{
			switch (Copy_u8PortNumber)
    46be:	8a 81       	ldd	r24, Y+2	; 0x02
    46c0:	28 2f       	mov	r18, r24
    46c2:	30 e0       	ldi	r19, 0x00	; 0
    46c4:	3e 83       	std	Y+6, r19	; 0x06
    46c6:	2d 83       	std	Y+5, r18	; 0x05
    46c8:	8d 81       	ldd	r24, Y+5	; 0x05
    46ca:	9e 81       	ldd	r25, Y+6	; 0x06
    46cc:	81 30       	cpi	r24, 0x01	; 1
    46ce:	91 05       	cpc	r25, r1
    46d0:	59 f1       	breq	.+86     	; 0x4728 <M_DIO_u8_ActivePullupResistor+0x226>
    46d2:	2d 81       	ldd	r18, Y+5	; 0x05
    46d4:	3e 81       	ldd	r19, Y+6	; 0x06
    46d6:	22 30       	cpi	r18, 0x02	; 2
    46d8:	31 05       	cpc	r19, r1
    46da:	2c f4       	brge	.+10     	; 0x46e6 <M_DIO_u8_ActivePullupResistor+0x1e4>
    46dc:	8d 81       	ldd	r24, Y+5	; 0x05
    46de:	9e 81       	ldd	r25, Y+6	; 0x06
    46e0:	00 97       	sbiw	r24, 0x00	; 0
    46e2:	69 f0       	breq	.+26     	; 0x46fe <M_DIO_u8_ActivePullupResistor+0x1fc>
    46e4:	62 c0       	rjmp	.+196    	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
    46e6:	2d 81       	ldd	r18, Y+5	; 0x05
    46e8:	3e 81       	ldd	r19, Y+6	; 0x06
    46ea:	22 30       	cpi	r18, 0x02	; 2
    46ec:	31 05       	cpc	r19, r1
    46ee:	89 f1       	breq	.+98     	; 0x4752 <M_DIO_u8_ActivePullupResistor+0x250>
    46f0:	8d 81       	ldd	r24, Y+5	; 0x05
    46f2:	9e 81       	ldd	r25, Y+6	; 0x06
    46f4:	83 30       	cpi	r24, 0x03	; 3
    46f6:	91 05       	cpc	r25, r1
    46f8:	09 f4       	brne	.+2      	; 0x46fc <M_DIO_u8_ActivePullupResistor+0x1fa>
    46fa:	40 c0       	rjmp	.+128    	; 0x477c <M_DIO_u8_ActivePullupResistor+0x27a>
    46fc:	56 c0       	rjmp	.+172    	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
			{
			case DIO_u8_PORTA : CLR_BIT(DIO_u8_PORTA_REG,Copy_u8PinNumber); break; /*Disable the pull-up Resistor*/
    46fe:	ab e3       	ldi	r26, 0x3B	; 59
    4700:	b0 e0       	ldi	r27, 0x00	; 0
    4702:	eb e3       	ldi	r30, 0x3B	; 59
    4704:	f0 e0       	ldi	r31, 0x00	; 0
    4706:	80 81       	ld	r24, Z
    4708:	48 2f       	mov	r20, r24
    470a:	8b 81       	ldd	r24, Y+3	; 0x03
    470c:	28 2f       	mov	r18, r24
    470e:	30 e0       	ldi	r19, 0x00	; 0
    4710:	81 e0       	ldi	r24, 0x01	; 1
    4712:	90 e0       	ldi	r25, 0x00	; 0
    4714:	02 2e       	mov	r0, r18
    4716:	02 c0       	rjmp	.+4      	; 0x471c <M_DIO_u8_ActivePullupResistor+0x21a>
    4718:	88 0f       	add	r24, r24
    471a:	99 1f       	adc	r25, r25
    471c:	0a 94       	dec	r0
    471e:	e2 f7       	brpl	.-8      	; 0x4718 <M_DIO_u8_ActivePullupResistor+0x216>
    4720:	80 95       	com	r24
    4722:	84 23       	and	r24, r20
    4724:	8c 93       	st	X, r24
    4726:	41 c0       	rjmp	.+130    	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
			case DIO_u8_PORTB :	CLR_BIT(DIO_u8_PORTB_REG,Copy_u8PinNumber); break; /*Disable the pull-up Resistor*/
    4728:	a8 e3       	ldi	r26, 0x38	; 56
    472a:	b0 e0       	ldi	r27, 0x00	; 0
    472c:	e8 e3       	ldi	r30, 0x38	; 56
    472e:	f0 e0       	ldi	r31, 0x00	; 0
    4730:	80 81       	ld	r24, Z
    4732:	48 2f       	mov	r20, r24
    4734:	8b 81       	ldd	r24, Y+3	; 0x03
    4736:	28 2f       	mov	r18, r24
    4738:	30 e0       	ldi	r19, 0x00	; 0
    473a:	81 e0       	ldi	r24, 0x01	; 1
    473c:	90 e0       	ldi	r25, 0x00	; 0
    473e:	02 2e       	mov	r0, r18
    4740:	02 c0       	rjmp	.+4      	; 0x4746 <M_DIO_u8_ActivePullupResistor+0x244>
    4742:	88 0f       	add	r24, r24
    4744:	99 1f       	adc	r25, r25
    4746:	0a 94       	dec	r0
    4748:	e2 f7       	brpl	.-8      	; 0x4742 <M_DIO_u8_ActivePullupResistor+0x240>
    474a:	80 95       	com	r24
    474c:	84 23       	and	r24, r20
    474e:	8c 93       	st	X, r24
    4750:	2c c0       	rjmp	.+88     	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
			case DIO_u8_PORTC :	CLR_BIT(DIO_u8_PORTC_REG,Copy_u8PinNumber); break; /*Disable the pull-up Resistor*/
    4752:	a5 e3       	ldi	r26, 0x35	; 53
    4754:	b0 e0       	ldi	r27, 0x00	; 0
    4756:	e5 e3       	ldi	r30, 0x35	; 53
    4758:	f0 e0       	ldi	r31, 0x00	; 0
    475a:	80 81       	ld	r24, Z
    475c:	48 2f       	mov	r20, r24
    475e:	8b 81       	ldd	r24, Y+3	; 0x03
    4760:	28 2f       	mov	r18, r24
    4762:	30 e0       	ldi	r19, 0x00	; 0
    4764:	81 e0       	ldi	r24, 0x01	; 1
    4766:	90 e0       	ldi	r25, 0x00	; 0
    4768:	02 2e       	mov	r0, r18
    476a:	02 c0       	rjmp	.+4      	; 0x4770 <M_DIO_u8_ActivePullupResistor+0x26e>
    476c:	88 0f       	add	r24, r24
    476e:	99 1f       	adc	r25, r25
    4770:	0a 94       	dec	r0
    4772:	e2 f7       	brpl	.-8      	; 0x476c <M_DIO_u8_ActivePullupResistor+0x26a>
    4774:	80 95       	com	r24
    4776:	84 23       	and	r24, r20
    4778:	8c 93       	st	X, r24
    477a:	17 c0       	rjmp	.+46     	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
			case DIO_u8_PORTD :	CLR_BIT(DIO_u8_PORTD_REG,Copy_u8PinNumber); break; /*Disable the pull-up Resistor*/
    477c:	a2 e3       	ldi	r26, 0x32	; 50
    477e:	b0 e0       	ldi	r27, 0x00	; 0
    4780:	e2 e3       	ldi	r30, 0x32	; 50
    4782:	f0 e0       	ldi	r31, 0x00	; 0
    4784:	80 81       	ld	r24, Z
    4786:	48 2f       	mov	r20, r24
    4788:	8b 81       	ldd	r24, Y+3	; 0x03
    478a:	28 2f       	mov	r18, r24
    478c:	30 e0       	ldi	r19, 0x00	; 0
    478e:	81 e0       	ldi	r24, 0x01	; 1
    4790:	90 e0       	ldi	r25, 0x00	; 0
    4792:	02 2e       	mov	r0, r18
    4794:	02 c0       	rjmp	.+4      	; 0x479a <M_DIO_u8_ActivePullupResistor+0x298>
    4796:	88 0f       	add	r24, r24
    4798:	99 1f       	adc	r25, r25
    479a:	0a 94       	dec	r0
    479c:	e2 f7       	brpl	.-8      	; 0x4796 <M_DIO_u8_ActivePullupResistor+0x294>
    479e:	80 95       	com	r24
    47a0:	84 23       	and	r24, r20
    47a2:	8c 93       	st	X, r24
    47a4:	02 c0       	rjmp	.+4      	; 0x47aa <M_DIO_u8_ActivePullupResistor+0x2a8>
			}

		}
		else { Local_u8ErrorState = ERROR ;	}
    47a6:	81 e0       	ldi	r24, 0x01	; 1
    47a8:	89 83       	std	Y+1, r24	; 0x01

	}

	return Local_u8ErrorState ;
    47aa:	89 81       	ldd	r24, Y+1	; 0x01
}
    47ac:	28 96       	adiw	r28, 0x08	; 8
    47ae:	0f b6       	in	r0, 0x3f	; 63
    47b0:	f8 94       	cli
    47b2:	de bf       	out	0x3e, r29	; 62
    47b4:	0f be       	out	0x3f, r0	; 63
    47b6:	cd bf       	out	0x3d, r28	; 61
    47b8:	cf 91       	pop	r28
    47ba:	df 91       	pop	r29
    47bc:	08 95       	ret

000047be <main>:
void T_L3 (void * PV_Param);



void main (void )
{
    47be:	af 92       	push	r10
    47c0:	bf 92       	push	r11
    47c2:	cf 92       	push	r12
    47c4:	df 92       	push	r13
    47c6:	ef 92       	push	r14
    47c8:	ff 92       	push	r15
    47ca:	0f 93       	push	r16
    47cc:	df 93       	push	r29
    47ce:	cf 93       	push	r28
    47d0:	cd b7       	in	r28, 0x3d	; 61
    47d2:	de b7       	in	r29, 0x3e	; 62
	M_DIO_void_DIOInit();
    47d4:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <M_DIO_void_DIOInit>

	xTaskCreate(T_L1,NULL,100,NULL,1,NULL);
    47d8:	8b e2       	ldi	r24, 0x2B	; 43
    47da:	94 e2       	ldi	r25, 0x24	; 36
    47dc:	60 e0       	ldi	r22, 0x00	; 0
    47de:	70 e0       	ldi	r23, 0x00	; 0
    47e0:	44 e6       	ldi	r20, 0x64	; 100
    47e2:	50 e0       	ldi	r21, 0x00	; 0
    47e4:	20 e0       	ldi	r18, 0x00	; 0
    47e6:	30 e0       	ldi	r19, 0x00	; 0
    47e8:	01 e0       	ldi	r16, 0x01	; 1
    47ea:	ee 24       	eor	r14, r14
    47ec:	ff 24       	eor	r15, r15
    47ee:	cc 24       	eor	r12, r12
    47f0:	dd 24       	eor	r13, r13
    47f2:	aa 24       	eor	r10, r10
    47f4:	bb 24       	eor	r11, r11
    47f6:	0e 94 4f 14 	call	0x289e	; 0x289e <xTaskGenericCreate>
	xTaskCreate(T_L2,NULL,100,NULL,2,NULL);
    47fa:	8b e3       	ldi	r24, 0x3B	; 59
    47fc:	94 e2       	ldi	r25, 0x24	; 36
    47fe:	60 e0       	ldi	r22, 0x00	; 0
    4800:	70 e0       	ldi	r23, 0x00	; 0
    4802:	44 e6       	ldi	r20, 0x64	; 100
    4804:	50 e0       	ldi	r21, 0x00	; 0
    4806:	20 e0       	ldi	r18, 0x00	; 0
    4808:	30 e0       	ldi	r19, 0x00	; 0
    480a:	02 e0       	ldi	r16, 0x02	; 2
    480c:	ee 24       	eor	r14, r14
    480e:	ff 24       	eor	r15, r15
    4810:	cc 24       	eor	r12, r12
    4812:	dd 24       	eor	r13, r13
    4814:	aa 24       	eor	r10, r10
    4816:	bb 24       	eor	r11, r11
    4818:	0e 94 4f 14 	call	0x289e	; 0x289e <xTaskGenericCreate>
	xTaskCreate(T_L3,NULL,100,NULL,3,NULL);
    481c:	8b e4       	ldi	r24, 0x4B	; 75
    481e:	94 e2       	ldi	r25, 0x24	; 36
    4820:	60 e0       	ldi	r22, 0x00	; 0
    4822:	70 e0       	ldi	r23, 0x00	; 0
    4824:	44 e6       	ldi	r20, 0x64	; 100
    4826:	50 e0       	ldi	r21, 0x00	; 0
    4828:	20 e0       	ldi	r18, 0x00	; 0
    482a:	30 e0       	ldi	r19, 0x00	; 0
    482c:	03 e0       	ldi	r16, 0x03	; 3
    482e:	ee 24       	eor	r14, r14
    4830:	ff 24       	eor	r15, r15
    4832:	cc 24       	eor	r12, r12
    4834:	dd 24       	eor	r13, r13
    4836:	aa 24       	eor	r10, r10
    4838:	bb 24       	eor	r11, r11
    483a:	0e 94 4f 14 	call	0x289e	; 0x289e <xTaskGenericCreate>

	/* start scheduler */
	vTaskStartScheduler();
    483e:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <vTaskStartScheduler>

}
    4842:	cf 91       	pop	r28
    4844:	df 91       	pop	r29
    4846:	0f 91       	pop	r16
    4848:	ff 90       	pop	r15
    484a:	ef 90       	pop	r14
    484c:	df 90       	pop	r13
    484e:	cf 90       	pop	r12
    4850:	bf 90       	pop	r11
    4852:	af 90       	pop	r10
    4854:	08 95       	ret

00004856 <T_L1>:


void T_L1 (void * PV_Param)
{
    4856:	df 93       	push	r29
    4858:	cf 93       	push	r28
    485a:	00 d0       	rcall	.+0      	; 0x485c <T_L1+0x6>
    485c:	cd b7       	in	r28, 0x3d	; 61
    485e:	de b7       	in	r29, 0x3e	; 62
    4860:	9a 83       	std	Y+2, r25	; 0x02
    4862:	89 83       	std	Y+1, r24	; 0x01

	while (1)
	{

		M_DIO_u8_TogglePinValue(DIO_u8_PORTA,DIO_u8_PIN0);
    4864:	80 e0       	ldi	r24, 0x00	; 0
    4866:	60 e0       	ldi	r22, 0x00	; 0
    4868:	0e 94 62 21 	call	0x42c4	; 0x42c4 <M_DIO_u8_TogglePinValue>
		vTaskDelay(1000);
    486c:	88 ee       	ldi	r24, 0xE8	; 232
    486e:	93 e0       	ldi	r25, 0x03	; 3
    4870:	0e 94 09 16 	call	0x2c12	; 0x2c12 <vTaskDelay>
    4874:	f7 cf       	rjmp	.-18     	; 0x4864 <T_L1+0xe>

00004876 <T_L2>:

	}
}

void T_L2 (void * PV_Param)
{
    4876:	df 93       	push	r29
    4878:	cf 93       	push	r28
    487a:	00 d0       	rcall	.+0      	; 0x487c <T_L2+0x6>
    487c:	cd b7       	in	r28, 0x3d	; 61
    487e:	de b7       	in	r29, 0x3e	; 62
    4880:	9a 83       	std	Y+2, r25	; 0x02
    4882:	89 83       	std	Y+1, r24	; 0x01

	while (1)
	{

		M_DIO_u8_TogglePinValue(DIO_u8_PORTA,DIO_u8_PIN1);
    4884:	80 e0       	ldi	r24, 0x00	; 0
    4886:	61 e0       	ldi	r22, 0x01	; 1
    4888:	0e 94 62 21 	call	0x42c4	; 0x42c4 <M_DIO_u8_TogglePinValue>
		vTaskDelay(1000);
    488c:	88 ee       	ldi	r24, 0xE8	; 232
    488e:	93 e0       	ldi	r25, 0x03	; 3
    4890:	0e 94 09 16 	call	0x2c12	; 0x2c12 <vTaskDelay>
    4894:	f7 cf       	rjmp	.-18     	; 0x4884 <T_L2+0xe>

00004896 <T_L3>:

	}
}

void T_L3 (void * PV_Param)
{
    4896:	df 93       	push	r29
    4898:	cf 93       	push	r28
    489a:	00 d0       	rcall	.+0      	; 0x489c <T_L3+0x6>
    489c:	cd b7       	in	r28, 0x3d	; 61
    489e:	de b7       	in	r29, 0x3e	; 62
    48a0:	9a 83       	std	Y+2, r25	; 0x02
    48a2:	89 83       	std	Y+1, r24	; 0x01

	while (1)
	{

		M_DIO_u8_TogglePinValue(DIO_u8_PORTA,DIO_u8_PIN2);
    48a4:	80 e0       	ldi	r24, 0x00	; 0
    48a6:	62 e0       	ldi	r22, 0x02	; 2
    48a8:	0e 94 62 21 	call	0x42c4	; 0x42c4 <M_DIO_u8_TogglePinValue>
		vTaskDelay(1000);
    48ac:	88 ee       	ldi	r24, 0xE8	; 232
    48ae:	93 e0       	ldi	r25, 0x03	; 3
    48b0:	0e 94 09 16 	call	0x2c12	; 0x2c12 <vTaskDelay>
    48b4:	f7 cf       	rjmp	.-18     	; 0x48a4 <T_L3+0xe>

000048b6 <__mulsi3>:
    48b6:	62 9f       	mul	r22, r18
    48b8:	d0 01       	movw	r26, r0
    48ba:	73 9f       	mul	r23, r19
    48bc:	f0 01       	movw	r30, r0
    48be:	82 9f       	mul	r24, r18
    48c0:	e0 0d       	add	r30, r0
    48c2:	f1 1d       	adc	r31, r1
    48c4:	64 9f       	mul	r22, r20
    48c6:	e0 0d       	add	r30, r0
    48c8:	f1 1d       	adc	r31, r1
    48ca:	92 9f       	mul	r25, r18
    48cc:	f0 0d       	add	r31, r0
    48ce:	83 9f       	mul	r24, r19
    48d0:	f0 0d       	add	r31, r0
    48d2:	74 9f       	mul	r23, r20
    48d4:	f0 0d       	add	r31, r0
    48d6:	65 9f       	mul	r22, r21
    48d8:	f0 0d       	add	r31, r0
    48da:	99 27       	eor	r25, r25
    48dc:	72 9f       	mul	r23, r18
    48de:	b0 0d       	add	r27, r0
    48e0:	e1 1d       	adc	r30, r1
    48e2:	f9 1f       	adc	r31, r25
    48e4:	63 9f       	mul	r22, r19
    48e6:	b0 0d       	add	r27, r0
    48e8:	e1 1d       	adc	r30, r1
    48ea:	f9 1f       	adc	r31, r25
    48ec:	bd 01       	movw	r22, r26
    48ee:	cf 01       	movw	r24, r30
    48f0:	11 24       	eor	r1, r1
    48f2:	08 95       	ret

000048f4 <__divmodsi4>:
    48f4:	97 fb       	bst	r25, 7
    48f6:	09 2e       	mov	r0, r25
    48f8:	05 26       	eor	r0, r21
    48fa:	0e d0       	rcall	.+28     	; 0x4918 <__divmodsi4_neg1>
    48fc:	57 fd       	sbrc	r21, 7
    48fe:	04 d0       	rcall	.+8      	; 0x4908 <__divmodsi4_neg2>
    4900:	14 d0       	rcall	.+40     	; 0x492a <__udivmodsi4>
    4902:	0a d0       	rcall	.+20     	; 0x4918 <__divmodsi4_neg1>
    4904:	00 1c       	adc	r0, r0
    4906:	38 f4       	brcc	.+14     	; 0x4916 <__divmodsi4_exit>

00004908 <__divmodsi4_neg2>:
    4908:	50 95       	com	r21
    490a:	40 95       	com	r20
    490c:	30 95       	com	r19
    490e:	21 95       	neg	r18
    4910:	3f 4f       	sbci	r19, 0xFF	; 255
    4912:	4f 4f       	sbci	r20, 0xFF	; 255
    4914:	5f 4f       	sbci	r21, 0xFF	; 255

00004916 <__divmodsi4_exit>:
    4916:	08 95       	ret

00004918 <__divmodsi4_neg1>:
    4918:	f6 f7       	brtc	.-4      	; 0x4916 <__divmodsi4_exit>
    491a:	90 95       	com	r25
    491c:	80 95       	com	r24
    491e:	70 95       	com	r23
    4920:	61 95       	neg	r22
    4922:	7f 4f       	sbci	r23, 0xFF	; 255
    4924:	8f 4f       	sbci	r24, 0xFF	; 255
    4926:	9f 4f       	sbci	r25, 0xFF	; 255
    4928:	08 95       	ret

0000492a <__udivmodsi4>:
    492a:	a1 e2       	ldi	r26, 0x21	; 33
    492c:	1a 2e       	mov	r1, r26
    492e:	aa 1b       	sub	r26, r26
    4930:	bb 1b       	sub	r27, r27
    4932:	fd 01       	movw	r30, r26
    4934:	0d c0       	rjmp	.+26     	; 0x4950 <__udivmodsi4_ep>

00004936 <__udivmodsi4_loop>:
    4936:	aa 1f       	adc	r26, r26
    4938:	bb 1f       	adc	r27, r27
    493a:	ee 1f       	adc	r30, r30
    493c:	ff 1f       	adc	r31, r31
    493e:	a2 17       	cp	r26, r18
    4940:	b3 07       	cpc	r27, r19
    4942:	e4 07       	cpc	r30, r20
    4944:	f5 07       	cpc	r31, r21
    4946:	20 f0       	brcs	.+8      	; 0x4950 <__udivmodsi4_ep>
    4948:	a2 1b       	sub	r26, r18
    494a:	b3 0b       	sbc	r27, r19
    494c:	e4 0b       	sbc	r30, r20
    494e:	f5 0b       	sbc	r31, r21

00004950 <__udivmodsi4_ep>:
    4950:	66 1f       	adc	r22, r22
    4952:	77 1f       	adc	r23, r23
    4954:	88 1f       	adc	r24, r24
    4956:	99 1f       	adc	r25, r25
    4958:	1a 94       	dec	r1
    495a:	69 f7       	brne	.-38     	; 0x4936 <__udivmodsi4_loop>
    495c:	60 95       	com	r22
    495e:	70 95       	com	r23
    4960:	80 95       	com	r24
    4962:	90 95       	com	r25
    4964:	9b 01       	movw	r18, r22
    4966:	ac 01       	movw	r20, r24
    4968:	bd 01       	movw	r22, r26
    496a:	cf 01       	movw	r24, r30
    496c:	08 95       	ret

0000496e <memcpy>:
    496e:	fb 01       	movw	r30, r22
    4970:	dc 01       	movw	r26, r24
    4972:	02 c0       	rjmp	.+4      	; 0x4978 <memcpy+0xa>
    4974:	01 90       	ld	r0, Z+
    4976:	0d 92       	st	X+, r0
    4978:	41 50       	subi	r20, 0x01	; 1
    497a:	50 40       	sbci	r21, 0x00	; 0
    497c:	d8 f7       	brcc	.-10     	; 0x4974 <memcpy+0x6>
    497e:	08 95       	ret

00004980 <_exit>:
    4980:	f8 94       	cli

00004982 <__stop_program>:
    4982:	ff cf       	rjmp	.-2      	; 0x4982 <__stop_program>
